/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 52);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

var core = module.exports = { version: '2.5.1' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(35)('wks');
var uid = __webpack_require__(36);
var Symbol = __webpack_require__(2).Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),
/* 2 */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var core = __webpack_require__(0);
var ctx = __webpack_require__(10);
var hide = __webpack_require__(5);
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && key in exports) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(7);
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(6);
var createDesc = __webpack_require__(20);
module.exports = __webpack_require__(8) ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(4);
var IE8_DOM_DEFINE = __webpack_require__(56);
var toPrimitive = __webpack_require__(57);
var dP = Object.defineProperty;

exports.f = __webpack_require__(8) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(13)(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 9 */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(12);
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at = __webpack_require__(55)(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(32)(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),
/* 12 */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),
/* 13 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),
/* 14 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),
/* 15 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(18);
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),
/* 17 */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),
/* 18 */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(7);
var document = __webpack_require__(2).document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),
/* 20 */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(62);
var enumBugKeys = __webpack_require__(37);

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(34);
var defined = __webpack_require__(18);
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(17);
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(35)('keys');
var uid = __webpack_require__(36);
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(6).f;
var has = __webpack_require__(14);
var TAG = __webpack_require__(1)('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(66);
var global = __webpack_require__(2);
var hide = __webpack_require__(5);
var Iterators = __webpack_require__(9);
var TO_STRING_TAG = __webpack_require__(1)('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(15);
var TAG = __webpack_require__(1)('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(27);
var ITERATOR = __webpack_require__(1)('iterator');
var Iterators = __webpack_require__(9);
module.exports = __webpack_require__(0).getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 25.4.1.5 NewPromiseCapability(C)
var aFunction = __webpack_require__(12);

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(79), __esModule: true };

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(53), __esModule: true };

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(33);
var $export = __webpack_require__(3);
var redefine = __webpack_require__(58);
var hide = __webpack_require__(5);
var has = __webpack_require__(14);
var Iterators = __webpack_require__(9);
var $iterCreate = __webpack_require__(59);
var setToStringTag = __webpack_require__(25);
var getPrototypeOf = __webpack_require__(65);
var ITERATOR = __webpack_require__(1)('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),
/* 33 */
/***/ (function(module, exports) {

module.exports = true;


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(15);
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});
module.exports = function (key) {
  return store[key] || (store[key] = {});
};


/***/ }),
/* 36 */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),
/* 37 */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(2).document;
module.exports = document && document.documentElement;


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(4);
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(9);
var ITERATOR = __webpack_require__(1)('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__(4);
var aFunction = __webpack_require__(12);
var SPECIES = __webpack_require__(1)('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(10);
var invoke = __webpack_require__(72);
var html = __webpack_require__(38);
var cel = __webpack_require__(19);
var global = __webpack_require__(2);
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (__webpack_require__(15)(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};


/***/ }),
/* 43 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(4);
var isObject = __webpack_require__(7);
var newPromiseCapability = __webpack_require__(29);

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__(1)('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(78), __esModule: true };

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ICACRO = exports.$ELM = undefined;

var _isInteger = __webpack_require__(84);

var _isInteger2 = _interopRequireDefault(_isInteger);

var _keys = __webpack_require__(88);

var _keys2 = _interopRequireDefault(_keys);

var _assign = __webpack_require__(30);

var _assign2 = _interopRequireDefault(_assign);

var _from = __webpack_require__(48);

var _from2 = _interopRequireDefault(_from);

var _toConsumableArray2 = __webpack_require__(95);

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _slicedToArray2 = __webpack_require__(49);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _storage = __webpack_require__(118);

var _storage2 = _interopRequireDefault(_storage);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var reservedElements = ['div', 'body', 'head', 'img', 'style', 'span', 'ul', 'li', 'input', 'button', 'h1', 'h2', 'h3', 'h4', 'a', 'p', 'strong', 'svg']; /*
                                                                                                                                                          eslint no-param-reassign: [
                                                                                                                                                            "error", { "props": true, "ignorePropertyModificationsFor": ["element"] }
                                                                                                                                                          ]
                                                                                                                                                          */
/* eslint no-use-before-define: ["error", { "functions": false }] */
/* eslint-env es6 */

var GetElement = function GetElement(selector) {
  return document.querySelector(selector);
};

var $ELM_ELEMENT = function $ELM_ELEMENT(element) {
  var rect = function rect(arg) {
    return element.getBoundingClientRect()[arg];
  };
  return {
    attr: function attr() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (element) {
        var _ref = args.length === 2 ? [].concat((0, _toConsumableArray3.default)(args)) : args[0].split(':'),
            _ref2 = (0, _slicedToArray3.default)(_ref, 2),
            attr = _ref2[0],
            value = _ref2[1];

        if (value) {
          element.setAttribute(attr, value);
          return this;
        }
        return element.getAttribute(attr);
      }
      throw new Error(args + ' Element does not exist! Function \'attr\'');
    },
    height: function height() {
      return rect('height');
    },
    click: function click(callback) {
      if (element) {
        element.addEventListener('click', callback);
        return this;
      }
      throw new Error(callback + ' Element does not exist! Function \'click\'');
    },
    html: function html(str) {
      if (element) {
        if (!str) return element.innerHTML;
        element.innerHTML = str;
        return this;
      }
      throw new Error(str + ' Element does not exist! Function \'html\'');
    },
    text: function text(str) {
      if (element) {
        if (!str) return element.innerHTML;
        element.innerHTML = '';
        element.appendChild(document.createTextNode(str));
        return this;
      }
      throw new Error(str + ' Element does not exist! Function \'text\'');
    },
    image: function image(src) {
      if (element) {
        element.src = src;
        return this;
      }
      throw new Error(src + ' Element does not exist! Function \'image\'');
    },
    href: function href(url) {
      if (element) {
        element.href = url;
        return this;
      }
      throw new Error(url + ' Element does not exist! Function \'href\'');
    },
    appendFirst: function appendFirst(child) {
      var c = child.nodeType ? child : child.element;
      if (element) {
        element.insertBefore(c, element.childNodes[0]);
        return this;
      }
      throw new Error(child + ' Element does not exist! Function \'append\'');
    },
    append: function append(child) {
      var c = child.nodeType ? child : child.element;
      if (element) {
        element.appendChild(c);
        return this;
      }
      throw new Error(child + ' Element does not exist! Function \'append\'');
    },
    appendAll: function appendAll() {
      for (var _len2 = arguments.length, childs = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        childs[_key2] = arguments[_key2];
      }

      return childs.map(this.append);
    },
    css: function css(cn) {
      if (cn) {
        cn.split(' ').join(',').split(',').forEach(function (c) {
          return c && element && element.classList.add(c.replace(/\./g, '').trim());
        });
      }
      return this;
    },
    get: function get() {
      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      if (element) {
        if (args.length === 1) return $ELM_ELEMENT(element.querySelector(args[0]));
        return args.map(function (arg) {
          return $ELM_ELEMENT(element.querySelector(arg));
        });
      }
      throw new Error(args + ' Element does not exist! Function \'get\'');
    },
    children: function children(arg) {
      if (arg) {
        var _list = (0, _from2.default)(element.getElementsByTagName(arg));
        return _list.map(function (child) {
          return $ELM_ELEMENT(child);
        });
      }
      var list = (0, _from2.default)(element.childNodes);
      return list.map(function (child) {
        return $ELM_ELEMENT(child);
      });
    },
    style: function style(stl) {
      if (element) {
        (0, _assign2.default)(element.style, stl);
        return this;
      }
      throw new Error(stl + ' Element does not exist! Function \'style\'');
    },
    data: function data(key, value) {
      if (element) {
        element.dataset[key] = value;
        return this;
      }
      throw new Error(key + ' ' + value + ' Element does not exist! Function \'data\'');
    },

    element: element
  };
};

var CreateElement = function CreateElement(arg) {
  if (arg instanceof HTMLElement) return $ELM_ELEMENT(arg);
  var arr = arg.split(' ');
  var type = arr.reduce(function (acc, current) {
    if (reservedElements.includes(current)) {
      return current;
    }
    return acc;
  }, 'div');

  var classNames = arr.filter(function (current) {
    return !reservedElements.includes(current);
  }).join();
  var dom = document.createElement(type);
  return $ELM_ELEMENT(dom).css(classNames);
};

var CreateElementByObject = function CreateElementByObject(type, iterable) {
  var element = CreateElement(type);
  (0, _keys2.default)(iterable).forEach(function (item) {
    var func = element[item];
    if (func) {
      var value = iterable[item];
      if (value && value.length) {
        func(value);
      }
    }
  });
  return element;
};

var $ELM = exports.$ELM = {
  elms: {},
  create: function create() {
    for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }

    if (args.length === 1) return CreateElement(args[0]);
    return args.map(function (arg) {
      return CreateElement(arg);
    });
  },
  build: function build(type, iterable) {
    return CreateElementByObject(type, iterable);
  },
  get: function get() {
    var _this = this;

    for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }

    if (args.length === 1) {
      var key = (0, _isInteger2.default)(parseInt(args[0], 10)) ? parseInt(args[0], 10) : args[0];
      return this.elms[key] || $ELM_ELEMENT(GetElement(key));
    }
    return args.map(function (arg) {
      var key = (0, _isInteger2.default)(parseInt(arg, 10)) ? parseInt(arg, 10) : arg;
      return _this.elms[key] || $ELM_ELEMENT(GetElement(key));
    });
  },
  save: function save(id, element) {
    this.elms[id] = this.elms[id] || {};
    this.elms[id] = element;
  },
  copy: function copy(selector) {
    var child = GetElement(selector);
    if (child) {
      return CreateElement(child.cloneNode(true));
    }
    throw new Error(selector + ' Element does not exist! Function \'copy\'');
  }
};

var ICACRO = exports.ICACRO = function ICACRO() {
  $ELM.get('body').css('cro');
  return {
    getElementContentByTagAndAttr: function getElementContentByTagAndAttr(regexp, tag, attr) {
      var qsa = document.querySelectorAll(tag);
      return this.toArray(qsa).reduce(function (acc, element) {
        if (new RegExp(regexp).test(element[attr])) {
          acc.push(element[attr]);
        }
        return acc;
      }, []);
    },
    removeElements: function removeElements(classNames) {
      classNames.forEach(function (className) {
        var elm = document.querySelector(className);
        if (elm instanceof HTMLElement) elm.parentNode.removeChild(elm);
      });
    },
    toArray: function toArray(list) {
      return Array.prototype.slice.call(list);
    },
    load: function load() {
      for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }

      var _args = (0, _slicedToArray3.default)(args, 2),
          url = _args[0],
          options = _args[1];

      var ops = (0, _assign2.default)({}, { method: 'get' }, options);
      return fetch(url, ops).then(function (response) {
        return response.json();
      }).catch(function (err) {
        return err;
      });
    },
    style: function style(styles) {
      console.log('style is deprecated... use css and require.');
      var style = $ELM.create('style');
      style.attr('type', 'text/css');
      style.append(document.createTextNode(styles));
      $ELM.get('head').append(style);
    },
    isLoggedIn: function isLoggedIn() {
      return $ELM.get('#hdnIcaState').attr('value').length > 1;
    },
    gaPush: function gaPush(_ref3) {
      var _ref3$eventCategory = _ref3.eventCategory,
          eventCategory = _ref3$eventCategory === undefined ? 'A/B' : _ref3$eventCategory,
          eventAction = _ref3.eventAction,
          eventLabel = _ref3.eventLabel;

      if (ga) {
        ga('send', 'event', eventCategory, eventAction, eventLabel);
      }
    },

    storage: {
      set: function set(key, value) {
        _storage2.default.set(key, value);
      },
      get: function get(key) {
        return _storage2.default.get(key);
      },
      clear: function clear() {
        _storage2.default.clear();
      }
    }
  };
};

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(92), __esModule: true };

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _isIterable2 = __webpack_require__(96);

var _isIterable3 = _interopRequireDefault(_isIterable2);

var _getIterator2 = __webpack_require__(99);

var _getIterator3 = _interopRequireDefault(_getIterator2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if ((0, _isIterable3.default)(Object(arr))) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

/***/ }),
/* 50 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getElement = (function (fn) {
	var memo = {};

	return function(selector) {
		if (typeof memo[selector] === "undefined") {
			var styleTarget = fn.call(this, selector);
			// Special case to return head of iframe instead of iframe itself
			if (styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[selector] = styleTarget;
		}
		return memo[selector]
	};
})(function (target) {
	return document.querySelector(target)
});

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(115);

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton) options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
	if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertInto + " " + options.insertAt.before);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	options.attrs.type = "text/css";

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _promise = __webpack_require__(31);

var _promise2 = _interopRequireDefault(_promise);

var _stringify = __webpack_require__(46);

var _stringify2 = _interopRequireDefault(_stringify);

var _assign = __webpack_require__(30);

var _assign2 = _interopRequireDefault(_assign);

var _main = __webpack_require__(47);

var _ratings = __webpack_require__(102);

var _ratings2 = _interopRequireDefault(_ratings);

var _banners = __webpack_require__(103);

var _banners2 = _interopRequireDefault(_banners);

var _coupons = __webpack_require__(104);

var _coupons2 = _interopRequireDefault(_coupons);

__webpack_require__(116);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(function ($) {
  'use strict';

  var LOGIN_ACTION = {
    SAVE_RECIPE: 'SPARA',
    LOAD_COUPON: 'LADDA'
  };
  var ACTION_COOKIES = {
    SAVE_RECIPE: 'cro_startpage_actionCookie_saveRecipe',
    LOAD_COUPON: 'cro_startpage_actionCookie_loadCoupon'
  };
  var loadedCoupons = [];

  // if (hj) hj('trigger','variant5');// eslint-disable-line
  var test = {
    create: function create(className, parent, text, type) {
      var t = type || 'div';
      var div = document.createElement(t);
      if (text && type === 'img') {
        div.src = text;
      } else if (text) {
        div.appendChild(document.createTextNode(text));
      }
      if (className) div.className = className;
      if (parent) parent.appendChild(div);
      return div;
    },
    addCoupon: function addCoupon(coupon) {
      var _this = this;

      var couponItem = _main.$ELM.create('coupons-container__item');
      var img = _main.$ELM.create('img');
      var title = _main.$ELM.create('h3');
      var discount = _main.$ELM.create('h1');
      var subtitle = _main.$ELM.create('h4');
      var moreInfo = _main.$ELM.create('a');
      var button = _main.$ELM.create('button .button coupon-button');

      title.text(coupon.title);
      discount.text(coupon.discount);
      subtitle.text(coupon.subtitle);
      moreInfo.text('Mer info');
      button.text('Ladda kupong');
      img.image(coupon.image);
      moreInfo.href(coupon.url);

      button.click(function () {
        if (_this.isLoggedIn()) {
          _this.loadCouponOnCard(coupon).then(function (response) {
            _this.changeOfferStatus(response, coupon);
          });
        } else {
          icadatalayer.add('HSE', {
            HSE: {
              action: 'login-mousedown',
              name: coupon.PageName,
              hseurl: coupon.url
            }
          });

          var cookieData = {
            PageName: coupon.PageName,
            recipeId: coupon.recipeId,
            title: coupon.PageName,
            url: coupon.PageName,
            OfferId: coupon.Offer,
            CampaignId: coupon.PageName
          };

          _this.setActionCookie(ACTION_COOKIES.LOAD_COUPON, cookieData);
          _this.createModal(LOGIN_ACTION.LOAD_COUPON);
        }
      });

      icadatalayer.add('HSE', {
        HSE: {
          action: 'display',
          title: coupon.PageName,
          hseurl: coupon.url
        }
      });
      couponItem.attr('id', 'coupon-' + coupon.OfferId + '-' + coupon.recipeId);
      this.loadCouponData(coupon).then(function (data) {
        if (data.Offer.LoadedOnCard) {
          couponItem.css('offer-loaded');
          button.text('Kupong laddad');
        }
      });
      couponItem.appendAll(img, title, discount, subtitle, moreInfo, button);
      return couponItem;
    },
    addBanner: function addBanner(banner) {
      var _this2 = this;

      var bannerContainer = _main.$ELM.create('li banner-container');
      var bannerContainerImg = _main.$ELM.create('banner-container__img');
      var img = _main.$ELM.create('img');
      img.image(banner.image);
      bannerContainerImg.append(img);
      bannerContainerImg.image(banner.image);
      // bannerContainerImg.style({
      //   background: `url(${banner.image})`,
      //   'background-size': 'contain',
      //   'background-repeat': 'no-repeat',
      // });
      var textContainer = _main.$ELM.create('banner-container__text-container');
      var title = _main.$ELM.create('h1 text-container__title');
      var ratings = _main.$ELM.create('text-container__ratings');
      var difficulty = _main.$ELM.create('h4 text-container__difficulty');
      var couponsWrapper = _main.$ELM.create('coupons-container');
      var saveButton = this.createSaveRecipeCTA(banner);

      ratings.html((0, _ratings2.default)(banner.stars));
      title.text(banner.title);
      difficulty.text(banner.cookTime);

      banner.coupons.forEach(function (coupon) {
        couponsWrapper.append(_this2.addCoupon(coupon));
      });

      textContainer.appendAll(title, ratings, difficulty);
      bannerContainer.appendAll(bannerContainerImg, textContainer, saveButton, couponsWrapper);
      return bannerContainer;
    },
    addStyle: function addStyle(element, stl) {
      (0, _assign2.default)(element.style, stl);
    },
    addBanners: function addBanners() {
      var _this3 = this;

      var header = _main.$ELM.get('.header');
      var ul = _main.$ELM.create('ul cro-slider');
      header.html(' ');
      _banners2.default.forEach(function (banner) {
        ul.append(_this3.addBanner(banner));
      });
      header.append(ul);
      // console.log(ul.children('li')[0].height());
      // ul.style({
      //   width: `${100 * banners.length}%`,
      //   // height: `${ul.children('li')[0].height().toString()}px`,
      // });
      $('.cro-slider').slick({
        adaptiveHeight: true
      });
    },
    addIcaCard: function addIcaCard() {
      var self = this;
      var icaImageContainer = self.create('ica-card-container');
      self.create('', icaImageContainer, 'Få rabatt med ICA-Kort', 'h1');
      var usps = self.create('usp-list', icaImageContainer, null, 'ul');
      usps.innerHTML = '\n      <li><svg viewBox="0 0 32 32" width="15px" height="15px"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="/Assets/icons/sprite.svg#check"></use></svg> ICA-kort med bonus</li>\n      <li><svg viewBox="0 0 32 32" width="15px" height="15px"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="/Assets/icons/sprite.svg#check"></use></svg> Personliga erbjudanden</li>\n      <li><svg viewBox="0 0 32 32" width="15px" height="15px"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="/Assets/icons/sprite.svg#check"></use></svg> Kortpriser varje vecka</li>\n      ';
      self.create('', icaImageContainer, 'https://www.ica.se/ImageVaultFiles/id_78649/cf_3/ICA_Kort_och_Bank.png', 'img');
      self.create('button', icaImageContainer, 'Skapa konto och bli medlem', 'a').href = '/ansokan/?step=6369766963666f726d';
      document.querySelector('.main').appendChild(icaImageContainer);
    },
    dinnerTonight: function dinnerTonight() {
      var container = _main.$ELM.get('.search-recipe-container');
      var recipeTrendingList = _main.$ELM.get('.recipe-trending-list');
      var img = _main.$ELM.create('img').image('/imagevaultfiles/id_124300/cf_259/nyttiga_recept.jpg');
      var seeAll = _main.$ELM.copy('.search-recipe-container__all-recipes');
      this.removeElements(['.search-recipe-container__all-recipes']);
      recipeTrendingList.append(seeAll);
      container.appendFirst(img);
      container.get('h1').text('Vad blir det för middag ikväll?');
    },
    manipulateDom: function manipulateDom() {
      this.removeElements(['.image-slider li', '.image-slider .lazy-spinner', '.header-content', '.push-items-list', '.quicklink-list', '.main .link-list', '.recipe-category-listing .banner-image', '.recipe-category-listing > .col-12 > h2', '.search-recipe-container__recipe-count', '.recipe-category-listing .recipe-list-items']);
      this.addBanners();
      this.createOffers();
      this.addIcaCard();
      this.dinnerTonight();
      var returnUrl = encodeURIComponent(window.location.href);
      var iframeContainer = $('<div class="cro-iframe-container"><span class="loader"></span><iframe src="//www.ica.se/logga-in/?returnurl=' + returnUrl + '" frameborder="0"></iframe></div>');
      $('body').append(iframeContainer);
    },
    createSaveRecipeCTA: function createSaveRecipeCTA(banner) {
      var _this4 = this;

      var container = _main.$ELM.create('button-wrapper');
      var cta = _main.$ELM.create('a .button banner-button');
      cta.text('Lägg recept i inköpslistan');
      cta.href('/logga-in/?returnUrl=' + encodeURIComponent(window.location));
      cta.data('recipeId', banner.recipeId);
      cta.data('tracking', '{ "name": "' + banner.title + '", "URL": "' + banner.url + '" }');
      cta.css('js-add-to-new-shoppinglist banner-button-' + banner.recipeId);

      var savedRecipes = this.getSavedRecipes();
      if (savedRecipes.includes(banner.recipeId)) {
        cta.css('saved');
        cta.text('Recept tillagt i inköpslistan');
      }

      cta.click(function (e) {
        e.preventDefault();
        if (_this4.isLoggedIn()) {
          _this4.addRecipeToShoppingList(banner.recipeId);
          _this4.saveRecipe(banner.recipeId);
          _this4.addRecipeToSavedList(banner.recipeId);
          cta.css('saved');
          cta.text('Recept tillagt i inköpslistan');
        } else {
          _this4.setActionCookie(ACTION_COOKIES.SAVE_RECIPE, banner.recipeId);
          _this4.createModal(LOGIN_ACTION.SAVE_RECIPE);
        }
      });
      container.append(cta);
      return container;
    },
    createOffers: function createOffers() {
      var main = _main.$ELM.get('.main');
      var container = _main.$ELM.create('div coupon-banner');
      var offerButton = _main.$ELM.create('a .button offers-button').text('Gå till ICAs kuponger').href('/erbjudanden/butikserbjudanden/alla-digitala-kuponger/');
      var img = _main.$ELM.create('img').image('https://raw.githubusercontent.com/Banzaci/ica/master/src/start-page/Coupons_image.png');
      container.appendAll(img, offerButton);
      main.append(container);
    },
    addRecipeToShoppingList: function addRecipeToShoppingList(recipeId) {
      // tracking sker via klassnamn

      ICA.ajax.post('/Templates/Recipes/Handlers/ShoppingListHandler.ashx', {
        recipeIds: [recipeId],
        ShoppingListId: 0,
        numberOfServings: 0,
        recipes: [],
        shoppingListName: createShoppingsListName()
      });

      function createShoppingsListName() {
        var d = new Date();
        var year = d.getFullYear();
        var month = d.getMonth();
        var day = d.getDate();
        var months = { 10: 'nov', 11: 'dec' }; // testet kommer endast ligga ute i nov, senast dec

        return 'Att handla, ' + day + ' ' + months[month] + ' ' + year;
      }
    },
    saveRecipe: function saveRecipe(recipeId) {
      var banner = _banners2.default.filter(function (b) {
        return b.recipeId === recipeId;
      })[0];

      dataLayer.push({
        event: 'recipe-save',
        name: banner.title,
        URL: banner.url
      });

      ICA.ajax.get('/Templates/Recipes/Handlers/FavoriteRecipesHandler.ashx', {
        recipeId: recipeId,
        method: 'Add'
      });
    },
    setActionCookie: function setActionCookie(cookieName, cookieData) {
      // TODO: Flytta till main.js
      var d = new Date();
      d.setDate(new Date().getDate() + 1); // expires tomorrow

      ICA.legacy.setCookie(cookieName, (0, _stringify2.default)(cookieData), d);
    },
    getActionCookie: function getActionCookie(cookieName) {
      // TODO: Flytta till main.js
      var actionCookie = ICA.legacy.getCookie(cookieName);

      if (!actionCookie) {
        return null;
      }

      ICA.legacy.killCookie(cookieName);
      return JSON.parse(actionCookie);
    },
    checkActionCookies: function checkActionCookies() {
      var _this5 = this;

      if (!this.isLoggedIn) return;

      var recipeId = this.getActionCookie(ACTION_COOKIES.SAVE_RECIPE);
      if (recipeId) {
        this.addRecipeToShoppingList(recipeId);
        this.saveRecipe(recipeId);
        this.addRecipeToSavedList(recipeId);
        var cta = _main.$ELM.get('banner-button-' + recipeId);
        cta.css('saved');
        cta.text('Recept tillagt i inköpslistan');
      }

      var coupon = this.getActionCookie(ACTION_COOKIES.LOAD_COUPON);
      if (coupon) {
        this.loadCouponOnCard(coupon).then(function (response) {
          _this5.changeOfferStatus(response, coupon);
        });
      }
    },
    addRecipeToSavedList: function addRecipeToSavedList(recipeId) {
      var self = this;
      var d = new Date();
      d.setDate(new Date().getDate() + 1); // expires tomorrow

      var savedRecipes = self.getSavedRecipes();

      savedRecipes.push(recipeId);

      ICA.legacy.setCookie('cro_start_savedRecipes', (0, _stringify2.default)(savedRecipes), d);
    },
    getSavedRecipes: function getSavedRecipes() {
      var cookie = ICA.legacy.getCookie('cro_start_savedRecipes');
      return cookie ? JSON.parse(cookie) : [];
    },
    changeOfferStatus: function changeOfferStatus(response, coupon) {
      if (response.ok) {
        _main.$ELM.get('#coupon-' + coupon.OfferId + '-' + coupon.recipeId).css('offer-loaded');
        _main.$ELM.get('#coupon-' + coupon.OfferId + '-' + coupon.recipeId + ' .coupon-button').text('Kupong laddad');
      }
    },

    // hotjarTriggered: false,
    loaderIsActive: false,
    buttonHandlerPollTimeout: null,
    showLoader: function showLoader() {
      var container = $('.cro-iframe-container');
      container.find('.loader').show();
      container.find('iframe').css('opacity', '0');
      this.loaderIsActive = true;
    },
    hideLoader: function hideLoader() {
      var container = $('.cro-iframe-container');
      container.find('.loader').hide();
      container.find('iframe').css('opacity', '1');
      this.loaderIsActive = false;
    },
    addButtonHandlerPoll: function addButtonHandlerPoll() {
      var self = this;
      var iframe = $('.cro-iframe-container iframe');
      var e = iframe.contents().find('.remodal-wrapper #grey-card-btn, .remodal-wrapper .pink-card-btn');

      if (e.length) {
        e.click(function () {
          self.showLoader();
        });
        window.clearTimeout(self.buttonHandlerPollTimeout);
      } else {
        self.buttonHandlerPollTimeout = window.setTimeout(self.addButtonHandlerPoll.bind(self), 1000);
      }
    },
    addEventListeners: function addEventListeners() {
      var self = this;

      $('.header').off('mousedown');

      $(window).on('message onmessage', function (e) {
        var origin = window.location.protocol + '//' + window.location.host;
        if (e.originalEvent.origin === origin && /mobilebankid/i.test(e.originalEvent.data)) {
          self.showLoader();
        }
      });
    },
    getIframeStyles: function getIframeStyles() {
      return '<style type="text/css">\n        @media  (max-width: 767px) {\n        h3.greeting, h3.card-heading { font-size: 18px; }\n        img.card-icon { width: 50px; }\n        .select-card-modal { border: 0; padding: 0; margin: 0; }\n        .remodal-wrapper { padding: 0; }\n        }\n        </style>';
    },
    createModal: function createModal() {
      var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : LOGIN_ACTION.SAVE_RECIPE;

      var self = this;
      var modal = new coreComponents.modal({
        tpl: $('.cro-iframe-container').get(0),
        size: 'md',
        container: $('.modal-container').get(0)
      });

      setTimeout(function () {
        self.showLoader();

        var iframe = $('.cro-iframe-container iframe');

        iframe.on('load', function () {
          var regex = new RegExp('^' + window.location.href + '$', 'gi');
          if (regex.test(this.contentWindow.location)) {
            window.location.reload(true);
          }

          if (this.contentWindow.location.href.indexOf('logga-in') !== -1) {
            var _hideHeaderBar = function _hideHeaderBar() {
              var e = $('.cro-iframe-container iframe').contents().find('.header-bar');
              if (e.length) {
                e.hide();
                window.clearTimeout(headerBarTimeout);
                hideHeaderBarDeferred.resolve();
              } else {
                headerBarTimeout = window.setTimeout(_hideHeaderBar, 0);
              }
            };

            var _appendHeader = function _appendHeader() {
              var e = $('.cro-iframe-container iframe').contents().find('h1');
              if (e.length) {
                var message = action === LOGIN_ACTION.SAVE_RECIPE ? ' för att lägga till i inköpslistan och spara recept' : ' för att ladda kupongen';
                e.append(message);
                e.css({ 'font-family': 'icahand, arial, sans-serif', 'font-size': '3rem' });

                if (window.screen.width < 768) {
                  e.css('font-size', '18px');
                  e.parent().css('margin', '0');
                }
                window.clearTimeout(appendHeaderTimeout);
                appendHeaderDeferred.resolve();
              } else {
                appendHeaderTimeout = window.setTimeout(_appendHeader, 0);
              }
            };

            var _addStyles = function _addStyles() {
              var e = $('.cro-iframe-container iframe').contents().find('body');
              if (e.length) {
                e.append(self.getIframeStyles());
                window.clearTimeout(addStylesTimeout);
                addStylesDeferred.resolve();
              } else {
                addStylesTimeout = window.setTimeout(_addStyles, 0);
              }
            };

            var _addIframeTracking = function _addIframeTracking() {
              var e = $('.cro-iframe-container iframe').contents();
              if (e.length) {
                var eventAction = action === LOGIN_ACTION.SAVE_RECIPE ? 'Spara recept från startsidan' : 'Ladda kupong från startsida';

                // Fortsätt (Mobilt BankId)
                e.find('#submit-login-mobile-bank-id').on('click', function () {
                  ga('send', 'event', 'A/B', eventAction, 'Logga in - Mobilt BankId');
                });

                // Behöver du hjälp (Mobilt BankId)
                e.find('.login-support-bank-id-link').on('click', function () {
                  ga('send', 'event', 'A/B', eventAction, 'Behöver du hjälp');
                });

                // Skapa konto (Mobilt BankId)
                e.find('.get-mobile-bank-id-link').on('click', function () {
                  ga('send', 'event', 'A/B', eventAction, 'Skapa konto - Mobilt BankId');
                });

                // Logga in (Lösenord)
                e.find('#log-in-submit').on('click', function () {
                  ga('send', 'event', 'A/B', eventAction, 'Logga in - Lösenord');
                });

                // Glömt lösenord (Lösenord)
                e.find('.login-support-password-link').on('click', function () {
                  ga('send', 'event', 'A/B', eventAction, 'Glömt lösenord');
                });

                // Skapa konto (Lösenord)
                e.find('.create-account-link').on('click', function () {
                  ga('send', 'event', 'A/B', eventAction, 'Skapa konto - Lösenord');
                });

                window.clearTimeout(addIframeTrackingTimeout);
                addIframeTrackingDeferred.resolve();
              } else {
                addIframeTrackingTimeout = window.setTimeout(_addIframeTracking, 0);
              }
            };

            var headerBarTimeout = window.setTimeout(_hideHeaderBar, 10);
            var appendHeaderTimeout = window.setTimeout(_appendHeader, 10);
            var addStylesTimeout = window.setTimeout(_addStyles, 10);
            var addIframeTrackingTimeout = window.setTimeout(_addIframeTracking, 10);
            var hideHeaderBarDeferred = $.Deferred();
            var appendHeaderDeferred = $.Deferred();
            var addStylesDeferred = $.Deferred();
            var addIframeTrackingDeferred = $.Deferred();

            $.when(hideHeaderBarDeferred, appendHeaderDeferred, addStylesDeferred, addIframeTrackingDeferred).done(function () {
              self.hideLoader();
            });
          }

          $('.cro-iframe-container iframe').contents().find('form').on('submit', function () {
            if (!$(this).find('input.error').length) {
              self.showLoader();
            }
          });

          $('.cro-iframe-container iframe').contents().find('#submit-login-mobile-bank-id').on('click', function () {
            if (!$(this).find('input.error').length) {
              self.buttonHandlerPollTimeout = setTimeout(self.addButtonHandlerPoll.bind(self), 1000);
            }
          });

          $('.cro-iframe-container iframe').contents().find('a[href*="www.ica.se"]').each(function () {
            $(this).attr('href', $(this).attr('href').replace('http://', 'https://'));
          }).click(function (e) {
            window.location.href = $(this).attr('href');
            e.preventDefault();
          });
        });

        // trigga hotjar heatmap första gången modalen öppnats
        // if (typeof hj === 'function' && !self.hotjarTriggered) {
        //     hj('trigger', 'variant');
        //     self.hotjarTriggered = true;
        // }
      }, 50);
    },
    loadCouponData: function loadCouponData(coupon) {
      return loadedCoupons[coupon.OfferId] ? _promise2.default.resolve(loadedCoupons[coupon.OfferId]) : window.fetch('/api/jsonhse/' + coupon.id, { credentials: 'same-origin' }).then(function (response) {
        return response.json();
      }).then(function (json) {
        loadedCoupons[coupon.OfferId] = json;
        return json;
      });
    },
    loadCouponOnCard: function loadCouponOnCard(coupon) {
      var opts = {
        OfferId: coupon.OfferId,
        CampaignId: coupon.CampaignId,
        StoreId: 0,
        StoreGroupId: 0
      };

      return window.fetch('/api/jsonhse/Claimoffer', {
        credentials: 'same-origin',
        method: 'POST',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        body: (0, _stringify2.default)(opts)
      }).then(function (response) {
        if (response.ok) {
          icadatalayer.add('HSE', {
            HSE: {
              action: 'coupon-loaded',
              name: coupon.PageName,
              offer: coupon.title,
              hseurl: coupon.url
            }
          });
        }
        return response;
      });
    }
  };

  $(document).ready(function () {
    var IC = (0, _main.ICACRO)();
    if (/^https:\/\/www.ica.se\/$/.test(window.location)) {
      (0, _assign2.default)(test, IC);
      test.checkActionCookies();
      test.manipulateDom();
      test.addEventListeners();
    }
    if (/^https:\/\/www.ica.se\/erbjudanden\/butikserbjudanden\/alla-digitala-kuponger\/$/.test(window.location)) {
      _coupons2.default.manipulateDom(IC, function () {
        test.createModal(LOGIN_ACTION.LOAD_COUPON);
      });
    }
  });
})(jQuery); /* eslint no-inner-declarations: "off" */
/* eslint no-use-before-define: "off" */

// ==UserScript==
// @name         Start-page
// @path         //./src/start-page/variant.js
// @namespace    http://tampermonkey.net/
// @version      0.1
// @match        https://www.ica.se/*
// @grant        none
// ==/UserScript==

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(54);
__webpack_require__(11);
__webpack_require__(26);
__webpack_require__(69);
__webpack_require__(76);
__webpack_require__(77);
module.exports = __webpack_require__(0).Promise;


/***/ }),
/* 54 */
/***/ (function(module, exports) {



/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(17);
var defined = __webpack_require__(18);
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(8) && !__webpack_require__(13)(function () {
  return Object.defineProperty(__webpack_require__(19)('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(7);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(5);


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__(60);
var descriptor = __webpack_require__(20);
var setToStringTag = __webpack_require__(25);
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(5)(IteratorPrototype, __webpack_require__(1)('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(4);
var dPs = __webpack_require__(61);
var enumBugKeys = __webpack_require__(37);
var IE_PROTO = __webpack_require__(24)('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(19)('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(38).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(6);
var anObject = __webpack_require__(4);
var getKeys = __webpack_require__(21);

module.exports = __webpack_require__(8) ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(14);
var toIObject = __webpack_require__(22);
var arrayIndexOf = __webpack_require__(63)(false);
var IE_PROTO = __webpack_require__(24)('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(22);
var toLength = __webpack_require__(23);
var toAbsoluteIndex = __webpack_require__(64);
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(17);
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(14);
var toObject = __webpack_require__(16);
var IE_PROTO = __webpack_require__(24)('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(67);
var step = __webpack_require__(68);
var Iterators = __webpack_require__(9);
var toIObject = __webpack_require__(22);

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(32)(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),
/* 67 */
/***/ (function(module, exports) {

module.exports = function () { /* empty */ };


/***/ }),
/* 68 */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(33);
var global = __webpack_require__(2);
var ctx = __webpack_require__(10);
var classof = __webpack_require__(27);
var $export = __webpack_require__(3);
var isObject = __webpack_require__(7);
var aFunction = __webpack_require__(12);
var anInstance = __webpack_require__(70);
var forOf = __webpack_require__(71);
var speciesConstructor = __webpack_require__(41);
var task = __webpack_require__(42).set;
var microtask = __webpack_require__(73)();
var newPromiseCapabilityModule = __webpack_require__(29);
var perform = __webpack_require__(43);
var promiseResolve = __webpack_require__(44);
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[__webpack_require__(1)('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value);
            if (domain) domain.exit();
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  if (promise._h == 1) return false;
  var chain = promise._a || promise._c;
  var i = 0;
  var reaction;
  while (chain.length > i) {
    reaction = chain[i++];
    if (reaction.fail || !isUnhandled(reaction.promise)) return false;
  } return true;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = __webpack_require__(74)($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
__webpack_require__(25)($Promise, PROMISE);
__webpack_require__(75)(PROMISE);
Wrapper = __webpack_require__(0)[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(45)(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});


/***/ }),
/* 70 */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(10);
var call = __webpack_require__(39);
var isArrayIter = __webpack_require__(40);
var anObject = __webpack_require__(4);
var toLength = __webpack_require__(23);
var getIterFn = __webpack_require__(28);
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;


/***/ }),
/* 72 */
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var macrotask = __webpack_require__(42).set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__(15)(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver
  } else if (Observer) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    var promise = Promise.resolve();
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

var hide = __webpack_require__(5);
module.exports = function (target, src, safe) {
  for (var key in src) {
    if (safe && target[key]) target[key] = src[key];
    else hide(target, key, src[key]);
  } return target;
};


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(2);
var core = __webpack_require__(0);
var dP = __webpack_require__(6);
var DESCRIPTORS = __webpack_require__(8);
var SPECIES = __webpack_require__(1)('species');

module.exports = function (KEY) {
  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// https://github.com/tc39/proposal-promise-finally

var $export = __webpack_require__(3);
var core = __webpack_require__(0);
var global = __webpack_require__(2);
var speciesConstructor = __webpack_require__(41);
var promiseResolve = __webpack_require__(44);

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-promise-try
var $export = __webpack_require__(3);
var newPromiseCapability = __webpack_require__(29);
var perform = __webpack_require__(43);

$export($export.S, 'Promise', { 'try': function (callbackfn) {
  var promiseCapability = newPromiseCapability.f(this);
  var result = perform(callbackfn);
  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
  return promiseCapability.promise;
} });


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(0);
var $JSON = core.JSON || (core.JSON = { stringify: JSON.stringify });
module.exports = function stringify(it) { // eslint-disable-line no-unused-vars
  return $JSON.stringify.apply($JSON, arguments);
};


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(80);
module.exports = __webpack_require__(0).Object.assign;


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(3);

$export($export.S + $export.F, 'Object', { assign: __webpack_require__(81) });


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = __webpack_require__(21);
var gOPS = __webpack_require__(82);
var pIE = __webpack_require__(83);
var toObject = __webpack_require__(16);
var IObject = __webpack_require__(34);
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__(13)(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;


/***/ }),
/* 82 */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),
/* 83 */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(85), __esModule: true };

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(86);
module.exports = __webpack_require__(0).Number.isInteger;


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var $export = __webpack_require__(3);

$export($export.S, 'Number', { isInteger: __webpack_require__(87) });


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var isObject = __webpack_require__(7);
var floor = Math.floor;
module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(89), __esModule: true };

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(90);
module.exports = __webpack_require__(0).Object.keys;


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__(16);
var $keys = __webpack_require__(21);

__webpack_require__(91)('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(3);
var core = __webpack_require__(0);
var fails = __webpack_require__(13);
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(11);
__webpack_require__(93);
module.exports = __webpack_require__(0).Array.from;


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ctx = __webpack_require__(10);
var $export = __webpack_require__(3);
var toObject = __webpack_require__(16);
var call = __webpack_require__(39);
var isArrayIter = __webpack_require__(40);
var toLength = __webpack_require__(23);
var createProperty = __webpack_require__(94);
var getIterFn = __webpack_require__(28);

$export($export.S + $export.F * !__webpack_require__(45)(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $defineProperty = __webpack_require__(6);
var createDesc = __webpack_require__(20);

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _from = __webpack_require__(48);

var _from2 = _interopRequireDefault(_from);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  } else {
    return (0, _from2.default)(arr);
  }
};

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(97), __esModule: true };

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(26);
__webpack_require__(11);
module.exports = __webpack_require__(98);


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(27);
var ITERATOR = __webpack_require__(1)('iterator');
var Iterators = __webpack_require__(9);
module.exports = __webpack_require__(0).isIterable = function (it) {
  var O = Object(it);
  return O[ITERATOR] !== undefined
    || '@@iterator' in O
    // eslint-disable-next-line no-prototype-builtins
    || Iterators.hasOwnProperty(classof(O));
};


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(100), __esModule: true };

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(26);
__webpack_require__(11);
module.exports = __webpack_require__(101);


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(4);
var get = __webpack_require__(28);
module.exports = __webpack_require__(0).getIterator = function (it) {
  var iterFn = get(it);
  if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');
  return anObject(iterFn.call(it));
};


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (stars) {
  var arr = ['0', '26', '52', '78', '104'];
  var strs = arr.map(function (x, index) {
    return '<g transform="translate(' + x + ' 0)" class="' + (index < stars ? 'active' : '') + '">\n      <path d="M23.2 10.303q.194.509-.073.97-1.188 2.182-5.067 5.479 1.018 4.194 1.212 6.715.049.679-.533 1.067-.315.194-.63.194-.242 0-.533-.121-.412-.242-1.333-.679-3.273-1.624-4.606-2.473-1.333.849-4.606 2.473-.921.436-1.333.679-.606.315-1.164-.073-.582-.388-.533-1.067.194-2.521 1.212-6.715-3.879-3.297-5.067-5.479-.267-.461-.073-.97.17-.509.63-.679 1.358-.606 6.861-.8 1.988-5.77 3.248-7.03.388-.339.824-.339.461 0 .8.339 1.285 1.261 3.273 7.03 5.503.194 6.861.8.461.194.63.679z"></path>\n      </g>';
  });
  return '<svg xmlns="http://www.w3.org/2000/svg" viewBox="-0.12099626660346985 1.4550001621246338 127.39400121569633 25.34600469470024">\n  <linearGradient id="half" x1="0" x2="100%" y1="0" y2="0">\n  <stop offset="50%" stop-color="currentColor"></stop>\n  <stop offset="50%" stop-color="#d5d7da"></stop>\n  </linearGradient>\n  ' + strs.join('') + '\n  </svg>';
};

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = [{
  recipeId: 718382,
  title: 'Lasagne med halloumi, spenat och pumpakärnor',
  stars: 4,
  cookTime: '60 MIN | MEDEL',
  image: 'https://www.ica.se/imagevaultfiles/id_106734/cf_259/lasagne-med-halloumi-spenat-och-pumpakarnor-718382.png',
  url: 'https://www.ica.se/recept/lasagne-med-halloumi-spenat-och-pumpakarnor-718382/',
  coupons: [{
    id: 458278,
    recipeId: 718382,
    title: 'Bönpasta/ lasagneplattor',
    image: 'https://www.ica.se/Handlers/Image.ashx?w=150&h=150&m=p&bgr=fff&u=http://extbild.ica.se//PictureWeb/80/1030/14_1000555309.jpg',
    discount: '20% rabatt',
    subtitle: 'Risenta 120-200 g',
    url: '/kampanj/hse/458278',
    PageName: 'LSR 1030 Bönpasta/lasagneplattor',
    OfferId: 1000555309,
    CampaignId: 1030
  }, {
    id: 458276,
    recipeId: 718382,
    title: 'Buljongkuber',
    image: 'https://www.ica.se/Handlers/Image.ashx?w=150&h=150&m=p&bgr=fff&u=http://extbild.ica.se//PictureWeb/80/1028/14_1000555307.jpg',
    discount: '25% rabatt',
    subtitle: 'Knorr 6-pack',
    url: '/kampanj/hse/458276',
    PageName: 'LSR 1028 Buljong',
    OfferId: 1000555307,
    CampaignId: 1028
  }]
}, {
  recipeId: 722803,
  title: 'Pasta med falafel och ärtpesto',
  stars: 3,
  cookTime: '45 MIN | MEDEL',
  image: 'https://www.ica.se/imagevaultfiles/id_168851/cf_259/pasta-med-falafel-artpesto-722803-700x654.jpg',
  url: 'https://www.ica.se/recept/pasta-med-falafel-och-artpesto-722803/',
  coupons: [{
    id: 458280,
    recipeId: 722803,
    title: 'Falafel',
    image: 'https://www.ica.se/Handlers/Image.ashx?w=150&h=150&m=p&bgr=fff&u=http://extbild.ica.se//PictureWeb/80/1031/14_1000555310.jpg',
    discount: '5 kr rabatt',
    subtitle: 'Findus 450 g',
    url: '/kampanj/hse/458280',
    PageName: 'LSR 1031 Falafel',
    OfferId: 1000555310,
    CampaignId: 1031
  }, {
    id: 458277,
    recipeId: 722803,
    title: 'iMat',
    image: 'https://www.ica.se/Handlers/Image.ashx?w=150&h=150&m=p&bgr=fff&u=http://extbild.ica.se//PictureWeb/80/1029/14_1000555308.jpg',
    discount: '15% rabatt',
    subtitle: 'Oatly 250 g',
    url: '/kampanj/hse/458277',
    PageName: 'LSR 1029 iMat',
    OfferId: 1000555308,
    CampaignId: 1029
  }]
}, {
  recipeId: 722867,
  title: 'Fryst cheesecake med saffran',
  stars: 4,
  cookTime: '1-4 TIM | MEDEL',
  image: 'https://www.ica.se/imagevaultfiles/id_170800/cf_259/fryst-cheesecake-med-saffran-722867-liten.jpg',
  url: 'https://www.ica.se/recept/fryst-cheesecake-med-saffran-722867/',
  coupons: [{
    id: 458282,
    recipeId: 722867,
    title: 'Färskost',
    image: 'https://www.ica.se/Handlers/Image.ashx?w=150&h=150&m=p&bgr=fff&u=http://extbild.ica.se//PictureWeb/80/1033/14_1000555312.jpg',
    discount: '3 kr rabatt',
    subtitle: 'Philadelphia 175-300 g',
    url: '/kampanj/hse/458282',
    PageName: 'LSR 1033 Färskost Philadelpia',
    OfferId: 1000555312,
    CampaignId: 1033
  }, {
    id: 458274,
    recipeId: 722867,
    title: 'Margarin',
    image: 'https://www.ica.se/Handlers/Image.ashx?w=150&h=150&m=p&bgr=fff&u=http://extbild.ica.se//PictureWeb/80/1026/14_1000555305.jpg',
    discount: '5 kr rabatt',
    subtitle: 'Milda 1 kg',
    url: '/kampanj/hse/458274',
    PageName: 'LSR 1026 Margarin',
    OfferId: 1000555305,
    CampaignId: 1026
  }]
}, {
  recipeId: 719374,
  title: 'Torsk i ugn med dill- och citronsås',
  stars: 4,
  cookTime: '30 MIN | MEDEL',
  image: 'https://www.ica.se/imagevaultfiles/id_122727/cf_259/torsk-i-ugn-med-dill-och-citronsas-v38-2015-719374.jpg',
  url: 'https://www.ica.se/recept/torsk-i-ugn-med-dill-och-citronsas-719374/',
  coupons: [{
    id: 458288,
    recipeId: 719374,
    title: 'Torskfilé',
    image: 'https://www.ica.se/Handlers/Image.ashx?w=150&h=150&m=p&bgr=fff&u=http://extbild.ica.se//PictureWeb/80/1038/14_1000555317.jpg',
    discount: '25% rabatt',
    subtitle: 'ICA 600 g',
    url: '/kampanj/hse/458288',
    PageName: 'LSR 1038 Torskfilé',
    OfferId: 1000555317,
    CampaignId: 1038
  }, {
    id: 458274,
    recipeId: 719374,
    title: 'Margarin',
    image: 'https://www.ica.se/Handlers/Image.ashx?w=150&h=150&m=p&bgr=fff&u=http://extbild.ica.se//PictureWeb/80/1026/14_1000555305.jpg',
    discount: '5 kr rabatt',
    subtitle: 'Milda 1 kg',
    url: '/kampanj/hse/458274',
    PageName: 'LSR 1026 Margarin',
    OfferId: 1000555305,
    CampaignId: 1026
  }]
}, {
  recipeId: 721310,
  title: 'Glutenfri saffranskaka',
  stars: 4,
  cookTime: '1-4 TIM | MEDEL',
  image: 'https://www.ica.se/imagevaultfiles/id_150397/cf_259/glutenfri-saffranskaka-721310-liten.jpg',
  url: 'https://www.ica.se/recept/glutenfri-saffranskaka-721310/',
  coupons: [{
    id: 458298,
    recipeId: 721310,
    title: 'Mandelmassa',
    image: 'https://www.ica.se/Handlers/Image.ashx?w=150&h=150&m=p&bgr=fff&u=http://extbild.ica.se//PictureWeb/80/1044/14_1000555323.jpg',
    discount: '25 % rabatt',
    subtitle: 'ICA 200 g',
    url: '/kampanj/hse/458298',
    PageName: 'LSR 1044 Mandelmassa',
    OfferId: 1000555323,
    CampaignId: 1044
  }, {
    id: 458274,
    recipeId: 721310,
    title: 'Margarin',
    image: 'https://www.ica.se/Handlers/Image.ashx?w=150&h=150&m=p&bgr=fff&u=http://extbild.ica.se//PictureWeb/80/1026/14_1000555305.jpg',
    discount: '5 kr rabatt',
    subtitle: 'Milda 1 kg',
    url: '/kampanj/hse/458274',
    PageName: 'LSR 1026 Margarin',
    OfferId: 1000555305,
    CampaignId: 1026
  }]
}, {
  recipeId: 722922,
  title: 'Mozartkulor',
  stars: 5,
  cookTime: '30 MIN | MEDEL',
  image: 'https://www.ica.se/imagevaultfiles/id_172499/cf_259/mozartkulor-722922-580x580.jpg',
  url: 'https://www.ica.se/recept/mozartkulor-722922/',
  coupons: [{
    id: 458298,
    recipeId: 722922,
    title: 'Mandelmassa',
    image: 'https://www.ica.se/Handlers/Image.ashx?w=150&h=150&m=p&bgr=fff&u=http://extbild.ica.se//PictureWeb/80/1044/14_1000555323.jpg',
    discount: '25 % rabatt',
    subtitle: 'ICA 200 g',
    url: '/kampanj/hse/458298',
    PageName: 'LSR 1044 Mandelmassa',
    OfferId: 1000555323,
    CampaignId: 1044
  }, {
    id: 458297,
    recipeId: 722922,
    title: 'Baknougat',
    image: 'https://www.ica.se/Handlers/Image.ashx?w=150&h=150&m=p&bgr=fff&u=http://extbild.ica.se//PictureWeb/80/1043/14_1000555322.jpg',
    discount: '5 kr rabatt',
    subtitle: 'ICA 250 g',
    url: '/kampanj/hse/458297',
    PageName: 'LSR 1043 Baknougat',
    OfferId: 1000555322,
    CampaignId: 1043
  }]
}];

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = __webpack_require__(30);

var _assign2 = _interopRequireDefault(_assign);

var _defineProperty2 = __webpack_require__(105);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _regenerator = __webpack_require__(109);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _stringify = __webpack_require__(46);

var _stringify2 = _interopRequireDefault(_stringify);

var _asyncToGenerator2 = __webpack_require__(112);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _slicedToArray2 = __webpack_require__(49);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _main = __webpack_require__(47);

__webpack_require__(113);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var coupons = {
  printBanner: function printBanner(content, _ref) {
    var _this = this;

    var title = _ref.title,
        discount = _ref.discount,
        preamble = _ref.preamble,
        url = _ref.url,
        img = _ref.img,
        isUsed = _ref.isUsed,
        id = _ref.id,
        data = _ref.data;

    var isUsedClass = isUsed ? ' is-used' : '';

    var _$ELM$create = _main.$ELM.create('banner', 'banner-row', 'banner-column', 'banner-column grow-one', 'banner-column', 'banner-column__image', 'h1', 'span', 'p', 'img', 'a', 'button .button download ' + isUsedClass),
        _$ELM$create2 = (0, _slicedToArray3.default)(_$ELM$create, 12),
        bannerElement = _$ELM$create2[0],
        bannerRow = _$ELM$create2[1],
        bannerColumn1 = _$ELM$create2[2],
        bannerColumn2 = _$ELM$create2[3],
        bannerColumn3 = _$ELM$create2[4],
        imgElement = _$ELM$create2[5],
        titleElement = _$ELM$create2[6],
        discountElement = _$ELM$create2[7],
        preambleElement = _$ELM$create2[8],
        imgHolder = _$ELM$create2[9],
        readMore = _$ELM$create2[10],
        downLoad = _$ELM$create2[11];

    var buttonText = isUsed ? 'Kupong laddad' : 'Ladda kupong';

    imgHolder.image(img);
    imgElement.append(imgHolder);

    readMore.href('/kampanj/hse/' + id).text('Läs mer');
    downLoad.href(url).text(buttonText);

    titleElement.html(title);
    discountElement.html(discount);
    preambleElement.html(preamble);

    bannerColumn1.append(imgElement);
    bannerColumn2.appendAll(titleElement, discountElement, preambleElement, readMore);
    bannerColumn3.append(downLoad);

    bannerRow.appendAll(bannerColumn1, bannerColumn2, bannerColumn3);
    bannerElement.append(bannerRow);
    content.append(bannerElement);

    downLoad.click(function (event) {
      return _this.onClick(event, data);
    });
    _main.$ELM.save(id, bannerElement);

    icadatalayer.add('HSE', {
      HSE: {
        action: 'display',
        title: data.PageName,
        hseurl: '/kampanj/hse/' + data.CampaignId
      }
    });
  },
  loadCouponOnCard: function () {
    var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(data) {
      return _regenerator2.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.load('/api/jsonhse/Claimoffer', {
                credentials: 'same-origin',
                method: 'POST',
                headers: {
                  Accept: 'application/json',
                  'Content-Type': 'application/json'
                },
                body: (0, _stringify2.default)(data)
              });

            case 2:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function loadCouponOnCard(_x) {
      return _ref2.apply(this, arguments);
    }

    return loadCouponOnCard;
  }(),
  checkActionCookie: function checkActionCookie() {
    var coupon = this.storage.get('coupon');
    if (coupon && this.isLoggedIn()) {
      this.storage.remove('coupon');
      this.loadCouponOnCard(coupon);
    }
  },
  deactivateCoupon: function deactivateCoupon(id) {
    _main.$ELM.get(id).get('button').css('is-used');
  },
  onClick: function () {
    var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(event, data) {
      return _regenerator2.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              event.preventDefault();

              if (!this.isLoggedIn()) {
                _context2.next = 8;
                break;
              }

              this.deactivateCoupon(data.CampaignId);
              _context2.next = 5;
              return this.loadCouponOnCard(data);

            case 5:
              icadatalayer.add('HSE', {
                HSE: {
                  action: 'coupon-loaded',
                  name: data.PageName,
                  offer: data.ProductName,
                  hseurl: '/kampanj/hse/' + data.CampaignId
                }
              });
              _context2.next = 11;
              break;

            case 8:
              icadatalayer.add('HSE', {
                HSE: {
                  action: 'login-mousedown',
                  name: data.PageName,
                  hseurl: '/kampanj/hse/' + data.CampaignId
                }
              });
              this.storage.set('coupon', data);
              this.createModal();

            case 11:
            case 'end':
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function onClick(_x2, _x3) {
      return _ref3.apply(this, arguments);
    }

    return onClick;
  }(),
  loadBanners: function loadBanners(ids, content) {
    var _this2 = this;

    ids.forEach(function (id) {
      _this2.load('https://www.ica.se/api/jsonhse/' + id, { credentials: 'same-origin' }).then(function (response) {
        var _data;

        var PageName = response.PageName,
            Header = response.Header,
            Offer = response.Offer,
            CampaignId = response.CampaignId,
            StoreGroupId = response.StoreGroupId,
            StoreId = response.StoreId;
        var ProductName = Offer.ProductName,
            LoadedOnCard = Offer.LoadedOnCard,
            OfferCondition = Offer.OfferCondition,
            Brand = Offer.Brand,
            SizeOrQuantity = Offer.SizeOrQuantity,
            OfferId = Offer.OfferId;


        var data = (_data = {
          CampaignId: CampaignId,
          ProductName: ProductName
        }, (0, _defineProperty3.default)(_data, 'CampaignId', CampaignId), (0, _defineProperty3.default)(_data, 'PageName', PageName), (0, _defineProperty3.default)(_data, 'OfferId', OfferId), (0, _defineProperty3.default)(_data, 'StoreId', StoreId), (0, _defineProperty3.default)(_data, 'StoreGroupId', StoreGroupId), _data);
        _this2.printBanner(content, {
          data: data,
          id: CampaignId,
          isUsed: LoadedOnCard,
          title: Header,
          discount: OfferCondition.Conditions[0],
          preamble: Brand + ' ' + SizeOrQuantity.Text,
          url: '',
          img: Offer.Image.ImageUrl
        });
      });
    });
  },
  addIframe: function addIframe() {
    var returnUrl = encodeURIComponent(window.location.href);
    var iframe = _main.$ELM.create('cro-iframe-container');
    var iframeContainer = '<span class="loader"></span><iframe src="//www.ica.se/logga-in/?returnurl=' + returnUrl + '" frameborder="0"></iframe>';
    iframe.html(iframeContainer);
    _main.$ELM.get('body').append(iframe);
  },
  manipulateDom: function manipulateDom(ICACRO, createModal) {
    (0, _assign2.default)(this, ICACRO, { createModal: createModal });
    var content = _main.$ELM.get('#content');
    var regexp = /www.ica.se\/kampanj\/hse/g;
    var banners = this.getElementContentByTagAndAttr(regexp, 'a', 'href');
    var ids = banners.map(function (banner) {
      return banner.match(/\d+$/)[0];
    });
    this.addIframe();
    content.html(' ');
    this.loadBanners(ids, content);
    this.checkActionCookie();
    this.storage.clear();
  }
};

exports.default = coupons;

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(106);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (obj, key, value) {
  if (key in obj) {
    (0, _defineProperty2.default)(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(107), __esModule: true };

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(108);
var $Object = __webpack_require__(0).Object;
module.exports = function defineProperty(it, key, desc) {
  return $Object.defineProperty(it, key, desc);
};


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(3);
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__(8), 'Object', { defineProperty: __webpack_require__(6).f });


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(110);


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g = (function() { return this })() || Function("return this")();

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = __webpack_require__(111);

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}


/***/ }),
/* 111 */
/***/ (function(module, exports) {

/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  (function() { return this })() || Function("return this")()
);


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _promise = __webpack_require__(31);

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (fn) {
  return function () {
    var gen = fn.apply(this, arguments);
    return new _promise2.default(function (resolve, reject) {
      function step(key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }

        if (info.done) {
          resolve(value);
        } else {
          return _promise2.default.resolve(value).then(function (value) {
            step("next", value);
          }, function (err) {
            step("throw", err);
          });
        }
      }

      return step("next");
    });
  };
};

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(114);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {"hmr":true}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(51)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../node_modules/css-loader/index.js!./coupons-style.css", function() {
			var newContent = require("!!../../node_modules/css-loader/index.js!./coupons-style.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(50)(undefined);
// imports


// module
exports.push([module.i, ".cro .grow-one { flex-grow: 1; }\r\n.cro .banner { display:flex; background-color: #F8EBF3; margin-bottom: 10px; }\r\n.cro .banner.is-used { background-color: rgba(247,247,247,1); }\r\n.cro .banner-row {\r\ndisplay:flex;\r\nwidth:100%;\r\nalign-items: center;\r\nbackground-color: white;\r\nmargin: 10px 15px;\r\nposition: relative;\r\n}\r\n.cro .banner-row::after {\r\nbackground:url(\"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIxLjAuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCAxMCAyMCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgMTAgMjA7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCS5zdDB7ZmlsbDojRjhFQkYzO30KPC9zdHlsZT4KPHBhdGggY2xhc3M9InN0MCIgZD0iTTIuNDk3MDIxLDkuOTg4ODA3YzAsNC4xNDIxNTEsMy4zNTc4NDksNy41MDAwMDEsNy41LDcuNTAwMDAxdi0xNQoJQzUuODU0ODcsMi40ODg4MDcsMi40OTcwMjEsNS44NDY2NTYsMi40OTcwMjEsOS45ODg4MDd6Ii8+Cjwvc3ZnPgo=\") space;\r\nbackground-size: 13px 26px;\r\nbottom: 0;\r\ncontent: '';\r\ndisplay: block;\r\nheight: 100%;\r\nposition: absolute;\r\nright: 0;\r\ntop: 0;\r\nwidth: 13px;\r\n}\r\n.cro .banner .banner-column:first-child { margin-left: 10px; }\r\n.cro .banner .banner-column:last-child {  margin-right: 10px; }\r\n.cro .banner .banner-column { padding: 10px; }\r\n.cro .banner .banner-column .download {\r\n  font-size: 12px;\r\n  align-items: center;\r\n  background: #F8EBF3;\r\n  font-weight: bold;\r\n  color: rgba(160,41,113,1);\r\n  cursor: pointer;\r\n  display: flex;\r\n  flex-direction: column;\r\n  justify-content: center;\r\n  margin: 10px 10px 10px 0;\r\n  border-radius: 6rem;\r\n  width: 100px;\r\n  line-height: 1.4rem;\r\n  padding-bottom: 10px;\r\n}\r\n.cro .banner .banner-column .download.is-used {\r\n  background: #DDE9BF;\r\n  color: #8DB72C;\r\n  pointer-events: none;\r\n  transition: width .2s ease, color .2s 250ms ease, background .2s ease\r\n}\r\n.cro .banner .banner-column h1 { font-size: 1.6rem; word-break: break-all;}\r\n.cro .banner .banner-column span {\r\n  color: #EB1F07;\r\n  font-family: icarubrik;\r\n  font-size: 2.2rem;\r\n  font-weight: bold;\r\n}\r\n.cro .banner .banner-column p {\r\n  color: #808283;\r\n  font-size: 1.3rem;\r\n  margin: 0;\r\n}\r\n/*rgba(141,183,44,1)*/\r\n.cro .banner .banner-column h1.is-used,\r\n.cro .banner .banner-column span.is-used,\r\n.cro .banner .banner-column p.is-used { color: #D5D7DA; }\r\n.cro .banner .banner-column .banner-column__more-info { font-size: 20px; }\r\n.cro .banner-column__image {\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  text-align: center;\r\n  width: 150px;\r\n  height: 150px;\r\n}\r\n.cro .banner-column__image img {\r\n  max-width: 100%;\r\n  max-height: 100%;\r\n  width: auto;\r\n  height: auto;\r\n}\r\n.cro .banner-column__image img.is-used {\r\n  opacity: .3;\r\n}\r\n@media only screen and (max-width: 780px){\r\n  .cro .banner-column__image {\r\n    width: 65px;\r\n    height: 65px;\r\n  }\r\n  #page {\r\n    padding: 0 5px 5px;\r\n  }\r\n  .cro .banner .banner-column:first-child { padding: 10px; margin-left: 0; }\r\n  .cro .banner .banner-column:last-child { padding: 10px 10px 10px 0; margin-right: 0; }\r\n  .cro .banner .banner-column { padding: 10px 0; }\r\n}\r\n", ""]);

// exports


/***/ }),
/* 115 */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(117);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {"hmr":true}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(51)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../node_modules/css-loader/index.js!./style.css", function() {
			var newContent = require("!!../../node_modules/css-loader/index.js!./style.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(50)(undefined);
// imports


// module
exports.push([module.i, "/*.cro header .image-slider {\r\n  position: absolute !important;\r\n}*/\r\n\r\n/*\r\nbackground-position: -338px -1885px; prev\r\n\r\n\r\nbackground-position: -438px -1885px;\r\n */\r\n\r\n.cro #header {\r\n  background-color: white;\r\n}\r\n\r\n.slick-slide, .slick-track:focus {\r\n  outline: none;\r\n}\r\n.start-page-icase #header {\r\n  height: 100%;\r\n}\r\n.coupon-banner {\r\n  text-align: center;\r\n  margin-bottom: 30px;\r\n  background-color: #F8EBF3;\r\n}\r\n.coupon-banner img {\r\n  margin: 10px 0 0;\r\n}\r\n.cro .search-recipe-container {\r\n  margin-bottom: 20px;\r\n}\r\n.cro .search-recipe-container img {\r\n  margin-bottom: 20px;\r\n}\r\n.cro .search-recipe-container h1, .coupon-banner h1 {\r\n  font-size: 2.8rem;\r\n}\r\n.cro .search-recipe-container__all-recipes {\r\n  font-size: 2.2rem;\r\n}\r\n.cro .pl .container-backdrop {\r\n  padding: 15px 10px 30px;\r\n}\r\n\r\n.slick-prev:before, .slick-next:before { content: '' }\r\n.slick-prev {\r\n  top: 170px;\r\n  left: -10px;\r\n  background-position: -338px -1885px;\r\n  width: 50px !important;\r\n  height: 50px !important;\r\n}\r\n.slick-next {\r\n  top: 170px;\r\n  right: -10px;\r\n  background-position: -438px -1885px;\r\n  width: 50px !important;\r\n  height: 50px !important;\r\n}\r\n\r\n.cro .slick-prev:hover,\r\n.cro .slick-prev:focus,\r\n.cro .slick-prev:active {\r\n  background-color: transparent;\r\n  background-position: -338px -1885px;\r\n}\r\n.cro .slick-next:hover,\r\n.cro .slick-next:focus,\r\n.cro .slick-next:active {\r\n  background-color: transparent;\r\n  background-position: -438px -1885px;\r\n}\r\n.cro .slick-arrow {\r\n  background-color: transparent;\r\n  background-image: url('/Templates/General/Views/Images/RWD/sprites/general_sprite1.png?1');\r\n  background-repeat: no-repeat;\r\n}\r\nbutton:focus, button:active {outline:0;}\r\n.slick-initialized .slick-slider {\r\n  outline: none;\r\n}\r\n.cro .banner-container {\r\n  width: 100%;\r\n  height: 100%;\r\n  background-color: white;\r\n  z-index: 20 !important;\r\n  display: inline-block;\r\n}\r\n\r\n.cro .banner-container__img {\r\n  width: inherit;\r\n  height: 320px;\r\n  position: absolute;\r\n  top: 0;\r\n  overflow: hidden;\r\n}\r\n\r\n.cro .banner-container__img img { height: auto; width: 100%; }\r\n\r\n.cro .banner-container__text-container {\r\n  max-width: 100%;\r\n  margin: 110px 35px 10px;\r\n  text-shadow: 0 0 5px rgba(0, 0, 0, 0.4);\r\n  position: relative;\r\n}\r\n\r\n.cro .text-container__title {\r\n  font-size: 36px;\r\n  color: white;\r\n  font-family: icarubrik;\r\n  font-weight: 600;\r\n  line-height: 3rem;\r\n  white-space: normal;\r\n}\r\n\r\n.cro .text-container__ratings svg .active {\r\n  fill: #EB1F07;\r\n}\r\n\r\n.cro .text-container__ratings svg {\r\n  /*display: inline-block;*/\r\n  display: block;\r\n  fill: #D5D7DA;\r\n  height: 18px;\r\n  vertical-align: middle;\r\n  width: 91px;\r\n  -webkit-filter: drop-shadow( 1px 1px 2px rgba(0,0,0,0.4) );\r\n  filter: drop-shadow( 1px 1px 2px rgba(0,0,0,0.4) );\r\n}\r\n\r\n.cro .text-container__difficulty {\r\n  text-transform: uppercase;\r\n  font: 16px icatext;\r\n  font-weight: 900;\r\n  margin-top: 6px;\r\n  color: white;\r\n}\r\n\r\n.cro .coupons-container {\r\n  width: 100%;\r\n  z-index: 999;\r\n  display: flex;\r\n  flex-direction: row;\r\n  padding: 5px;\r\n  /*margin-bottom: 20px;*/\r\n}\r\n\r\n.cro .coupons-container__item {\r\n  background-color: white;\r\n  width: 50%;\r\n  margin: 0 4px;\r\n  padding: 10px;\r\n  border: 8px solid rgba(217,20,99,0.1);\r\n  border-bottom-width: 17px;\r\n  border-radius: 6px;\r\n  display: flex;\r\n  flex-direction: column;\r\n  justify-content: space-between;\r\n  position: relative;\r\n}\r\n\r\n.cro .coupons-container__item:after {\r\n  background: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMjAgMTAiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDIwIDEwOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+PHN0eWxlIHR5cGU9InRleHQvY3NzIj4uc3Qwe2ZpbGw6I2ZmZjt9PC9zdHlsZT48cGF0aCBjbGFzcz0ic3QwIiBkPSJNMTAsMi41Yy00LjEsMC03LjUsMy40LTcuNSw3LjVoMTVDMTcuNSw1LjksMTQuMiwyLjUsMTAsMi41eiIvPjwvc3ZnPg==) space;\r\n  background-size: 26px 13px;\r\n  content: '';\r\n  display: block;\r\n  width: 140%;\r\n  height: 13px;\r\n  position: absolute;\r\n  bottom: -17px;\r\n  left: -30px;\r\n}\r\n\r\n.cro .coupons-container__item img {\r\n  width: 60% !important;\r\n  height: auto !important;\r\n  margin: 0 auto !important;\r\n}\r\n\r\n.cro .coupons-container .coupons-container__item h3 {\r\n  font-size: 16px;\r\n  line-height: 1.3em;\r\n}\r\n\r\n.cro .coupons-container .coupons-container__item h1 {\r\n  font-size: 22px;\r\n  font-weight: 700;\r\n  color: #EB1F07;\r\n  line-height: 15px;\r\n}\r\n\r\n.cro .coupons-container .coupons-container__item h4 {\r\n  color: #808283;\r\n  font-size: 1.3rem;\r\n  line-height: 1;\r\n  font-family: icatext;\r\n  font-weight: normal;\r\n}\r\n\r\n.cro .coupons-container .coupons-container__item a {\r\n  font-size: 14px;\r\n  line-height: 15px;\r\n  margin-bottom: 5px;\r\n}\r\n\r\n.cro .coupons-container .coupons-container__item .coupon-button {\r\n  font-size: 12px;\r\n  line-height: 2.2rem;\r\n  min-width: auto;\r\n  align-self: center;\r\n  width: 100%;\r\n  background: #F8EBF3;\r\n  color: #A02971;\r\n}\r\n\r\n.cro .coupons-container .coupons-container__item.offer-loaded .coupon-button {\r\n  background: #DDE9BF;\r\n  color: #8DB72C;\r\n  pointer-events: none;\r\n  transition: width .2s ease, color .2s 250ms ease, background .2s ease;\r\n}\r\n\r\n.cro .coupons-container .coupons-container__item .coupons-image {\r\n  width: 100%;\r\n  height: 60px;\r\n  background-repeat: no-repeat;\r\n  background-size: contain;\r\n  background-position: center;\r\n}\r\n\r\n.cro .banner-wrapper .banner-image img {\r\n  width: 100%;\r\n  position: relative;\r\n  margin-left: 0 !important;\r\n  height: auto !important;\r\n  margin-top: 0 !important;\r\n  min-width: 375px;\r\n}\r\n\r\n.cro .button-wrapper {\r\n  margin: 10px;\r\n}\r\n\r\n.cro .banner-button {\r\n  width: 100%;\r\n  display: block;\r\n}\r\n.cro .banner-button.saved {\r\n  background: #DDE9BF;\r\n  color: #8DB72C;\r\n  pointer-events: none;\r\n  transition: width .2s ease, color .2s 250ms ease, background .2s ease;\r\n  font-weight: 400;\r\n}\r\n\r\n.cro .offers-button {\r\n  width: 90%;\r\n  margin-bottom: 20px;\r\n}\r\n\r\n.cro .rating-star-container {\r\n  position: absolute;\r\n  z-index: 50;\r\n  margin:10px;\r\n  top: 30px;\r\n  color: white;\r\n  text-shadow: 0 0 5px rgba(0, 0, 0, 0.4);\r\n}\r\n\r\n.cro .ica-card-container {\r\n  display: flex;\r\n  flex-direction: column;\r\n  min-height: 250px;\r\n}\r\n\r\n.cro .ica-card-container h1 {\r\n  color: #EB1F07;\r\n}\r\n\r\n.cro .ica-card-container a {\r\n  align-self: flex-start;\r\n  max-width: 250px;\r\n  margin-top:-160px;\r\n}\r\n\r\n.cro .ica-card-container img {\r\n  max-width: 385px;\r\n  width: 80%;\r\n  align-self: flex-end;\r\n  margin-top:-120px;\r\n}\r\n\r\n@media only screen and (max-width: 960px){\r\n  .cro .ica-card-container {\r\n    min-height: none;\r\n  }\r\n\r\n  .cro .ica-card-container h1 {\r\n    line-height: 3rem;\r\n    font-size: 3rem;\r\n    margin-bottom: 20px;\r\n  }\r\n\r\n  .cro .ica-card-container a {\r\n    align-self: center;\r\n    margin-top: 20px;\r\n    max-width: none;\r\n    width: 100%;\r\n  }\r\n\r\n  .cro .ica-card-container img {\r\n    align-self: center;\r\n    margin-top:auto;\r\n  }\r\n\r\n  .cro .offers-container {\r\n    width: 100%;\r\n    background-color: white;\r\n    -webkit-filter: drop-shadow( 1px 1px 2px rgba(0,0,0,0.4) );\r\n    filter: drop-shadow( 1px 1px 2px rgba(0,0,0,0.4) );\r\n  }\r\n\r\n  .start-page-icase > header.full-size-image .image-slider,\r\n  .start-page-icase > header.full-size-image .image-slider ul,\r\n  .start-page-icase > header.full-size-image .image-slider li {\r\n    max-height: 100%;\r\n    width: 100% !important;\r\n    height: 100% !important;\r\n  }\r\n}\r\n.cro .unslider-controls { pointer-events: none; }\r\n.cro .unslider-arrow { pointer-events: auto; }\r\n\r\n@media (max-width: 767px) { .cro .cro-iframe-container { padding-bottom: 135% !important; } }\r\n.cro > .cro-iframe-container { display: none; }\r\n.cro .modal-copntainer .cro-iframe-container { display: initial; }\r\n.cro .container { text-align: center; margin-top: 50px;}\r\n.cro .container h2 { font: 28px icahand; margin-bottom: 20px; }\r\n.cro .cro-iframe-container {\r\n  position: relative;\r\n  height: 0;\r\n  overflow: hidden;\r\n  padding-bottom: 85%;\r\n  background-color: #F3F0EB;\r\n}\r\n.cro .cro-iframe-container iframe {\r\n  opacity: 0;\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  width: 100%;\r\n  height: 100%;\r\n}\r\n\r\n.cro .usp-list { margin-bottom: 10px; }\r\n\r\n.cro .usp-list li {\r\n  font: 24px icarubrik;\r\n  font-weight: 600;\r\n  margin-bottom: 15px;\r\n}\r\n.cro .usp-list svg {\r\n  fill: #8DB72C;\r\n  margin-right: 5px;\r\n}\r\n", ""]);

// exports


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = __webpack_require__(105);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _stringify = __webpack_require__(46);

var _stringify2 = _interopRequireDefault(_stringify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var storage = function storage() {
  var fallBack = {
    storage: {},
    setItem: function setItem(key, value) {
      this.storage[key] = value;
    },
    getItem: function getItem(key) {
      return this.storage[key];
    }
  };
  var chooseStorage = function chooseStorage(typeOfStorage) {
    try {
      if (typeOfStorage in window && window[typeOfStorage] !== null) {
        return window[typeOfStorage];
      }
      return fallBack;
    } catch (e) {
      return false;
    }
  };

  var api = {
    setUp: function setUp(storageName, typeOfStorage) {
      var storageType = chooseStorage(typeOfStorage);
      return {
        set: function set(key, value) {
          storageType.setItem(storageName, (0, _stringify2.default)((0, _defineProperty3.default)({}, key, value)));
        },
        get: function get(key) {
          return JSON.parse(storageType.getItem(storageName))[key];
        },
        clear: function clear() {
          storageType.setItem(storageName, (0, _stringify2.default)({}));
        }
      };
    }
  };
  return {
    setUp: function setUp() {
      var storageName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'cro-cookie';
      var typeOfStorage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'sessionStorage';

      var storageApi = api.setUp(storageName, typeOfStorage);
      return {
        set: function set(key, value) {
          storageApi.set(key, value);
        },
        get: function get(key) {
          return storageApi.get(key);
        },
        clear: function clear() {
          storageApi.clear();
        }
      };
    }
  };
};

var db = storage();
exports.default = db.setUp();

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgZDQwMDEwYzBkOTk5ZTg0ZDk1MjAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb3JlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4tb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGlkZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlcmF0b3JzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2ZhaWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RlZmluZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWxlbmd0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC1rZXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NsYXNzb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX25ldy1wcm9taXNlLWNhcGFiaWxpdHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvcHJvbWlzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbGlicmFyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lvYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL191aWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faHRtbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY2FsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLWFycmF5LWl0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdGFzay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3BlcmZvcm0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wcm9taXNlLXJlc29sdmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWRldGVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL2pzb24vc3RyaW5naWZ5LmpzIiwid2VicGFjazovLy8uL3NyYy91dGlsL21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9hcnJheS9mcm9tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvc2xpY2VkVG9BcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzIiwid2VicGFjazovLy8uL3NyYy9zdGFydC1wYWdlL3ZhcmlhbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9wcm9taXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc3RyaW5nLWF0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19yZWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tYWJzb2x1dGUtaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ3BvLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLXN0ZXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5wcm9taXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4taW5zdGFuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19mb3Itb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pbnZva2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19taWNyb3Rhc2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19yZWRlZmluZS1hbGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtc3BlY2llcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnByb21pc2UuZmluYWxseS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnByb21pc2UudHJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vanNvbi9zdHJpbmdpZnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1waWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9udW1iZXIvaXMtaW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL251bWJlci9pcy1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYubnVtYmVyLmlzLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2tleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qva2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXNhcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL2FycmF5L2Zyb20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5hcnJheS5mcm9tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3JlYXRlLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9pcy1pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL2lzLWl0ZXJhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmlzLWl0ZXJhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvZ2V0LWl0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vZ2V0LWl0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbC9tb2R1bGVzL3JhdGluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3N0YXJ0LXBhZ2UvYmFubmVycy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc3RhcnQtcGFnZS9jb3Vwb25zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS1tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3N0YXJ0LXBhZ2UvY291cG9ucy1zdHlsZS5jc3M/MmQxOSIsIndlYnBhY2s6Ly8vLi9zcmMvc3RhcnQtcGFnZS9jb3Vwb25zLXN0eWxlLmNzcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzIiwid2VicGFjazovLy8uL3NyYy9zdGFydC1wYWdlL3N0eWxlLmNzcz82NDkwIiwid2VicGFjazovLy8uL3NyYy9zdGFydC1wYWdlL3N0eWxlLmNzcyIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbC9tb2R1bGVzL3N0b3JhZ2UuanMiXSwibmFtZXMiOlsicmVzZXJ2ZWRFbGVtZW50cyIsIkdldEVsZW1lbnQiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJzZWxlY3RvciIsIiRFTE1fRUxFTUVOVCIsImVsZW1lbnQiLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiYXJnIiwiYXR0ciIsImFyZ3MiLCJsZW5ndGgiLCJzcGxpdCIsInZhbHVlIiwic2V0QXR0cmlidXRlIiwiZ2V0QXR0cmlidXRlIiwiRXJyb3IiLCJoZWlnaHQiLCJjbGljayIsImNhbGxiYWNrIiwiYWRkRXZlbnRMaXN0ZW5lciIsImh0bWwiLCJzdHIiLCJpbm5lckhUTUwiLCJ0ZXh0IiwiYXBwZW5kQ2hpbGQiLCJjcmVhdGVUZXh0Tm9kZSIsImltYWdlIiwic3JjIiwiaHJlZiIsInVybCIsImFwcGVuZEZpcnN0IiwiY2hpbGQiLCJjIiwibm9kZVR5cGUiLCJpbnNlcnRCZWZvcmUiLCJjaGlsZE5vZGVzIiwiYXBwZW5kIiwiYXBwZW5kQWxsIiwiY2hpbGRzIiwibWFwIiwiY3NzIiwiY24iLCJqb2luIiwiZm9yRWFjaCIsImNsYXNzTGlzdCIsImFkZCIsInJlcGxhY2UiLCJ0cmltIiwiZ2V0IiwiY2hpbGRyZW4iLCJsaXN0IiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJzdHlsZSIsInN0bCIsImRhdGEiLCJrZXkiLCJkYXRhc2V0IiwiQ3JlYXRlRWxlbWVudCIsIkhUTUxFbGVtZW50IiwiYXJyIiwidHlwZSIsInJlZHVjZSIsImFjYyIsImN1cnJlbnQiLCJpbmNsdWRlcyIsImNsYXNzTmFtZXMiLCJmaWx0ZXIiLCJkb20iLCJjcmVhdGVFbGVtZW50IiwiQ3JlYXRlRWxlbWVudEJ5T2JqZWN0IiwiaXRlcmFibGUiLCJpdGVtIiwiZnVuYyIsIiRFTE0iLCJlbG1zIiwiY3JlYXRlIiwiYnVpbGQiLCJwYXJzZUludCIsInNhdmUiLCJpZCIsImNvcHkiLCJjbG9uZU5vZGUiLCJJQ0FDUk8iLCJnZXRFbGVtZW50Q29udGVudEJ5VGFnQW5kQXR0ciIsInJlZ2V4cCIsInRhZyIsInFzYSIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJ0b0FycmF5IiwiUmVnRXhwIiwidGVzdCIsInB1c2giLCJyZW1vdmVFbGVtZW50cyIsImNsYXNzTmFtZSIsImVsbSIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsIkFycmF5IiwicHJvdG90eXBlIiwic2xpY2UiLCJjYWxsIiwibG9hZCIsIm9wdGlvbnMiLCJvcHMiLCJtZXRob2QiLCJmZXRjaCIsInRoZW4iLCJyZXNwb25zZSIsImpzb24iLCJjYXRjaCIsImVyciIsInN0eWxlcyIsImNvbnNvbGUiLCJsb2ciLCJpc0xvZ2dlZEluIiwiZ2FQdXNoIiwiZXZlbnRDYXRlZ29yeSIsImV2ZW50QWN0aW9uIiwiZXZlbnRMYWJlbCIsImdhIiwic3RvcmFnZSIsInNldCIsImNsZWFyIiwiJCIsIkxPR0lOX0FDVElPTiIsIlNBVkVfUkVDSVBFIiwiTE9BRF9DT1VQT04iLCJBQ1RJT05fQ09PS0lFUyIsImxvYWRlZENvdXBvbnMiLCJwYXJlbnQiLCJ0IiwiZGl2IiwiYWRkQ291cG9uIiwiY291cG9uIiwiY291cG9uSXRlbSIsImltZyIsInRpdGxlIiwiZGlzY291bnQiLCJzdWJ0aXRsZSIsIm1vcmVJbmZvIiwiYnV0dG9uIiwibG9hZENvdXBvbk9uQ2FyZCIsImNoYW5nZU9mZmVyU3RhdHVzIiwiaWNhZGF0YWxheWVyIiwiSFNFIiwiYWN0aW9uIiwibmFtZSIsIlBhZ2VOYW1lIiwiaHNldXJsIiwiY29va2llRGF0YSIsInJlY2lwZUlkIiwiT2ZmZXJJZCIsIk9mZmVyIiwiQ2FtcGFpZ25JZCIsInNldEFjdGlvbkNvb2tpZSIsImNyZWF0ZU1vZGFsIiwibG9hZENvdXBvbkRhdGEiLCJMb2FkZWRPbkNhcmQiLCJhZGRCYW5uZXIiLCJiYW5uZXIiLCJiYW5uZXJDb250YWluZXIiLCJiYW5uZXJDb250YWluZXJJbWciLCJ0ZXh0Q29udGFpbmVyIiwicmF0aW5ncyIsImRpZmZpY3VsdHkiLCJjb3Vwb25zV3JhcHBlciIsInNhdmVCdXR0b24iLCJjcmVhdGVTYXZlUmVjaXBlQ1RBIiwic3RhcnMiLCJjb29rVGltZSIsImNvdXBvbnMiLCJhZGRTdHlsZSIsImFkZEJhbm5lcnMiLCJoZWFkZXIiLCJ1bCIsInNsaWNrIiwiYWRhcHRpdmVIZWlnaHQiLCJhZGRJY2FDYXJkIiwic2VsZiIsImljYUltYWdlQ29udGFpbmVyIiwidXNwcyIsImRpbm5lclRvbmlnaHQiLCJjb250YWluZXIiLCJyZWNpcGVUcmVuZGluZ0xpc3QiLCJzZWVBbGwiLCJtYW5pcHVsYXRlRG9tIiwiY3JlYXRlT2ZmZXJzIiwicmV0dXJuVXJsIiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwid2luZG93IiwibG9jYXRpb24iLCJpZnJhbWVDb250YWluZXIiLCJjdGEiLCJzYXZlZFJlY2lwZXMiLCJnZXRTYXZlZFJlY2lwZXMiLCJlIiwicHJldmVudERlZmF1bHQiLCJhZGRSZWNpcGVUb1Nob3BwaW5nTGlzdCIsInNhdmVSZWNpcGUiLCJhZGRSZWNpcGVUb1NhdmVkTGlzdCIsIm1haW4iLCJvZmZlckJ1dHRvbiIsIklDQSIsImFqYXgiLCJwb3N0IiwicmVjaXBlSWRzIiwiU2hvcHBpbmdMaXN0SWQiLCJudW1iZXJPZlNlcnZpbmdzIiwicmVjaXBlcyIsInNob3BwaW5nTGlzdE5hbWUiLCJjcmVhdGVTaG9wcGluZ3NMaXN0TmFtZSIsImQiLCJEYXRlIiwieWVhciIsImdldEZ1bGxZZWFyIiwibW9udGgiLCJnZXRNb250aCIsImRheSIsImdldERhdGUiLCJtb250aHMiLCJiIiwiZGF0YUxheWVyIiwiZXZlbnQiLCJVUkwiLCJjb29raWVOYW1lIiwic2V0RGF0ZSIsImxlZ2FjeSIsInNldENvb2tpZSIsImdldEFjdGlvbkNvb2tpZSIsImFjdGlvbkNvb2tpZSIsImdldENvb2tpZSIsImtpbGxDb29raWUiLCJKU09OIiwicGFyc2UiLCJjaGVja0FjdGlvbkNvb2tpZXMiLCJjb29raWUiLCJvayIsImxvYWRlcklzQWN0aXZlIiwiYnV0dG9uSGFuZGxlclBvbGxUaW1lb3V0Iiwic2hvd0xvYWRlciIsImZpbmQiLCJzaG93IiwiaGlkZUxvYWRlciIsImhpZGUiLCJhZGRCdXR0b25IYW5kbGVyUG9sbCIsImlmcmFtZSIsImNvbnRlbnRzIiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImJpbmQiLCJhZGRFdmVudExpc3RlbmVycyIsIm9mZiIsIm9uIiwib3JpZ2luIiwicHJvdG9jb2wiLCJob3N0Iiwib3JpZ2luYWxFdmVudCIsImdldElmcmFtZVN0eWxlcyIsIm1vZGFsIiwiY29yZUNvbXBvbmVudHMiLCJ0cGwiLCJzaXplIiwicmVnZXgiLCJjb250ZW50V2luZG93IiwicmVsb2FkIiwiaW5kZXhPZiIsImhpZGVIZWFkZXJCYXIiLCJoZWFkZXJCYXJUaW1lb3V0IiwiaGlkZUhlYWRlckJhckRlZmVycmVkIiwicmVzb2x2ZSIsImFwcGVuZEhlYWRlciIsIm1lc3NhZ2UiLCJzY3JlZW4iLCJ3aWR0aCIsImFwcGVuZEhlYWRlclRpbWVvdXQiLCJhcHBlbmRIZWFkZXJEZWZlcnJlZCIsImFkZFN0eWxlcyIsImFkZFN0eWxlc1RpbWVvdXQiLCJhZGRTdHlsZXNEZWZlcnJlZCIsImFkZElmcmFtZVRyYWNraW5nIiwiYWRkSWZyYW1lVHJhY2tpbmdUaW1lb3V0IiwiYWRkSWZyYW1lVHJhY2tpbmdEZWZlcnJlZCIsIkRlZmVycmVkIiwid2hlbiIsImRvbmUiLCJlYWNoIiwiY3JlZGVudGlhbHMiLCJvcHRzIiwiU3RvcmVJZCIsIlN0b3JlR3JvdXBJZCIsImhlYWRlcnMiLCJBY2NlcHQiLCJib2R5Iiwib2ZmZXIiLCJyZWFkeSIsIklDIiwialF1ZXJ5Iiwic3RycyIsIngiLCJpbmRleCIsInByaW50QmFubmVyIiwiY29udGVudCIsInByZWFtYmxlIiwiaXNVc2VkIiwiaXNVc2VkQ2xhc3MiLCJiYW5uZXJFbGVtZW50IiwiYmFubmVyUm93IiwiYmFubmVyQ29sdW1uMSIsImJhbm5lckNvbHVtbjIiLCJiYW5uZXJDb2x1bW4zIiwiaW1nRWxlbWVudCIsInRpdGxlRWxlbWVudCIsImRpc2NvdW50RWxlbWVudCIsInByZWFtYmxlRWxlbWVudCIsImltZ0hvbGRlciIsInJlYWRNb3JlIiwiZG93bkxvYWQiLCJidXR0b25UZXh0Iiwib25DbGljayIsImNoZWNrQWN0aW9uQ29va2llIiwicmVtb3ZlIiwiZGVhY3RpdmF0ZUNvdXBvbiIsIlByb2R1Y3ROYW1lIiwibG9hZEJhbm5lcnMiLCJpZHMiLCJIZWFkZXIiLCJPZmZlckNvbmRpdGlvbiIsIkJyYW5kIiwiU2l6ZU9yUXVhbnRpdHkiLCJDb25kaXRpb25zIiwiVGV4dCIsIkltYWdlIiwiSW1hZ2VVcmwiLCJhZGRJZnJhbWUiLCJiYW5uZXJzIiwibWF0Y2giLCJmYWxsQmFjayIsInNldEl0ZW0iLCJnZXRJdGVtIiwiY2hvb3NlU3RvcmFnZSIsInR5cGVPZlN0b3JhZ2UiLCJhcGkiLCJzZXRVcCIsInN0b3JhZ2VOYW1lIiwic3RvcmFnZVR5cGUiLCJzdG9yYWdlQXBpIiwiZGIiXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQzdEQSw2QkFBNkI7QUFDN0IsdUNBQXVDOzs7Ozs7O0FDRHZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qzs7Ozs7OztBQ0x6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGNBQWM7QUFDZCxjQUFjO0FBQ2QsY0FBYztBQUNkLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGdCQUFnQjtBQUNoQjs7Ozs7OztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOzs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxZQUFZO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0EsaUNBQWlDLFFBQVEsbUJBQW1CLFVBQVUsRUFBRSxFQUFFO0FBQzFFLENBQUM7Ozs7Ozs7QUNIRDs7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbkJBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixjQUFjO0FBQ2Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsQ0FBQzs7Ozs7OztBQ2hCRDtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7Ozs7Ozs7QUNOQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBOzs7Ozs7O0FDSEEsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvRUFBb0UsaUNBQWlDO0FBQ3JHOzs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUseUJBQXlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0IsRUFBRTs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLFlBQVk7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQ2pCQSxrQkFBa0Isd0Q7Ozs7OztBQ0FsQixrQkFBa0Isd0Q7Ozs7Ozs7QUNBbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7O0FBRUEsOEJBQThCLGFBQWE7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsb0NBQW9DO0FBQzdFLDZDQUE2QyxvQ0FBb0M7QUFDakYsS0FBSyw0QkFBNEIsb0NBQW9DO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQSxrQ0FBa0MsMkJBQTJCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7Ozs7OztBQ3JFQTs7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSx1Q0FBdUM7QUFDdkM7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNIQTtBQUNBOzs7Ozs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7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QTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7Ozs7OztBQ3hDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssWUFBWSxlQUFlO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7Ozs7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7Ozs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLGNBQWM7QUFDZCxpQkFBaUI7QUFDakI7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FDakNBLDhCQUE4Qjs7Ozs7OztBQ0E5QjtBQUNBLFVBQVU7QUFDVjs7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLEtBQUs7QUFDTCxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNB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QywyREFBa0JoUyxHQUFsQixFQUF3QjNDLEtBQXhCLEVBQWpDO0FBQ0QsU0FISTtBQUlMb0MsV0FKSyxlQUlETyxHQUpDLEVBSUk7QUFDUCxpQkFBT2lMLEtBQUtDLEtBQUwsQ0FBVytHLFlBQVlOLE9BQVosQ0FBb0JLLFdBQXBCLENBQVgsRUFBNkNoUyxHQUE3QyxDQUFQO0FBQ0QsU0FOSTtBQU9MbUUsYUFQSyxtQkFPRztBQUNOOE4sc0JBQVlQLE9BQVosQ0FBb0JNLFdBQXBCLEVBQWlDLHlCQUFlLEVBQWYsQ0FBakM7QUFDRDtBQVRJLE9BQVA7QUFXRDtBQWRTLEdBQVo7QUFnQkEsU0FBTztBQUNMRCxTQURLLG1CQUMrRDtBQUFBLFVBQTlEQyxXQUE4RCx1RUFBaEQsWUFBZ0Q7QUFBQSxVQUFsQ0gsYUFBa0MsdUVBQWxCLGdCQUFrQjs7QUFDbEUsVUFBTUssYUFBYUosSUFBSUMsS0FBSixDQUFVQyxXQUFWLEVBQXVCSCxhQUF2QixDQUFuQjtBQUNBLGFBQU87QUFDTDNOLFdBREssZUFDRGxFLEdBREMsRUFDSTNDLEtBREosRUFDVztBQUNkNlUscUJBQVdoTyxHQUFYLENBQWVsRSxHQUFmLEVBQW9CM0MsS0FBcEI7QUFDRCxTQUhJO0FBSUxvQyxXQUpLLGVBSURPLEdBSkMsRUFJSTtBQUNQLGlCQUFPa1MsV0FBV3pTLEdBQVgsQ0FBZU8sR0FBZixDQUFQO0FBQ0QsU0FOSTtBQU9MbUUsYUFQSyxtQkFPRztBQUNOK04scUJBQVcvTixLQUFYO0FBQ0Q7QUFUSSxPQUFQO0FBV0Q7QUFkSSxHQUFQO0FBZ0JELENBckREOztBQXVEQSxJQUFNZ08sS0FBS2xPLFNBQVg7a0JBQ2VrTyxHQUFHSixLQUFILEUiLCJmaWxlIjoidmFyaWFudC5taW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA1Mik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgZDQwMDEwYzBkOTk5ZTg0ZDk1MjAiLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0geyB2ZXJzaW9uOiAnMi41LjEnIH07XG5pZiAodHlwZW9mIF9fZSA9PSAnbnVtYmVyJykgX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvcmUuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHN0b3JlID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ3drcycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlN5bWJvbDtcbnZhciBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xuXG52YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZiAodHlwZW9mIF9fZyA9PSAnbnVtYmVyJykgX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24gKHR5cGUsIG5hbWUsIHNvdXJjZSkge1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRjtcbiAgdmFyIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0Lkc7XG4gIHZhciBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TO1xuICB2YXIgSVNfUFJPVE8gPSB0eXBlICYgJGV4cG9ydC5QO1xuICB2YXIgSVNfQklORCA9IHR5cGUgJiAkZXhwb3J0LkI7XG4gIHZhciBJU19XUkFQID0gdHlwZSAmICRleHBvcnQuVztcbiAgdmFyIGV4cG9ydHMgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KTtcbiAgdmFyIGV4cFByb3RvID0gZXhwb3J0c1tQUk9UT1RZUEVdO1xuICB2YXIgdGFyZ2V0ID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXTtcbiAgdmFyIGtleSwgb3duLCBvdXQ7XG4gIGlmIChJU19HTE9CQUwpIHNvdXJjZSA9IG5hbWU7XG4gIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgaWYgKG93biAmJiBrZXkgaW4gZXhwb3J0cykgY29udGludWU7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSBvd24gPyB0YXJnZXRba2V5XSA6IHNvdXJjZVtrZXldO1xuICAgIC8vIHByZXZlbnQgZ2xvYmFsIHBvbGx1dGlvbiBmb3IgbmFtZXNwYWNlc1xuICAgIGV4cG9ydHNba2V5XSA9IElTX0dMT0JBTCAmJiB0eXBlb2YgdGFyZ2V0W2tleV0gIT0gJ2Z1bmN0aW9uJyA/IHNvdXJjZVtrZXldXG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICA6IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKVxuICAgIC8vIHdyYXAgZ2xvYmFsIGNvbnN0cnVjdG9ycyBmb3IgcHJldmVudCBjaGFuZ2UgdGhlbSBpbiBsaWJyYXJ5XG4gICAgOiBJU19XUkFQICYmIHRhcmdldFtrZXldID09IG91dCA/IChmdW5jdGlvbiAoQykge1xuICAgICAgdmFyIEYgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIEMpIHtcbiAgICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDKCk7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQyhhKTtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBDKGEsIGIpO1xuICAgICAgICAgIH0gcmV0dXJuIG5ldyBDKGEsIGIsIGMpO1xuICAgICAgICB9IHJldHVybiBDLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgICAgRltQUk9UT1RZUEVdID0gQ1tQUk9UT1RZUEVdO1xuICAgICAgcmV0dXJuIEY7XG4gICAgLy8gbWFrZSBzdGF0aWMgdmVyc2lvbnMgZm9yIHByb3RvdHlwZSBtZXRob2RzXG4gICAgfSkob3V0KSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5tZXRob2RzLiVOQU1FJVxuICAgIGlmIChJU19QUk9UTykge1xuICAgICAgKGV4cG9ydHMudmlydHVhbCB8fCAoZXhwb3J0cy52aXJ0dWFsID0ge30pKVtrZXldID0gb3V0O1xuICAgICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLnByb3RvdHlwZS4lTkFNRSVcbiAgICAgIGlmICh0eXBlICYgJGV4cG9ydC5SICYmIGV4cFByb3RvICYmICFleHBQcm90b1trZXldKSBoaWRlKGV4cFByb3RvLCBrZXksIG91dCk7XG4gICAgfVxuICB9XG59O1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2V4cG9ydC5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4tb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oaWRlLmpzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGRQID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XG4gIGlmICgndmFsdWUnIGluIEF0dHJpYnV0ZXMpIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwLmpzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLW9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZXNjcmlwdG9ycy5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXJhdG9ycy5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgJGF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbi8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24gKGl0ZXJhdGVkKSB7XG4gIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIE8gPSB0aGlzLl90O1xuICB2YXIgaW5kZXggPSB0aGlzLl9pO1xuICB2YXIgcG9pbnQ7XG4gIGlmIChpbmRleCA+PSBPLmxlbmd0aCkgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICBwb2ludCA9ICRhdChPLCBpbmRleCk7XG4gIHRoaXMuX2kgKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4geyB2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlIH07XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICh0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29mLmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1vYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWludGVnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVmaW5lZC5qc1xuLy8gbW9kdWxlIGlkID0gMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYml0bWFwLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGU6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWlvYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMS4xNSBUb0xlbmd0aFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWxlbmd0aC5qc1xuLy8gbW9kdWxlIGlkID0gMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdrZXlzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLWtleS5qc1xuLy8gbW9kdWxlIGlkID0gMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGRlZiA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCB0YWcsIHN0YXQpIHtcbiAgaWYgKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpIGRlZihpdCwgVEFHLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZyB9KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanNcbi8vIG1vZHVsZSBpZCA9IDI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciBUT19TVFJJTkdfVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbnZhciBET01JdGVyYWJsZXMgPSAoJ0NTU1J1bGVMaXN0LENTU1N0eWxlRGVjbGFyYXRpb24sQ1NTVmFsdWVMaXN0LENsaWVudFJlY3RMaXN0LERPTVJlY3RMaXN0LERPTVN0cmluZ0xpc3QsJyArXG4gICdET01Ub2tlbkxpc3QsRGF0YVRyYW5zZmVySXRlbUxpc3QsRmlsZUxpc3QsSFRNTEFsbENvbGxlY3Rpb24sSFRNTENvbGxlY3Rpb24sSFRNTEZvcm1FbGVtZW50LEhUTUxTZWxlY3RFbGVtZW50LCcgK1xuICAnTWVkaWFMaXN0LE1pbWVUeXBlQXJyYXksTmFtZWROb2RlTWFwLE5vZGVMaXN0LFBhaW50UmVxdWVzdExpc3QsUGx1Z2luLFBsdWdpbkFycmF5LFNWR0xlbmd0aExpc3QsU1ZHTnVtYmVyTGlzdCwnICtcbiAgJ1NWR1BhdGhTZWdMaXN0LFNWR1BvaW50TGlzdCxTVkdTdHJpbmdMaXN0LFNWR1RyYW5zZm9ybUxpc3QsU291cmNlQnVmZmVyTGlzdCxTdHlsZVNoZWV0TGlzdCxUZXh0VHJhY2tDdWVMaXN0LCcgK1xuICAnVGV4dFRyYWNrTGlzdCxUb3VjaExpc3QnKS5zcGxpdCgnLCcpO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IERPTUl0ZXJhYmxlcy5sZW5ndGg7IGkrKykge1xuICB2YXIgTkFNRSA9IERPTUl0ZXJhYmxlc1tpXTtcbiAgdmFyIENvbGxlY3Rpb24gPSBnbG9iYWxbTkFNRV07XG4gIHZhciBwcm90byA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIGlmIChwcm90byAmJiAhcHJvdG9bVE9fU1RSSU5HX1RBR10pIGhpZGUocHJvdG8sIFRPX1NUUklOR19UQUcsIE5BTUUpO1xuICBJdGVyYXRvcnNbTkFNRV0gPSBJdGVyYXRvcnMuQXJyYXk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xudmFyIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuLy8gRVMzIHdyb25nIGhlcmVcbnZhciBBUkcgPSBjb2YoZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8sIFQsIEI7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mIChUID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUQUcpKSA9PSAnc3RyaW5nJyA/IFRcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IEFSRyA/IGNvZihPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChCID0gY29mKE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogQjtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY2xhc3NvZi5qc1xuLy8gbW9kdWxlIGlkID0gMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmdldEl0ZXJhdG9yTWV0aG9kID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCAhPSB1bmRlZmluZWQpIHJldHVybiBpdFtJVEVSQVRPUl1cbiAgICB8fCBpdFsnQEBpdGVyYXRvciddXG4gICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanNcbi8vIG1vZHVsZSBpZCA9IDI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIDI1LjQuMS41IE5ld1Byb21pc2VDYXBhYmlsaXR5KEMpXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xuXG5mdW5jdGlvbiBQcm9taXNlQ2FwYWJpbGl0eShDKSB7XG4gIHZhciByZXNvbHZlLCByZWplY3Q7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBDKGZ1bmN0aW9uICgkJHJlc29sdmUsICQkcmVqZWN0KSB7XG4gICAgaWYgKHJlc29sdmUgIT09IHVuZGVmaW5lZCB8fCByZWplY3QgIT09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKCdCYWQgUHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgIHJlc29sdmUgPSAkJHJlc29sdmU7XG4gICAgcmVqZWN0ID0gJCRyZWplY3Q7XG4gIH0pO1xuICB0aGlzLnJlc29sdmUgPSBhRnVuY3Rpb24ocmVzb2x2ZSk7XG4gIHRoaXMucmVqZWN0ID0gYUZ1bmN0aW9uKHJlamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiAoQykge1xuICByZXR1cm4gbmV3IFByb21pc2VDYXBhYmlsaXR5KEMpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5LmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2Fzc2lnblwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduLmpzXG4vLyBtb2R1bGUgaWQgPSAzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vcHJvbWlzZVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9wcm9taXNlLmpzXG4vLyBtb2R1bGUgaWQgPSAzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgJGl0ZXJDcmVhdGUgPSByZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEJVR0dZID0gIShbXS5rZXlzICYmICduZXh0JyBpbiBbXS5rZXlzKCkpOyAvLyBTYWZhcmkgaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXG52YXIgRkZfSVRFUkFUT1IgPSAnQEBpdGVyYXRvcic7XG52YXIgS0VZUyA9ICdrZXlzJztcbnZhciBWQUxVRVMgPSAndmFsdWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChCYXNlLCBOQU1FLCBDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpIHtcbiAgJGl0ZXJDcmVhdGUoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuICB2YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24gKGtpbmQpIHtcbiAgICBpZiAoIUJVR0dZICYmIGtpbmQgaW4gcHJvdG8pIHJldHVybiBwcm90b1traW5kXTtcbiAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICB9O1xuICB2YXIgVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICB2YXIgREVGX1ZBTFVFUyA9IERFRkFVTFQgPT0gVkFMVUVTO1xuICB2YXIgVkFMVUVTX0JVRyA9IGZhbHNlO1xuICB2YXIgcHJvdG8gPSBCYXNlLnByb3RvdHlwZTtcbiAgdmFyICRuYXRpdmUgPSBwcm90b1tJVEVSQVRPUl0gfHwgcHJvdG9bRkZfSVRFUkFUT1JdIHx8IERFRkFVTFQgJiYgcHJvdG9bREVGQVVMVF07XG4gIHZhciAkZGVmYXVsdCA9ICRuYXRpdmUgfHwgZ2V0TWV0aG9kKERFRkFVTFQpO1xuICB2YXIgJGVudHJpZXMgPSBERUZBVUxUID8gIURFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZCgnZW50cmllcycpIDogdW5kZWZpbmVkO1xuICB2YXIgJGFueU5hdGl2ZSA9IE5BTUUgPT0gJ0FycmF5JyA/IHByb3RvLmVudHJpZXMgfHwgJG5hdGl2ZSA6ICRuYXRpdmU7XG4gIHZhciBtZXRob2RzLCBrZXksIEl0ZXJhdG9yUHJvdG90eXBlO1xuICAvLyBGaXggbmF0aXZlXG4gIGlmICgkYW55TmF0aXZlKSB7XG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZigkYW55TmF0aXZlLmNhbGwobmV3IEJhc2UoKSkpO1xuICAgIGlmIChJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJiBJdGVyYXRvclByb3RvdHlwZS5uZXh0KSB7XG4gICAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXG4gICAgICBzZXRUb1N0cmluZ1RhZyhJdGVyYXRvclByb3RvdHlwZSwgVEFHLCB0cnVlKTtcbiAgICAgIC8vIGZpeCBmb3Igc29tZSBvbGQgZW5naW5lc1xuICAgICAgaWYgKCFMSUJSQVJZICYmICFoYXMoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SKSkgaGlkZShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuICAgIH1cbiAgfVxuICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmIChERUZfVkFMVUVTICYmICRuYXRpdmUgJiYgJG5hdGl2ZS5uYW1lICE9PSBWQUxVRVMpIHtcbiAgICBWQUxVRVNfQlVHID0gdHJ1ZTtcbiAgICAkZGVmYXVsdCA9IGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuICRuYXRpdmUuY2FsbCh0aGlzKTsgfTtcbiAgfVxuICAvLyBEZWZpbmUgaXRlcmF0b3JcbiAgaWYgKCghTElCUkFSWSB8fCBGT1JDRUQpICYmIChCVUdHWSB8fCBWQUxVRVNfQlVHIHx8ICFwcm90b1tJVEVSQVRPUl0pKSB7XG4gICAgaGlkZShwcm90bywgSVRFUkFUT1IsICRkZWZhdWx0KTtcbiAgfVxuICAvLyBQbHVnIGZvciBsaWJyYXJ5XG4gIEl0ZXJhdG9yc1tOQU1FXSA9ICRkZWZhdWx0O1xuICBJdGVyYXRvcnNbVEFHXSA9IHJldHVyblRoaXM7XG4gIGlmIChERUZBVUxUKSB7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKFZBTFVFUyksXG4gICAgICBrZXlzOiBJU19TRVQgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6ICRlbnRyaWVzXG4gICAgfTtcbiAgICBpZiAoRk9SQ0VEKSBmb3IgKGtleSBpbiBtZXRob2RzKSB7XG4gICAgICBpZiAoIShrZXkgaW4gcHJvdG8pKSByZWRlZmluZShwcm90bywga2V5LCBtZXRob2RzW2tleV0pO1xuICAgIH0gZWxzZSAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChCVUdHWSB8fCBWQUxVRVNfQlVHKSwgTkFNRSwgbWV0aG9kcyk7XG4gIH1cbiAgcmV0dXJuIG1ldGhvZHM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHRydWU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbGlicmFyeS5qc1xuLy8gbW9kdWxlIGlkID0gMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG52YXIgc3RvcmUgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB7fSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC5qc1xuLy8gbW9kdWxlIGlkID0gMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlkID0gMDtcbnZhciBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdWlkLmpzXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSAzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbm1vZHVsZS5leHBvcnRzID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2h0bWwuanNcbi8vIG1vZHVsZSBpZCA9IDM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3JcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIGZuLCB2YWx1ZSwgZW50cmllcykge1xuICB0cnkge1xuICAgIHJldHVybiBlbnRyaWVzID8gZm4oYW5PYmplY3QodmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7XG4gIC8vIDcuNC42IEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIGNvbXBsZXRpb24pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIgcmV0ID0gaXRlcmF0b3JbJ3JldHVybiddO1xuICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCkgYW5PYmplY3QocmV0LmNhbGwoaXRlcmF0b3IpKTtcbiAgICB0aHJvdyBlO1xuICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY2FsbC5qc1xuLy8gbW9kdWxlIGlkID0gMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gY2hlY2sgb24gZGVmYXVsdCBBcnJheSBpdGVyYXRvclxudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKEl0ZXJhdG9ycy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b1tJVEVSQVRPUl0gPT09IGl0KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtYXJyYXktaXRlci5qc1xuLy8gbW9kdWxlIGlkID0gNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gNy4zLjIwIFNwZWNpZXNDb25zdHJ1Y3RvcihPLCBkZWZhdWx0Q29uc3RydWN0b3IpXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgU1BFQ0lFUyA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBEKSB7XG4gIHZhciBDID0gYW5PYmplY3QoTykuY29uc3RydWN0b3I7XG4gIHZhciBTO1xuICByZXR1cm4gQyA9PT0gdW5kZWZpbmVkIHx8IChTID0gYW5PYmplY3QoQylbU1BFQ0lFU10pID09IHVuZGVmaW5lZCA/IEQgOiBhRnVuY3Rpb24oUyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NwZWNpZXMtY29uc3RydWN0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBpbnZva2UgPSByZXF1aXJlKCcuL19pbnZva2UnKTtcbnZhciBodG1sID0gcmVxdWlyZSgnLi9faHRtbCcpO1xudmFyIGNlbCA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgc2V0VGFzayA9IGdsb2JhbC5zZXRJbW1lZGlhdGU7XG52YXIgY2xlYXJUYXNrID0gZ2xvYmFsLmNsZWFySW1tZWRpYXRlO1xudmFyIE1lc3NhZ2VDaGFubmVsID0gZ2xvYmFsLk1lc3NhZ2VDaGFubmVsO1xudmFyIERpc3BhdGNoID0gZ2xvYmFsLkRpc3BhdGNoO1xudmFyIGNvdW50ZXIgPSAwO1xudmFyIHF1ZXVlID0ge307XG52YXIgT05SRUFEWVNUQVRFQ0hBTkdFID0gJ29ucmVhZHlzdGF0ZWNoYW5nZSc7XG52YXIgZGVmZXIsIGNoYW5uZWwsIHBvcnQ7XG52YXIgcnVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaWQgPSArdGhpcztcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICBpZiAocXVldWUuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgdmFyIGZuID0gcXVldWVbaWRdO1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gICAgZm4oKTtcbiAgfVxufTtcbnZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCkge1xuICBydW4uY2FsbChldmVudC5kYXRhKTtcbn07XG4vLyBOb2RlLmpzIDAuOSsgJiBJRTEwKyBoYXMgc2V0SW1tZWRpYXRlLCBvdGhlcndpc2U6XG5pZiAoIXNldFRhc2sgfHwgIWNsZWFyVGFzaykge1xuICBzZXRUYXNrID0gZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGZuKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICB2YXIgaSA9IDE7XG4gICAgd2hpbGUgKGFyZ3VtZW50cy5sZW5ndGggPiBpKSBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgIHF1ZXVlWysrY291bnRlcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgICAgIGludm9rZSh0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pLCBhcmdzKTtcbiAgICB9O1xuICAgIGRlZmVyKGNvdW50ZXIpO1xuICAgIHJldHVybiBjb3VudGVyO1xuICB9O1xuICBjbGVhclRhc2sgPSBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShpZCkge1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gIH07XG4gIC8vIE5vZGUuanMgMC44LVxuICBpZiAocmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBTcGhlcmUgKEpTIGdhbWUgZW5naW5lKSBEaXNwYXRjaCBBUElcbiAgfSBlbHNlIGlmIChEaXNwYXRjaCAmJiBEaXNwYXRjaC5ub3cpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgRGlzcGF0Y2gubm93KGN0eChydW4sIGlkLCAxKSk7XG4gICAgfTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBNZXNzYWdlQ2hhbm5lbCwgaW5jbHVkZXMgV2ViV29ya2Vyc1xuICB9IGVsc2UgaWYgKE1lc3NhZ2VDaGFubmVsKSB7XG4gICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgIHBvcnQgPSBjaGFubmVsLnBvcnQyO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbGlzdGVuZXI7XG4gICAgZGVmZXIgPSBjdHgocG9ydC5wb3N0TWVzc2FnZSwgcG9ydCwgMSk7XG4gIC8vIEJyb3dzZXJzIHdpdGggcG9zdE1lc3NhZ2UsIHNraXAgV2ViV29ya2Vyc1xuICAvLyBJRTggaGFzIHBvc3RNZXNzYWdlLCBidXQgaXQncyBzeW5jICYgdHlwZW9mIGl0cyBwb3N0TWVzc2FnZSBpcyAnb2JqZWN0J1xuICB9IGVsc2UgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICYmIHR5cGVvZiBwb3N0TWVzc2FnZSA9PSAnZnVuY3Rpb24nICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoaWQgKyAnJywgJyonKTtcbiAgICB9O1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIsIGZhbHNlKTtcbiAgLy8gSUU4LVxuICB9IGVsc2UgaWYgKE9OUkVBRFlTVEFURUNIQU5HRSBpbiBjZWwoJ3NjcmlwdCcpKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoY2VsKCdzY3JpcHQnKSlbT05SRUFEWVNUQVRFQ0hBTkdFXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaHRtbC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgcnVuLmNhbGwoaWQpO1xuICAgICAgfTtcbiAgICB9O1xuICAvLyBSZXN0IG9sZCBicm93c2Vyc1xuICB9IGVsc2Uge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBzZXRUaW1lb3V0KGN0eChydW4sIGlkLCAxKSwgMCk7XG4gICAgfTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogc2V0VGFzayxcbiAgY2xlYXI6IGNsZWFyVGFza1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190YXNrLmpzXG4vLyBtb2R1bGUgaWQgPSA0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHsgZTogZmFsc2UsIHY6IGV4ZWMoKSB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHsgZTogdHJ1ZSwgdjogZSB9O1xuICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3BlcmZvcm0uanNcbi8vIG1vZHVsZSBpZCA9IDQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSByZXF1aXJlKCcuL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEMsIHgpIHtcbiAgYW5PYmplY3QoQyk7XG4gIGlmIChpc09iamVjdCh4KSAmJiB4LmNvbnN0cnVjdG9yID09PSBDKSByZXR1cm4geDtcbiAgdmFyIHByb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkuZihDKTtcbiAgdmFyIHJlc29sdmUgPSBwcm9taXNlQ2FwYWJpbGl0eS5yZXNvbHZlO1xuICByZXNvbHZlKHgpO1xuICByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHkucHJvbWlzZTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvbWlzZS1yZXNvbHZlLmpzXG4vLyBtb2R1bGUgaWQgPSA0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIHJpdGVyID0gWzddW0lURVJBVE9SXSgpO1xuICByaXRlclsncmV0dXJuJ10gPSBmdW5jdGlvbiAoKSB7IFNBRkVfQ0xPU0lORyA9IHRydWU7IH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXG4gIEFycmF5LmZyb20ocml0ZXIsIGZ1bmN0aW9uICgpIHsgdGhyb3cgMjsgfSk7XG59IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYywgc2tpcENsb3NpbmcpIHtcbiAgaWYgKCFza2lwQ2xvc2luZyAmJiAhU0FGRV9DTE9TSU5HKSByZXR1cm4gZmFsc2U7XG4gIHZhciBzYWZlID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IFs3XTtcbiAgICB2YXIgaXRlciA9IGFycltJVEVSQVRPUl0oKTtcbiAgICBpdGVyLm5leHQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB7IGRvbmU6IHNhZmUgPSB0cnVlIH07IH07XG4gICAgYXJyW0lURVJBVE9SXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGl0ZXI7IH07XG4gICAgZXhlYyhhcnIpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIHNhZmU7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGV0ZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vanNvbi9zdHJpbmdpZnlcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvanNvbi9zdHJpbmdpZnkuanNcbi8vIG1vZHVsZSBpZCA9IDQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcbmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjogW1xyXG4gIFwiZXJyb3JcIiwgeyBcInByb3BzXCI6IHRydWUsIFwiaWdub3JlUHJvcGVydHlNb2RpZmljYXRpb25zRm9yXCI6IFtcImVsZW1lbnRcIl0gfVxyXG5dXHJcbiovXHJcbi8qIGVzbGludCBuby11c2UtYmVmb3JlLWRlZmluZTogW1wiZXJyb3JcIiwgeyBcImZ1bmN0aW9uc1wiOiBmYWxzZSB9XSAqL1xyXG4vKiBlc2xpbnQtZW52IGVzNiAqL1xyXG5pbXBvcnQgU3RvcmFnZSBmcm9tICcuL21vZHVsZXMvc3RvcmFnZSc7XHJcblxyXG5jb25zdCByZXNlcnZlZEVsZW1lbnRzID0gWydkaXYnLCAnYm9keScsICdoZWFkJywgJ2ltZycsICdzdHlsZScsICdzcGFuJywgJ3VsJywgJ2xpJywgJ2lucHV0JywgJ2J1dHRvbicsICdoMScsICdoMicsICdoMycsICdoNCcsICdhJywgJ3AnLCAnc3Ryb25nJywgJ3N2ZyddO1xyXG5jb25zdCBHZXRFbGVtZW50ID0gc2VsZWN0b3IgPT4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XHJcblxyXG5jb25zdCAkRUxNX0VMRU1FTlQgPSAoZWxlbWVudCkgPT4ge1xyXG4gIGNvbnN0IHJlY3QgPSBhcmcgPT4gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVthcmddO1xyXG4gIHJldHVybiB7XHJcbiAgICBhdHRyKC4uLmFyZ3MpIHtcclxuICAgICAgaWYgKGVsZW1lbnQpIHtcclxuICAgICAgICBjb25zdCBbYXR0ciwgdmFsdWVdID0gYXJncy5sZW5ndGggPT09IDIgPyBbLi4uYXJnc10gOiBhcmdzWzBdLnNwbGl0KCc6Jyk7XHJcbiAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShhdHRyLCB2YWx1ZSk7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHIpO1xyXG4gICAgICB9XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHthcmdzfSBFbGVtZW50IGRvZXMgbm90IGV4aXN0ISBGdW5jdGlvbiAnYXR0cidgKTtcclxuICAgIH0sXHJcbiAgICBoZWlnaHQoKSB7XHJcbiAgICAgIHJldHVybiByZWN0KCdoZWlnaHQnKTtcclxuICAgIH0sXHJcbiAgICBjbGljayhjYWxsYmFjaykge1xyXG4gICAgICBpZiAoZWxlbWVudCkge1xyXG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjYWxsYmFjayk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgIH1cclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NhbGxiYWNrfSBFbGVtZW50IGRvZXMgbm90IGV4aXN0ISBGdW5jdGlvbiAnY2xpY2snYCk7XHJcbiAgICB9LFxyXG4gICAgaHRtbChzdHIpIHtcclxuICAgICAgaWYgKGVsZW1lbnQpIHtcclxuICAgICAgICBpZiAoIXN0cikgcmV0dXJuIGVsZW1lbnQuaW5uZXJIVE1MO1xyXG4gICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gc3RyO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICB9XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtzdHJ9IEVsZW1lbnQgZG9lcyBub3QgZXhpc3QhIEZ1bmN0aW9uICdodG1sJ2ApO1xyXG4gICAgfSxcclxuICAgIHRleHQoc3RyKSB7XHJcbiAgICAgIGlmIChlbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKCFzdHIpIHJldHVybiBlbGVtZW50LmlubmVySFRNTDtcclxuICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9ICcnO1xyXG4gICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoc3RyKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgIH1cclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3N0cn0gRWxlbWVudCBkb2VzIG5vdCBleGlzdCEgRnVuY3Rpb24gJ3RleHQnYCk7XHJcbiAgICB9LFxyXG4gICAgaW1hZ2Uoc3JjKSB7XHJcbiAgICAgIGlmIChlbGVtZW50KSB7XHJcbiAgICAgICAgZWxlbWVudC5zcmMgPSBzcmM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgIH1cclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3NyY30gRWxlbWVudCBkb2VzIG5vdCBleGlzdCEgRnVuY3Rpb24gJ2ltYWdlJ2ApO1xyXG4gICAgfSxcclxuICAgIGhyZWYodXJsKSB7XHJcbiAgICAgIGlmIChlbGVtZW50KSB7XHJcbiAgICAgICAgZWxlbWVudC5ocmVmID0gdXJsO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICB9XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHt1cmx9IEVsZW1lbnQgZG9lcyBub3QgZXhpc3QhIEZ1bmN0aW9uICdocmVmJ2ApO1xyXG4gICAgfSxcclxuICAgIGFwcGVuZEZpcnN0KGNoaWxkKSB7XHJcbiAgICAgIGNvbnN0IGMgPSBjaGlsZC5ub2RlVHlwZSA/IGNoaWxkIDogY2hpbGQuZWxlbWVudDtcclxuICAgICAgaWYgKGVsZW1lbnQpIHtcclxuICAgICAgICBlbGVtZW50Lmluc2VydEJlZm9yZShjLCBlbGVtZW50LmNoaWxkTm9kZXNbMF0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICB9XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjaGlsZH0gRWxlbWVudCBkb2VzIG5vdCBleGlzdCEgRnVuY3Rpb24gJ2FwcGVuZCdgKTtcclxuICAgIH0sXHJcbiAgICBhcHBlbmQoY2hpbGQpIHtcclxuICAgICAgY29uc3QgYyA9IGNoaWxkLm5vZGVUeXBlID8gY2hpbGQgOiBjaGlsZC5lbGVtZW50O1xyXG4gICAgICBpZiAoZWxlbWVudCkge1xyXG4gICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoYyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgIH1cclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NoaWxkfSBFbGVtZW50IGRvZXMgbm90IGV4aXN0ISBGdW5jdGlvbiAnYXBwZW5kJ2ApO1xyXG4gICAgfSxcclxuICAgIGFwcGVuZEFsbCguLi5jaGlsZHMpIHtcclxuICAgICAgcmV0dXJuIGNoaWxkcy5tYXAodGhpcy5hcHBlbmQpO1xyXG4gICAgfSxcclxuICAgIGNzcyhjbikge1xyXG4gICAgICBpZiAoY24pIHtcclxuICAgICAgICBjbi5zcGxpdCgnICcpXHJcbiAgICAgICAgICAuam9pbignLCcpXHJcbiAgICAgICAgICAuc3BsaXQoJywnKVxyXG4gICAgICAgICAgLmZvckVhY2goYyA9PiBjICYmIGVsZW1lbnQgJiYgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGMucmVwbGFjZSgvXFwuL2csICcnKS50cmltKCkpKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcbiAgICBnZXQoLi4uYXJncykge1xyXG4gICAgICBpZiAoZWxlbWVudCkge1xyXG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkgcmV0dXJuICRFTE1fRUxFTUVOVChlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoYXJnc1swXSkpO1xyXG4gICAgICAgIHJldHVybiBhcmdzLm1hcChhcmcgPT4gJEVMTV9FTEVNRU5UKGVsZW1lbnQucXVlcnlTZWxlY3RvcihhcmcpKSk7XHJcbiAgICAgIH1cclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2FyZ3N9IEVsZW1lbnQgZG9lcyBub3QgZXhpc3QhIEZ1bmN0aW9uICdnZXQnYCk7XHJcbiAgICB9LFxyXG4gICAgY2hpbGRyZW4oYXJnKSB7XHJcbiAgICAgIGlmIChhcmcpIHtcclxuICAgICAgICBjb25zdCBsaXN0ID0gQXJyYXkuZnJvbShlbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKGFyZykpO1xyXG4gICAgICAgIHJldHVybiBsaXN0Lm1hcChjaGlsZCA9PiAkRUxNX0VMRU1FTlQoY2hpbGQpKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBsaXN0ID0gQXJyYXkuZnJvbShlbGVtZW50LmNoaWxkTm9kZXMpO1xyXG4gICAgICByZXR1cm4gbGlzdC5tYXAoY2hpbGQgPT4gJEVMTV9FTEVNRU5UKGNoaWxkKSk7XHJcbiAgICB9LFxyXG4gICAgc3R5bGUoc3RsKSB7XHJcbiAgICAgIGlmIChlbGVtZW50KSB7XHJcbiAgICAgICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LnN0eWxlLCBzdGwpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICB9XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtzdGx9IEVsZW1lbnQgZG9lcyBub3QgZXhpc3QhIEZ1bmN0aW9uICdzdHlsZSdgKTtcclxuICAgIH0sXHJcbiAgICBkYXRhKGtleSwgdmFsdWUpIHtcclxuICAgICAgaWYgKGVsZW1lbnQpIHtcclxuICAgICAgICBlbGVtZW50LmRhdGFzZXRba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICB9XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtrZXl9ICR7dmFsdWV9IEVsZW1lbnQgZG9lcyBub3QgZXhpc3QhIEZ1bmN0aW9uICdkYXRhJ2ApO1xyXG4gICAgfSxcclxuICAgIGVsZW1lbnQsXHJcbiAgfTtcclxufTtcclxuXHJcbmNvbnN0IENyZWF0ZUVsZW1lbnQgPSAoYXJnKSA9PiB7XHJcbiAgaWYgKGFyZyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSByZXR1cm4gJEVMTV9FTEVNRU5UKGFyZyk7XHJcbiAgY29uc3QgYXJyID0gYXJnLnNwbGl0KCcgJyk7XHJcbiAgY29uc3QgdHlwZSA9IGFyci5yZWR1Y2UoKGFjYywgY3VycmVudCkgPT4ge1xyXG4gICAgaWYgKHJlc2VydmVkRWxlbWVudHMuaW5jbHVkZXMoY3VycmVudCkpIHtcclxuICAgICAgcmV0dXJuIGN1cnJlbnQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYWNjO1xyXG4gIH0sICdkaXYnKTtcclxuXHJcbiAgY29uc3QgY2xhc3NOYW1lcyA9IGFyci5maWx0ZXIoY3VycmVudCA9PiAhcmVzZXJ2ZWRFbGVtZW50cy5pbmNsdWRlcyhjdXJyZW50KSkuam9pbigpO1xyXG4gIGNvbnN0IGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSk7XHJcbiAgcmV0dXJuICRFTE1fRUxFTUVOVChkb20pLmNzcyhjbGFzc05hbWVzKTtcclxufTtcclxuXHJcbmNvbnN0IENyZWF0ZUVsZW1lbnRCeU9iamVjdCA9ICh0eXBlLCBpdGVyYWJsZSkgPT4ge1xyXG4gIGNvbnN0IGVsZW1lbnQgPSBDcmVhdGVFbGVtZW50KHR5cGUpO1xyXG4gIE9iamVjdC5rZXlzKGl0ZXJhYmxlKS5mb3JFYWNoKChpdGVtKSA9PiB7XHJcbiAgICBjb25zdCBmdW5jID0gZWxlbWVudFtpdGVtXTtcclxuICAgIGlmIChmdW5jKSB7XHJcbiAgICAgIGNvbnN0IHZhbHVlID0gaXRlcmFibGVbaXRlbV07XHJcbiAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5sZW5ndGgpIHtcclxuICAgICAgICBmdW5jKHZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0pO1xyXG4gIHJldHVybiBlbGVtZW50O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0ICRFTE0gPSB7XHJcbiAgZWxtczoge30sXHJcbiAgY3JlYXRlKC4uLmFyZ3MpIHtcclxuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIENyZWF0ZUVsZW1lbnQoYXJnc1swXSk7XHJcbiAgICByZXR1cm4gYXJncy5tYXAoYXJnID0+IENyZWF0ZUVsZW1lbnQoYXJnKSk7XHJcbiAgfSxcclxuICBidWlsZCh0eXBlLCBpdGVyYWJsZSkge1xyXG4gICAgcmV0dXJuIENyZWF0ZUVsZW1lbnRCeU9iamVjdCh0eXBlLCBpdGVyYWJsZSk7XHJcbiAgfSxcclxuICBnZXQoLi4uYXJncykge1xyXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgIGNvbnN0IGtleSA9IE51bWJlci5pc0ludGVnZXIocGFyc2VJbnQoYXJnc1swXSwgMTApKSA/IHBhcnNlSW50KGFyZ3NbMF0sIDEwKSA6IGFyZ3NbMF07XHJcbiAgICAgIHJldHVybiB0aGlzLmVsbXNba2V5XSB8fCAkRUxNX0VMRU1FTlQoR2V0RWxlbWVudChrZXkpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBhcmdzLm1hcCgoYXJnKSA9PiB7XHJcbiAgICAgIGNvbnN0IGtleSA9IE51bWJlci5pc0ludGVnZXIocGFyc2VJbnQoYXJnLCAxMCkpID8gcGFyc2VJbnQoYXJnLCAxMCkgOiBhcmc7XHJcbiAgICAgIHJldHVybiB0aGlzLmVsbXNba2V5XSB8fCAkRUxNX0VMRU1FTlQoR2V0RWxlbWVudChrZXkpKTtcclxuICAgIH0pO1xyXG4gIH0sXHJcbiAgc2F2ZShpZCwgZWxlbWVudCkge1xyXG4gICAgdGhpcy5lbG1zW2lkXSA9IHRoaXMuZWxtc1tpZF0gfHwge307XHJcbiAgICB0aGlzLmVsbXNbaWRdID0gZWxlbWVudDtcclxuICB9LFxyXG4gIGNvcHkoc2VsZWN0b3IpIHtcclxuICAgIGNvbnN0IGNoaWxkID0gR2V0RWxlbWVudChzZWxlY3Rvcik7XHJcbiAgICBpZiAoY2hpbGQpIHtcclxuICAgICAgcmV0dXJuIENyZWF0ZUVsZW1lbnQoY2hpbGQuY2xvbmVOb2RlKHRydWUpKTtcclxuICAgIH1cclxuICAgIHRocm93IG5ldyBFcnJvcihgJHtzZWxlY3Rvcn0gRWxlbWVudCBkb2VzIG5vdCBleGlzdCEgRnVuY3Rpb24gJ2NvcHknYCk7XHJcbiAgfSxcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBJQ0FDUk8gPSAoKSA9PiB7XHJcbiAgJEVMTS5nZXQoJ2JvZHknKS5jc3MoJ2NybycpO1xyXG4gIHJldHVybiB7XHJcbiAgICBnZXRFbGVtZW50Q29udGVudEJ5VGFnQW5kQXR0cihyZWdleHAsIHRhZywgYXR0cikge1xyXG4gICAgICBjb25zdCBxc2EgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHRhZyk7XHJcbiAgICAgIHJldHVybiB0aGlzLnRvQXJyYXkocXNhKS5yZWR1Y2UoKGFjYywgZWxlbWVudCkgPT4ge1xyXG4gICAgICAgIGlmIChuZXcgUmVnRXhwKHJlZ2V4cCkudGVzdChlbGVtZW50W2F0dHJdKSkge1xyXG4gICAgICAgICAgYWNjLnB1c2goZWxlbWVudFthdHRyXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhY2M7XHJcbiAgICAgIH0sIFtdKTtcclxuICAgIH0sXHJcbiAgICByZW1vdmVFbGVtZW50cyhjbGFzc05hbWVzKSB7XHJcbiAgICAgIGNsYXNzTmFtZXMuZm9yRWFjaCgoY2xhc3NOYW1lKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZWxtID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihjbGFzc05hbWUpO1xyXG4gICAgICAgIGlmIChlbG0gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkgZWxtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxtKTtcclxuICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgdG9BcnJheShsaXN0KSB7IHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChsaXN0KTsgfSxcclxuICAgIGxvYWQoLi4uYXJncykge1xyXG4gICAgICBjb25zdCBbdXJsLCBvcHRpb25zXSA9IGFyZ3M7XHJcbiAgICAgIGNvbnN0IG9wcyA9IE9iamVjdC5hc3NpZ24oe30sIHsgbWV0aG9kOiAnZ2V0JyB9LCBvcHRpb25zKTtcclxuICAgICAgcmV0dXJuIGZldGNoKHVybCwgb3BzKVxyXG4gICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmpzb24oKSlcclxuICAgICAgICAuY2F0Y2goZXJyID0+IGVycik7XHJcbiAgICB9LFxyXG4gICAgc3R5bGUoc3R5bGVzKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdzdHlsZSBpcyBkZXByZWNhdGVkLi4uIHVzZSBjc3MgYW5kIHJlcXVpcmUuJyk7XHJcbiAgICAgIGNvbnN0IHN0eWxlID0gJEVMTS5jcmVhdGUoJ3N0eWxlJyk7XHJcbiAgICAgIHN0eWxlLmF0dHIoJ3R5cGUnLCAndGV4dC9jc3MnKTtcclxuICAgICAgc3R5bGUuYXBwZW5kKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHN0eWxlcykpO1xyXG4gICAgICAkRUxNLmdldCgnaGVhZCcpLmFwcGVuZChzdHlsZSk7XHJcbiAgICB9LFxyXG4gICAgaXNMb2dnZWRJbigpIHtcclxuICAgICAgcmV0dXJuICRFTE0uZ2V0KCcjaGRuSWNhU3RhdGUnKS5hdHRyKCd2YWx1ZScpLmxlbmd0aCA+IDE7XHJcbiAgICB9LFxyXG4gICAgZ2FQdXNoKHsgZXZlbnRDYXRlZ29yeSA9ICdBL0InLCBldmVudEFjdGlvbiwgZXZlbnRMYWJlbCB9KSB7XHJcbiAgICAgIGlmIChnYSkge1xyXG4gICAgICAgIGdhKCdzZW5kJywgJ2V2ZW50JywgZXZlbnRDYXRlZ29yeSwgZXZlbnRBY3Rpb24sIGV2ZW50TGFiZWwpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgc3RvcmFnZToge1xyXG4gICAgICBzZXQoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIFN0b3JhZ2Uuc2V0KGtleSwgdmFsdWUpO1xyXG4gICAgICB9LFxyXG4gICAgICBnZXQoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIFN0b3JhZ2UuZ2V0KGtleSk7XHJcbiAgICAgIH0sXHJcbiAgICAgIGNsZWFyKCkge1xyXG4gICAgICAgIFN0b3JhZ2UuY2xlYXIoKTtcclxuICAgICAgfSxcclxuICAgIH0sXHJcbiAgfTtcclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3V0aWwvbWFpbi5qcyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9hcnJheS9mcm9tXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL2FycmF5L2Zyb20uanNcbi8vIG1vZHVsZSBpZCA9IDQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2lzSXRlcmFibGUyID0gcmVxdWlyZShcIi4uL2NvcmUtanMvaXMtaXRlcmFibGVcIik7XG5cbnZhciBfaXNJdGVyYWJsZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc0l0ZXJhYmxlMik7XG5cbnZhciBfZ2V0SXRlcmF0b3IyID0gcmVxdWlyZShcIi4uL2NvcmUtanMvZ2V0LWl0ZXJhdG9yXCIpO1xuXG52YXIgX2dldEl0ZXJhdG9yMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldEl0ZXJhdG9yMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHtcbiAgICB2YXIgX2FyciA9IFtdO1xuICAgIHZhciBfbiA9IHRydWU7XG4gICAgdmFyIF9kID0gZmFsc2U7XG4gICAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9pID0gKDAsIF9nZXRJdGVyYXRvcjMuZGVmYXVsdCkoYXJyKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfZCA9IHRydWU7XG4gICAgICBfZSA9IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9hcnI7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgIHJldHVybiBhcnI7XG4gICAgfSBlbHNlIGlmICgoMCwgX2lzSXRlcmFibGUzLmRlZmF1bHQpKE9iamVjdChhcnIpKSkge1xuICAgICAgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG4gICAgfVxuICB9O1xufSgpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSA0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmV0dXJuIFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgY29udGVudCArIFwifVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0fSkuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcblx0dmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cdGlmICghY3NzTWFwcGluZykge1xuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0aWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuXHRcdHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcblx0fVxuXG5cdHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuXHR2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xuXG5cdHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1xuLy8gbW9kdWxlIGlkID0gNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cblxudmFyIHN0eWxlc0luRG9tID0ge307XG5cbnZhclx0bWVtb2l6ZSA9IGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbztcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG1lbW87XG5cdH07XG59O1xuXG52YXIgaXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xuXHQvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuXHQvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG5cdC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcblx0Ly8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG5cdC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuXHRyZXR1cm4gd2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2I7XG59KTtcblxudmFyIGdldEVsZW1lbnQgPSAoZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vID0ge307XG5cblx0cmV0dXJuIGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG5cdFx0aWYgKHR5cGVvZiBtZW1vW3NlbGVjdG9yXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0dmFyIHN0eWxlVGFyZ2V0ID0gZm4uY2FsbCh0aGlzLCBzZWxlY3Rvcik7XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuXHRcdFx0aWYgKHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcblx0XHRcdFx0XHQvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG5cdFx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bWVtb1tzZWxlY3Rvcl0gPSBzdHlsZVRhcmdldDtcblx0XHR9XG5cdFx0cmV0dXJuIG1lbW9bc2VsZWN0b3JdXG5cdH07XG59KShmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldClcbn0pO1xuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhclx0c2luZ2xldG9uQ291bnRlciA9IDA7XG52YXJcdHN0eWxlc0luc2VydGVkQXRUb3AgPSBbXTtcblxudmFyXHRmaXhVcmxzID0gcmVxdWlyZShcIi4vdXJsc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XG5cdGlmICh0eXBlb2YgREVCVUcgIT09IFwidW5kZWZpbmVkXCIgJiYgREVCVUcpIHtcblx0XHRpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG5cdH1cblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRvcHRpb25zLmF0dHJzID0gdHlwZW9mIG9wdGlvbnMuYXR0cnMgPT09IFwib2JqZWN0XCIgPyBvcHRpb25zLmF0dHJzIDoge307XG5cblx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG5cdC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2Vcblx0aWYgKCFvcHRpb25zLnNpbmdsZXRvbikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgPGhlYWQ+IGVsZW1lbnRcblx0aWYgKCFvcHRpb25zLmluc2VydEludG8pIG9wdGlvbnMuaW5zZXJ0SW50byA9IFwiaGVhZFwiO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiB0aGUgdGFyZ2V0XG5cdGlmICghb3B0aW9ucy5pbnNlcnRBdCkgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XG5cblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0LCBvcHRpb25zKTtcblxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xuXHRcdH1cblxuXHRcdGlmKG5ld0xpc3QpIHtcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCwgb3B0aW9ucyk7XG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XG5cblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykgZG9tU3R5bGUucGFydHNbal0oKTtcblxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMsIG9wdGlvbnMpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdGlmKGRvbVN0eWxlKSB7XG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyAobGlzdCwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGVzID0gW107XG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XG5cdFx0dmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XG5cdFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XG5cblx0XHRpZighbmV3U3R5bGVzW2lkXSkgc3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcblx0XHRlbHNlIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcblx0fVxuXG5cdHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudCAob3B0aW9ucywgc3R5bGUpIHtcblx0dmFyIHRhcmdldCA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvKVxuXG5cdGlmICghdGFyZ2V0KSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnRJbnRvJyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG5cdH1cblxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZXNJbnNlcnRlZEF0VG9wW3N0eWxlc0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XG5cblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcblx0XHRpZiAoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCB0YXJnZXQuZmlyc3RDaGlsZCk7XG5cdFx0fSBlbHNlIGlmIChsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHRcdH1cblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGUpO1xuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcblx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlKSB7XG5cdFx0dmFyIG5leHRTaWJsaW5nID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8gKyBcIiBcIiArIG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlKTtcblx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBuZXh0U2libGluZyk7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiW1N0eWxlIExvYWRlcl1cXG5cXG4gSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcgKCdvcHRpb25zLmluc2VydEF0JykgZm91bmQuXFxuIE11c3QgYmUgJ3RvcCcsICdib3R0b20nLCBvciBPYmplY3QuXFxuIChodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlciNpbnNlcnRhdClcXG5cIik7XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50IChzdHlsZSkge1xuXHRpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXHRzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcblxuXHR2YXIgaWR4ID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlKTtcblx0aWYoaWR4ID49IDApIHtcblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG5cblx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXG5cdGFkZEF0dHJzKHN0eWxlLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlKTtcblxuXHRyZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG5cblx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHRvcHRpb25zLmF0dHJzLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuXG5cdGFkZEF0dHJzKGxpbmssIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGluayk7XG5cblx0cmV0dXJuIGxpbms7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHJzIChlbCwgYXR0cnMpIHtcblx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdGVsLnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGUsIHVwZGF0ZSwgcmVtb3ZlLCByZXN1bHQ7XG5cblx0Ly8gSWYgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gd2FzIGRlZmluZWQsIHJ1biBpdCBvbiB0aGUgY3NzXG5cdGlmIChvcHRpb25zLnRyYW5zZm9ybSAmJiBvYmouY3NzKSB7XG5cdCAgICByZXN1bHQgPSBvcHRpb25zLnRyYW5zZm9ybShvYmouY3NzKTtcblxuXHQgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgXHQvLyBJZiB0cmFuc2Zvcm0gcmV0dXJucyBhIHZhbHVlLCB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIHJ1bm5pbmcgcnVudGltZSB0cmFuc2Zvcm1hdGlvbnMgb24gdGhlIGNzcy5cblx0ICAgIFx0b2JqLmNzcyA9IHJlc3VsdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICBcdC8vIElmIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCBkb24ndCBhZGQgdGhpcyBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIGNvbmRpdGlvbmFsIGxvYWRpbmcgb2YgY3NzXG5cdCAgICBcdHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgIFx0XHQvLyBub29wXG5cdCAgICBcdH07XG5cdCAgICB9XG5cdH1cblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblxuXHRcdHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcblxuXHR9IGVsc2UgaWYgKFxuXHRcdG9iai5zb3VyY2VNYXAgJiZcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiXG5cdCkge1xuXHRcdHN0eWxlID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXG5cdFx0XHRpZihzdHlsZS5ocmVmKSBVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlLmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXHRcdH07XG5cdH1cblxuXHR1cGRhdGUob2JqKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaikge1xuXHRcdGlmIChuZXdPYmopIHtcblx0XHRcdGlmIChcblx0XHRcdFx0bmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuXHRcdFx0XHRuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuXHRcdFx0XHRuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcblx0fTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xuXG5cdGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGUsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGUuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXG5cdH1cblxuXHRpZihzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpIHtcblx0XHRcdHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuXHRcdH1cblxuXHRcdHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsgKGxpbmssIG9wdGlvbnMsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0Lypcblx0XHRJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcblx0XHRhbmQgdGhlcmUgaXMgbm8gcHVibGljUGF0aCBkZWZpbmVkIHRoZW4gbGV0cyB0dXJuIGNvbnZlcnRUb0Fic29sdXRlVXJsc1xuXHRcdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxuXHRcdGRpcmVjdGx5XG5cdCovXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xuXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscykge1xuXHRcdGNzcyA9IGZpeFVybHMoY3NzKTtcblx0fVxuXG5cdGlmIChzb3VyY2VNYXApIHtcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcblx0fVxuXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xuXG5cdHZhciBvbGRTcmMgPSBsaW5rLmhyZWY7XG5cblx0bGluay5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpIFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXG4vLyBtb2R1bGUgaWQgPSA1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiBlc2xpbnQgbm8taW5uZXItZGVjbGFyYXRpb25zOiBcIm9mZlwiICovXHJcbi8qIGVzbGludCBuby11c2UtYmVmb3JlLWRlZmluZTogXCJvZmZcIiAqL1xyXG5cclxuLy8gPT1Vc2VyU2NyaXB0PT1cclxuLy8gQG5hbWUgICAgICAgICBTdGFydC1wYWdlXHJcbi8vIEBwYXRoICAgICAgICAgLy8uL3NyYy9zdGFydC1wYWdlL3ZhcmlhbnQuanNcclxuLy8gQG5hbWVzcGFjZSAgICBodHRwOi8vdGFtcGVybW9ua2V5Lm5ldC9cclxuLy8gQHZlcnNpb24gICAgICAwLjFcclxuLy8gQG1hdGNoICAgICAgICBodHRwczovL3d3dy5pY2Euc2UvKlxyXG4vLyBAZ3JhbnQgICAgICAgIG5vbmVcclxuLy8gPT0vVXNlclNjcmlwdD09XHJcblxyXG5pbXBvcnQgeyBJQ0FDUk8sICRFTE0gfSBmcm9tICcuLi91dGlsL21haW4nO1xyXG5pbXBvcnQgUmF0aW5ncyBmcm9tICcuLi91dGlsL21vZHVsZXMvcmF0aW5ncyc7XHJcbmltcG9ydCBiYW5uZXJzIGZyb20gJy4vYmFubmVycyc7XHJcbmltcG9ydCBjb3Vwb25zIGZyb20gJy4vY291cG9ucyc7XHJcblxyXG5pbXBvcnQgJy4vc3R5bGUuY3NzJztcclxuXHJcbihmdW5jdGlvbiAoJCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgY29uc3QgTE9HSU5fQUNUSU9OID0ge1xyXG4gICAgU0FWRV9SRUNJUEU6ICdTUEFSQScsXHJcbiAgICBMT0FEX0NPVVBPTjogJ0xBRERBJyxcclxuICB9O1xyXG4gIGNvbnN0IEFDVElPTl9DT09LSUVTID0ge1xyXG4gICAgU0FWRV9SRUNJUEU6ICdjcm9fc3RhcnRwYWdlX2FjdGlvbkNvb2tpZV9zYXZlUmVjaXBlJyxcclxuICAgIExPQURfQ09VUE9OOiAnY3JvX3N0YXJ0cGFnZV9hY3Rpb25Db29raWVfbG9hZENvdXBvbicsXHJcbiAgfTtcclxuICBjb25zdCBsb2FkZWRDb3Vwb25zID0gW107XHJcblxyXG4gIC8vIGlmIChoaikgaGooJ3RyaWdnZXInLCd2YXJpYW50NScpOy8vIGVzbGludC1kaXNhYmxlLWxpbmVcclxuICBjb25zdCB0ZXN0ID0ge1xyXG4gICAgY3JlYXRlKGNsYXNzTmFtZSwgcGFyZW50LCB0ZXh0LCB0eXBlKSB7XHJcbiAgICAgIGNvbnN0IHQgPSB0eXBlIHx8ICdkaXYnO1xyXG4gICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHQpO1xyXG4gICAgICBpZiAodGV4dCAmJiB0eXBlID09PSAnaW1nJykge1xyXG4gICAgICAgIGRpdi5zcmMgPSB0ZXh0O1xyXG4gICAgICB9IGVsc2UgaWYgKHRleHQpIHtcclxuICAgICAgICBkaXYuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCkpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChjbGFzc05hbWUpIGRpdi5jbGFzc05hbWUgPSBjbGFzc05hbWU7XHJcbiAgICAgIGlmIChwYXJlbnQpIHBhcmVudC5hcHBlbmRDaGlsZChkaXYpO1xyXG4gICAgICByZXR1cm4gZGl2O1xyXG4gICAgfSxcclxuICAgIGFkZENvdXBvbihjb3Vwb24pIHtcclxuICAgICAgY29uc3QgY291cG9uSXRlbSA9ICRFTE0uY3JlYXRlKCdjb3Vwb25zLWNvbnRhaW5lcl9faXRlbScpO1xyXG4gICAgICBjb25zdCBpbWcgPSAkRUxNLmNyZWF0ZSgnaW1nJyk7XHJcbiAgICAgIGNvbnN0IHRpdGxlID0gJEVMTS5jcmVhdGUoJ2gzJyk7XHJcbiAgICAgIGNvbnN0IGRpc2NvdW50ID0gJEVMTS5jcmVhdGUoJ2gxJyk7XHJcbiAgICAgIGNvbnN0IHN1YnRpdGxlID0gJEVMTS5jcmVhdGUoJ2g0Jyk7XHJcbiAgICAgIGNvbnN0IG1vcmVJbmZvID0gJEVMTS5jcmVhdGUoJ2EnKTtcclxuICAgICAgY29uc3QgYnV0dG9uID0gJEVMTS5jcmVhdGUoJ2J1dHRvbiAuYnV0dG9uIGNvdXBvbi1idXR0b24nKTtcclxuXHJcbiAgICAgIHRpdGxlLnRleHQoY291cG9uLnRpdGxlKTtcclxuICAgICAgZGlzY291bnQudGV4dChjb3Vwb24uZGlzY291bnQpO1xyXG4gICAgICBzdWJ0aXRsZS50ZXh0KGNvdXBvbi5zdWJ0aXRsZSk7XHJcbiAgICAgIG1vcmVJbmZvLnRleHQoJ01lciBpbmZvJyk7XHJcbiAgICAgIGJ1dHRvbi50ZXh0KCdMYWRkYSBrdXBvbmcnKTtcclxuICAgICAgaW1nLmltYWdlKGNvdXBvbi5pbWFnZSk7XHJcbiAgICAgIG1vcmVJbmZvLmhyZWYoY291cG9uLnVybCk7XHJcblxyXG4gICAgICBidXR0b24uY2xpY2soKCkgPT4ge1xyXG4gICAgICAgIGlmICh0aGlzLmlzTG9nZ2VkSW4oKSkge1xyXG4gICAgICAgICAgdGhpcy5sb2FkQ291cG9uT25DYXJkKGNvdXBvbikudGhlbigocmVzcG9uc2UpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5jaGFuZ2VPZmZlclN0YXR1cyhyZXNwb25zZSwgY291cG9uKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpY2FkYXRhbGF5ZXIuYWRkKCdIU0UnLCB7XHJcbiAgICAgICAgICAgIEhTRToge1xyXG4gICAgICAgICAgICAgIGFjdGlvbjogJ2xvZ2luLW1vdXNlZG93bicsXHJcbiAgICAgICAgICAgICAgbmFtZTogY291cG9uLlBhZ2VOYW1lLFxyXG4gICAgICAgICAgICAgIGhzZXVybDogY291cG9uLnVybCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIGNvbnN0IGNvb2tpZURhdGEgPSB7XHJcbiAgICAgICAgICAgIFBhZ2VOYW1lOiBjb3Vwb24uUGFnZU5hbWUsXHJcbiAgICAgICAgICAgIHJlY2lwZUlkOiBjb3Vwb24ucmVjaXBlSWQsXHJcbiAgICAgICAgICAgIHRpdGxlOiBjb3Vwb24uUGFnZU5hbWUsXHJcbiAgICAgICAgICAgIHVybDogY291cG9uLlBhZ2VOYW1lLFxyXG4gICAgICAgICAgICBPZmZlcklkOiBjb3Vwb24uT2ZmZXIsXHJcbiAgICAgICAgICAgIENhbXBhaWduSWQ6IGNvdXBvbi5QYWdlTmFtZSxcclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgdGhpcy5zZXRBY3Rpb25Db29raWUoQUNUSU9OX0NPT0tJRVMuTE9BRF9DT1VQT04sIGNvb2tpZURhdGEpO1xyXG4gICAgICAgICAgdGhpcy5jcmVhdGVNb2RhbChMT0dJTl9BQ1RJT04uTE9BRF9DT1VQT04pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpY2FkYXRhbGF5ZXIuYWRkKCdIU0UnLCB7XHJcbiAgICAgICAgSFNFOiB7XHJcbiAgICAgICAgICBhY3Rpb246ICdkaXNwbGF5JyxcclxuICAgICAgICAgIHRpdGxlOiBjb3Vwb24uUGFnZU5hbWUsXHJcbiAgICAgICAgICBoc2V1cmw6IGNvdXBvbi51cmwsXHJcbiAgICAgICAgfSxcclxuICAgICAgfSk7XHJcbiAgICAgIGNvdXBvbkl0ZW0uYXR0cignaWQnLCBgY291cG9uLSR7Y291cG9uLk9mZmVySWR9LSR7Y291cG9uLnJlY2lwZUlkfWApO1xyXG4gICAgICB0aGlzLmxvYWRDb3Vwb25EYXRhKGNvdXBvbikudGhlbigoZGF0YSkgPT4ge1xyXG4gICAgICAgIGlmIChkYXRhLk9mZmVyLkxvYWRlZE9uQ2FyZCkge1xyXG4gICAgICAgICAgY291cG9uSXRlbS5jc3MoJ29mZmVyLWxvYWRlZCcpO1xyXG4gICAgICAgICAgYnV0dG9uLnRleHQoJ0t1cG9uZyBsYWRkYWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICBjb3Vwb25JdGVtLmFwcGVuZEFsbChpbWcsIHRpdGxlLCBkaXNjb3VudCwgc3VidGl0bGUsIG1vcmVJbmZvLCBidXR0b24pO1xyXG4gICAgICByZXR1cm4gY291cG9uSXRlbTtcclxuICAgIH0sXHJcbiAgICBhZGRCYW5uZXIoYmFubmVyKSB7XHJcbiAgICAgIGNvbnN0IGJhbm5lckNvbnRhaW5lciA9ICRFTE0uY3JlYXRlKCdsaSBiYW5uZXItY29udGFpbmVyJyk7XHJcbiAgICAgIGNvbnN0IGJhbm5lckNvbnRhaW5lckltZyA9ICRFTE0uY3JlYXRlKCdiYW5uZXItY29udGFpbmVyX19pbWcnKTtcclxuICAgICAgY29uc3QgaW1nID0gJEVMTS5jcmVhdGUoJ2ltZycpO1xyXG4gICAgICBpbWcuaW1hZ2UoYmFubmVyLmltYWdlKTtcclxuICAgICAgYmFubmVyQ29udGFpbmVySW1nLmFwcGVuZChpbWcpO1xyXG4gICAgICBiYW5uZXJDb250YWluZXJJbWcuaW1hZ2UoYmFubmVyLmltYWdlKTtcclxuICAgICAgLy8gYmFubmVyQ29udGFpbmVySW1nLnN0eWxlKHtcclxuICAgICAgLy8gICBiYWNrZ3JvdW5kOiBgdXJsKCR7YmFubmVyLmltYWdlfSlgLFxyXG4gICAgICAvLyAgICdiYWNrZ3JvdW5kLXNpemUnOiAnY29udGFpbicsXHJcbiAgICAgIC8vICAgJ2JhY2tncm91bmQtcmVwZWF0JzogJ25vLXJlcGVhdCcsXHJcbiAgICAgIC8vIH0pO1xyXG4gICAgICBjb25zdCB0ZXh0Q29udGFpbmVyID0gJEVMTS5jcmVhdGUoJ2Jhbm5lci1jb250YWluZXJfX3RleHQtY29udGFpbmVyJyk7XHJcbiAgICAgIGNvbnN0IHRpdGxlID0gJEVMTS5jcmVhdGUoJ2gxIHRleHQtY29udGFpbmVyX190aXRsZScpO1xyXG4gICAgICBjb25zdCByYXRpbmdzID0gJEVMTS5jcmVhdGUoJ3RleHQtY29udGFpbmVyX19yYXRpbmdzJyk7XHJcbiAgICAgIGNvbnN0IGRpZmZpY3VsdHkgPSAkRUxNLmNyZWF0ZSgnaDQgdGV4dC1jb250YWluZXJfX2RpZmZpY3VsdHknKTtcclxuICAgICAgY29uc3QgY291cG9uc1dyYXBwZXIgPSAkRUxNLmNyZWF0ZSgnY291cG9ucy1jb250YWluZXInKTtcclxuICAgICAgY29uc3Qgc2F2ZUJ1dHRvbiA9IHRoaXMuY3JlYXRlU2F2ZVJlY2lwZUNUQShiYW5uZXIpO1xyXG5cclxuICAgICAgcmF0aW5ncy5odG1sKFJhdGluZ3MoYmFubmVyLnN0YXJzKSk7XHJcbiAgICAgIHRpdGxlLnRleHQoYmFubmVyLnRpdGxlKTtcclxuICAgICAgZGlmZmljdWx0eS50ZXh0KGJhbm5lci5jb29rVGltZSk7XHJcblxyXG4gICAgICBiYW5uZXIuY291cG9ucy5mb3JFYWNoKChjb3Vwb24pID0+IHtcclxuICAgICAgICBjb3Vwb25zV3JhcHBlci5hcHBlbmQodGhpcy5hZGRDb3Vwb24oY291cG9uKSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdGV4dENvbnRhaW5lci5hcHBlbmRBbGwodGl0bGUsIHJhdGluZ3MsIGRpZmZpY3VsdHkpO1xyXG4gICAgICBiYW5uZXJDb250YWluZXIuYXBwZW5kQWxsKGJhbm5lckNvbnRhaW5lckltZywgdGV4dENvbnRhaW5lciwgc2F2ZUJ1dHRvbiwgY291cG9uc1dyYXBwZXIpO1xyXG4gICAgICByZXR1cm4gYmFubmVyQ29udGFpbmVyO1xyXG4gICAgfSxcclxuICAgIGFkZFN0eWxlKGVsZW1lbnQsIHN0bCkge1xyXG4gICAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHN0bCk7XHJcbiAgICB9LFxyXG4gICAgYWRkQmFubmVycygpIHtcclxuICAgICAgY29uc3QgaGVhZGVyID0gJEVMTS5nZXQoJy5oZWFkZXInKTtcclxuICAgICAgY29uc3QgdWwgPSAkRUxNLmNyZWF0ZSgndWwgY3JvLXNsaWRlcicpO1xyXG4gICAgICBoZWFkZXIuaHRtbCgnICcpO1xyXG4gICAgICBiYW5uZXJzLmZvckVhY2goKGJhbm5lcikgPT4ge1xyXG4gICAgICAgIHVsLmFwcGVuZCh0aGlzLmFkZEJhbm5lcihiYW5uZXIpKTtcclxuICAgICAgfSk7XHJcbiAgICAgIGhlYWRlci5hcHBlbmQodWwpO1xyXG4gICAgICAvLyBjb25zb2xlLmxvZyh1bC5jaGlsZHJlbignbGknKVswXS5oZWlnaHQoKSk7XHJcbiAgICAgIC8vIHVsLnN0eWxlKHtcclxuICAgICAgLy8gICB3aWR0aDogYCR7MTAwICogYmFubmVycy5sZW5ndGh9JWAsXHJcbiAgICAgIC8vICAgLy8gaGVpZ2h0OiBgJHt1bC5jaGlsZHJlbignbGknKVswXS5oZWlnaHQoKS50b1N0cmluZygpfXB4YCxcclxuICAgICAgLy8gfSk7XHJcbiAgICAgICQoJy5jcm8tc2xpZGVyJykuc2xpY2soe1xyXG4gICAgICAgIGFkYXB0aXZlSGVpZ2h0OiB0cnVlXHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIGFkZEljYUNhcmQoKSB7XHJcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG4gICAgICBjb25zdCBpY2FJbWFnZUNvbnRhaW5lciA9IHNlbGYuY3JlYXRlKCdpY2EtY2FyZC1jb250YWluZXInKTtcclxuICAgICAgc2VsZi5jcmVhdGUoJycsIGljYUltYWdlQ29udGFpbmVyLCAnRsOlIHJhYmF0dCBtZWQgSUNBLUtvcnQnLCAnaDEnKTtcclxuICAgICAgY29uc3QgdXNwcyA9IHNlbGYuY3JlYXRlKCd1c3AtbGlzdCcsIGljYUltYWdlQ29udGFpbmVyLCBudWxsLCAndWwnKTtcclxuICAgICAgdXNwcy5pbm5lckhUTUwgPSBgXHJcbiAgICAgIDxsaT48c3ZnIHZpZXdCb3g9XCIwIDAgMzIgMzJcIiB3aWR0aD1cIjE1cHhcIiBoZWlnaHQ9XCIxNXB4XCI+PHVzZSB4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiB4bGluazpocmVmPVwiL0Fzc2V0cy9pY29ucy9zcHJpdGUuc3ZnI2NoZWNrXCI+PC91c2U+PC9zdmc+IElDQS1rb3J0IG1lZCBib251czwvbGk+XHJcbiAgICAgIDxsaT48c3ZnIHZpZXdCb3g9XCIwIDAgMzIgMzJcIiB3aWR0aD1cIjE1cHhcIiBoZWlnaHQ9XCIxNXB4XCI+PHVzZSB4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiB4bGluazpocmVmPVwiL0Fzc2V0cy9pY29ucy9zcHJpdGUuc3ZnI2NoZWNrXCI+PC91c2U+PC9zdmc+IFBlcnNvbmxpZ2EgZXJianVkYW5kZW48L2xpPlxyXG4gICAgICA8bGk+PHN2ZyB2aWV3Qm94PVwiMCAwIDMyIDMyXCIgd2lkdGg9XCIxNXB4XCIgaGVpZ2h0PVwiMTVweFwiPjx1c2UgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgeGxpbms6aHJlZj1cIi9Bc3NldHMvaWNvbnMvc3ByaXRlLnN2ZyNjaGVja1wiPjwvdXNlPjwvc3ZnPiBLb3J0cHJpc2VyIHZhcmplIHZlY2thPC9saT5cclxuICAgICAgYDtcclxuICAgICAgc2VsZi5jcmVhdGUoJycsIGljYUltYWdlQ29udGFpbmVyLCAnaHR0cHM6Ly93d3cuaWNhLnNlL0ltYWdlVmF1bHRGaWxlcy9pZF83ODY0OS9jZl8zL0lDQV9Lb3J0X29jaF9CYW5rLnBuZycsICdpbWcnKTtcclxuICAgICAgc2VsZi5jcmVhdGUoJ2J1dHRvbicsIGljYUltYWdlQ29udGFpbmVyLCAnU2thcGEga29udG8gb2NoIGJsaSBtZWRsZW0nLCAnYScpXHJcbiAgICAgICAgLmhyZWYgPSAnL2Fuc29rYW4vP3N0ZXA9NjM2OTc2Njk2MzY2NmY3MjZkJztcclxuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm1haW4nKS5hcHBlbmRDaGlsZChpY2FJbWFnZUNvbnRhaW5lcik7XHJcbiAgICB9LFxyXG4gICAgZGlubmVyVG9uaWdodCgpIHtcclxuICAgICAgY29uc3QgY29udGFpbmVyID0gJEVMTS5nZXQoJy5zZWFyY2gtcmVjaXBlLWNvbnRhaW5lcicpO1xyXG4gICAgICBjb25zdCByZWNpcGVUcmVuZGluZ0xpc3QgPSAkRUxNLmdldCgnLnJlY2lwZS10cmVuZGluZy1saXN0Jyk7XHJcbiAgICAgIGNvbnN0IGltZyA9ICRFTE0uY3JlYXRlKCdpbWcnKS5pbWFnZSgnL2ltYWdldmF1bHRmaWxlcy9pZF8xMjQzMDAvY2ZfMjU5L255dHRpZ2FfcmVjZXB0LmpwZycpO1xyXG4gICAgICBjb25zdCBzZWVBbGwgPSAkRUxNLmNvcHkoJy5zZWFyY2gtcmVjaXBlLWNvbnRhaW5lcl9fYWxsLXJlY2lwZXMnKTtcclxuICAgICAgdGhpcy5yZW1vdmVFbGVtZW50cyhbJy5zZWFyY2gtcmVjaXBlLWNvbnRhaW5lcl9fYWxsLXJlY2lwZXMnXSk7XHJcbiAgICAgIHJlY2lwZVRyZW5kaW5nTGlzdC5hcHBlbmQoc2VlQWxsKTtcclxuICAgICAgY29udGFpbmVyLmFwcGVuZEZpcnN0KGltZyk7XHJcbiAgICAgIGNvbnRhaW5lci5nZXQoJ2gxJykudGV4dCgnVmFkIGJsaXIgZGV0IGbDtnIgbWlkZGFnIGlrdsOkbGw/Jyk7XHJcbiAgICB9LFxyXG4gICAgbWFuaXB1bGF0ZURvbSgpIHtcclxuICAgICAgdGhpcy5yZW1vdmVFbGVtZW50cyhbXHJcbiAgICAgICAgJy5pbWFnZS1zbGlkZXIgbGknLFxyXG4gICAgICAgICcuaW1hZ2Utc2xpZGVyIC5sYXp5LXNwaW5uZXInLFxyXG4gICAgICAgICcuaGVhZGVyLWNvbnRlbnQnLFxyXG4gICAgICAgICcucHVzaC1pdGVtcy1saXN0JyxcclxuICAgICAgICAnLnF1aWNrbGluay1saXN0JyxcclxuICAgICAgICAnLm1haW4gLmxpbmstbGlzdCcsXHJcbiAgICAgICAgJy5yZWNpcGUtY2F0ZWdvcnktbGlzdGluZyAuYmFubmVyLWltYWdlJyxcclxuICAgICAgICAnLnJlY2lwZS1jYXRlZ29yeS1saXN0aW5nID4gLmNvbC0xMiA+IGgyJyxcclxuICAgICAgICAnLnNlYXJjaC1yZWNpcGUtY29udGFpbmVyX19yZWNpcGUtY291bnQnLFxyXG4gICAgICAgICcucmVjaXBlLWNhdGVnb3J5LWxpc3RpbmcgLnJlY2lwZS1saXN0LWl0ZW1zJyxcclxuICAgICAgXSk7XHJcbiAgICAgIHRoaXMuYWRkQmFubmVycygpO1xyXG4gICAgICB0aGlzLmNyZWF0ZU9mZmVycygpO1xyXG4gICAgICB0aGlzLmFkZEljYUNhcmQoKTtcclxuICAgICAgdGhpcy5kaW5uZXJUb25pZ2h0KCk7XHJcbiAgICAgIGNvbnN0IHJldHVyblVybCA9IGVuY29kZVVSSUNvbXBvbmVudCh3aW5kb3cubG9jYXRpb24uaHJlZik7XHJcbiAgICAgIGNvbnN0IGlmcmFtZUNvbnRhaW5lciA9ICQoYDxkaXYgY2xhc3M9XCJjcm8taWZyYW1lLWNvbnRhaW5lclwiPjxzcGFuIGNsYXNzPVwibG9hZGVyXCI+PC9zcGFuPjxpZnJhbWUgc3JjPVwiLy93d3cuaWNhLnNlL2xvZ2dhLWluLz9yZXR1cm51cmw9JHtyZXR1cm5Vcmx9XCIgZnJhbWVib3JkZXI9XCIwXCI+PC9pZnJhbWU+PC9kaXY+YCk7XHJcbiAgICAgICQoJ2JvZHknKS5hcHBlbmQoaWZyYW1lQ29udGFpbmVyKTtcclxuICAgIH0sXHJcbiAgICBjcmVhdGVTYXZlUmVjaXBlQ1RBKGJhbm5lcikge1xyXG4gICAgICBjb25zdCBjb250YWluZXIgPSAkRUxNLmNyZWF0ZSgnYnV0dG9uLXdyYXBwZXInKTtcclxuICAgICAgY29uc3QgY3RhID0gJEVMTS5jcmVhdGUoJ2EgLmJ1dHRvbiBiYW5uZXItYnV0dG9uJyk7XHJcbiAgICAgIGN0YS50ZXh0KCdMw6RnZyByZWNlcHQgaSBpbmvDtnBzbGlzdGFuJyk7XHJcbiAgICAgIGN0YS5ocmVmKGAvbG9nZ2EtaW4vP3JldHVyblVybD0ke2VuY29kZVVSSUNvbXBvbmVudCh3aW5kb3cubG9jYXRpb24pfWApO1xyXG4gICAgICBjdGEuZGF0YSgncmVjaXBlSWQnLCBiYW5uZXIucmVjaXBlSWQpO1xyXG4gICAgICBjdGEuZGF0YSgndHJhY2tpbmcnLCBgeyBcIm5hbWVcIjogXCIke2Jhbm5lci50aXRsZX1cIiwgXCJVUkxcIjogXCIke2Jhbm5lci51cmx9XCIgfWApO1xyXG4gICAgICBjdGEuY3NzKGBqcy1hZGQtdG8tbmV3LXNob3BwaW5nbGlzdCBiYW5uZXItYnV0dG9uLSR7YmFubmVyLnJlY2lwZUlkfWApO1xyXG5cclxuICAgICAgY29uc3Qgc2F2ZWRSZWNpcGVzID0gdGhpcy5nZXRTYXZlZFJlY2lwZXMoKTtcclxuICAgICAgaWYgKHNhdmVkUmVjaXBlcy5pbmNsdWRlcyhiYW5uZXIucmVjaXBlSWQpKSB7XHJcbiAgICAgICAgY3RhLmNzcygnc2F2ZWQnKTtcclxuICAgICAgICBjdGEudGV4dCgnUmVjZXB0IHRpbGxhZ3QgaSBpbmvDtnBzbGlzdGFuJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGN0YS5jbGljaygoZSkgPT4ge1xyXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICBpZiAodGhpcy5pc0xvZ2dlZEluKCkpIHtcclxuICAgICAgICAgIHRoaXMuYWRkUmVjaXBlVG9TaG9wcGluZ0xpc3QoYmFubmVyLnJlY2lwZUlkKTtcclxuICAgICAgICAgIHRoaXMuc2F2ZVJlY2lwZShiYW5uZXIucmVjaXBlSWQpO1xyXG4gICAgICAgICAgdGhpcy5hZGRSZWNpcGVUb1NhdmVkTGlzdChiYW5uZXIucmVjaXBlSWQpO1xyXG4gICAgICAgICAgY3RhLmNzcygnc2F2ZWQnKTtcclxuICAgICAgICAgIGN0YS50ZXh0KCdSZWNlcHQgdGlsbGFndCBpIGlua8O2cHNsaXN0YW4nKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5zZXRBY3Rpb25Db29raWUoQUNUSU9OX0NPT0tJRVMuU0FWRV9SRUNJUEUsIGJhbm5lci5yZWNpcGVJZCk7XHJcbiAgICAgICAgICB0aGlzLmNyZWF0ZU1vZGFsKExPR0lOX0FDVElPTi5TQVZFX1JFQ0lQRSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgY29udGFpbmVyLmFwcGVuZChjdGEpO1xyXG4gICAgICByZXR1cm4gY29udGFpbmVyO1xyXG4gICAgfSxcclxuICAgIGNyZWF0ZU9mZmVycygpIHtcclxuICAgICAgY29uc3QgbWFpbiA9ICRFTE0uZ2V0KCcubWFpbicpO1xyXG4gICAgICBjb25zdCBjb250YWluZXIgPSAkRUxNLmNyZWF0ZSgnZGl2IGNvdXBvbi1iYW5uZXInKTtcclxuICAgICAgY29uc3Qgb2ZmZXJCdXR0b24gPSAkRUxNLmNyZWF0ZSgnYSAuYnV0dG9uIG9mZmVycy1idXR0b24nKS50ZXh0KCdHw6UgdGlsbCBJQ0FzIGt1cG9uZ2VyJykuaHJlZignL2VyYmp1ZGFuZGVuL2J1dGlrc2VyYmp1ZGFuZGVuL2FsbGEtZGlnaXRhbGEta3Vwb25nZXIvJyk7XHJcbiAgICAgIGNvbnN0IGltZyA9ICRFTE0uY3JlYXRlKCdpbWcnKS5pbWFnZSgnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0JhbnphY2kvaWNhL21hc3Rlci9zcmMvc3RhcnQtcGFnZS9Db3Vwb25zX2ltYWdlLnBuZycpO1xyXG4gICAgICBjb250YWluZXIuYXBwZW5kQWxsKGltZywgb2ZmZXJCdXR0b24pO1xyXG4gICAgICBtYWluLmFwcGVuZChjb250YWluZXIpO1xyXG4gICAgfSxcclxuICAgIGFkZFJlY2lwZVRvU2hvcHBpbmdMaXN0KHJlY2lwZUlkKSB7XHJcbiAgICAgIC8vIHRyYWNraW5nIHNrZXIgdmlhIGtsYXNzbmFtblxyXG5cclxuICAgICAgSUNBLmFqYXgucG9zdCgnL1RlbXBsYXRlcy9SZWNpcGVzL0hhbmRsZXJzL1Nob3BwaW5nTGlzdEhhbmRsZXIuYXNoeCcsIHtcclxuICAgICAgICByZWNpcGVJZHM6IFtyZWNpcGVJZF0sXHJcbiAgICAgICAgU2hvcHBpbmdMaXN0SWQ6IDAsXHJcbiAgICAgICAgbnVtYmVyT2ZTZXJ2aW5nczogMCxcclxuICAgICAgICByZWNpcGVzOiBbXSxcclxuICAgICAgICBzaG9wcGluZ0xpc3ROYW1lOiBjcmVhdGVTaG9wcGluZ3NMaXN0TmFtZSgpLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZVNob3BwaW5nc0xpc3ROYW1lKCkge1xyXG4gICAgICAgIGNvbnN0IGQgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgIGNvbnN0IHllYXIgPSBkLmdldEZ1bGxZZWFyKCk7XHJcbiAgICAgICAgY29uc3QgbW9udGggPSBkLmdldE1vbnRoKCk7XHJcbiAgICAgICAgY29uc3QgZGF5ID0gZC5nZXREYXRlKCk7XHJcbiAgICAgICAgY29uc3QgbW9udGhzID0geyAxMDogJ25vdicsIDExOiAnZGVjJyB9OyAvLyB0ZXN0ZXQga29tbWVyIGVuZGFzdCBsaWdnYSB1dGUgaSBub3YsIHNlbmFzdCBkZWNcclxuXHJcbiAgICAgICAgcmV0dXJuIGBBdHQgaGFuZGxhLCAke2RheX0gJHttb250aHNbbW9udGhdfSAke3llYXJ9YDtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIHNhdmVSZWNpcGUocmVjaXBlSWQpIHtcclxuICAgICAgY29uc3QgYmFubmVyID0gYmFubmVycy5maWx0ZXIoYiA9PiBiLnJlY2lwZUlkID09PSByZWNpcGVJZClbMF07XHJcblxyXG4gICAgICBkYXRhTGF5ZXIucHVzaCh7XHJcbiAgICAgICAgZXZlbnQ6ICdyZWNpcGUtc2F2ZScsXHJcbiAgICAgICAgbmFtZTogYmFubmVyLnRpdGxlLFxyXG4gICAgICAgIFVSTDogYmFubmVyLnVybCxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBJQ0EuYWpheC5nZXQoJy9UZW1wbGF0ZXMvUmVjaXBlcy9IYW5kbGVycy9GYXZvcml0ZVJlY2lwZXNIYW5kbGVyLmFzaHgnLCB7XHJcbiAgICAgICAgcmVjaXBlSWQsXHJcbiAgICAgICAgbWV0aG9kOiAnQWRkJyxcclxuICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgc2V0QWN0aW9uQ29va2llKGNvb2tpZU5hbWUsIGNvb2tpZURhdGEpIHtcclxuICAgICAgLy8gVE9ETzogRmx5dHRhIHRpbGwgbWFpbi5qc1xyXG4gICAgICBjb25zdCBkID0gbmV3IERhdGUoKTtcclxuICAgICAgZC5zZXREYXRlKG5ldyBEYXRlKCkuZ2V0RGF0ZSgpICsgMSk7IC8vIGV4cGlyZXMgdG9tb3Jyb3dcclxuXHJcbiAgICAgIElDQS5sZWdhY3kuc2V0Q29va2llKGNvb2tpZU5hbWUsIEpTT04uc3RyaW5naWZ5KGNvb2tpZURhdGEpLCBkKTtcclxuICAgIH0sXHJcbiAgICBnZXRBY3Rpb25Db29raWUoY29va2llTmFtZSkge1xyXG4gICAgICAvLyBUT0RPOiBGbHl0dGEgdGlsbCBtYWluLmpzXHJcbiAgICAgIGNvbnN0IGFjdGlvbkNvb2tpZSA9IElDQS5sZWdhY3kuZ2V0Q29va2llKGNvb2tpZU5hbWUpO1xyXG5cclxuICAgICAgaWYgKCFhY3Rpb25Db29raWUpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgSUNBLmxlZ2FjeS5raWxsQ29va2llKGNvb2tpZU5hbWUpO1xyXG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShhY3Rpb25Db29raWUpO1xyXG4gICAgfSxcclxuICAgIGNoZWNrQWN0aW9uQ29va2llcygpIHtcclxuICAgICAgaWYgKCF0aGlzLmlzTG9nZ2VkSW4pIHJldHVybjtcclxuXHJcbiAgICAgIGNvbnN0IHJlY2lwZUlkID0gdGhpcy5nZXRBY3Rpb25Db29raWUoQUNUSU9OX0NPT0tJRVMuU0FWRV9SRUNJUEUpO1xyXG4gICAgICBpZiAocmVjaXBlSWQpIHtcclxuICAgICAgICB0aGlzLmFkZFJlY2lwZVRvU2hvcHBpbmdMaXN0KHJlY2lwZUlkKTtcclxuICAgICAgICB0aGlzLnNhdmVSZWNpcGUocmVjaXBlSWQpO1xyXG4gICAgICAgIHRoaXMuYWRkUmVjaXBlVG9TYXZlZExpc3QocmVjaXBlSWQpO1xyXG4gICAgICAgIGNvbnN0IGN0YSA9ICRFTE0uZ2V0KGBiYW5uZXItYnV0dG9uLSR7cmVjaXBlSWR9YCk7XHJcbiAgICAgICAgY3RhLmNzcygnc2F2ZWQnKTtcclxuICAgICAgICBjdGEudGV4dCgnUmVjZXB0IHRpbGxhZ3QgaSBpbmvDtnBzbGlzdGFuJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGNvdXBvbiA9IHRoaXMuZ2V0QWN0aW9uQ29va2llKEFDVElPTl9DT09LSUVTLkxPQURfQ09VUE9OKTtcclxuICAgICAgaWYgKGNvdXBvbikge1xyXG4gICAgICAgIHRoaXMubG9hZENvdXBvbk9uQ2FyZChjb3Vwb24pLnRoZW4oKHJlc3BvbnNlKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLmNoYW5nZU9mZmVyU3RhdHVzKHJlc3BvbnNlLCBjb3Vwb24pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgYWRkUmVjaXBlVG9TYXZlZExpc3QocmVjaXBlSWQpIHtcclxuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcbiAgICAgIGNvbnN0IGQgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICBkLnNldERhdGUobmV3IERhdGUoKS5nZXREYXRlKCkgKyAxKTsgLy8gZXhwaXJlcyB0b21vcnJvd1xyXG5cclxuICAgICAgY29uc3Qgc2F2ZWRSZWNpcGVzID0gc2VsZi5nZXRTYXZlZFJlY2lwZXMoKTtcclxuXHJcbiAgICAgIHNhdmVkUmVjaXBlcy5wdXNoKHJlY2lwZUlkKTtcclxuXHJcbiAgICAgIElDQS5sZWdhY3kuc2V0Q29va2llKCdjcm9fc3RhcnRfc2F2ZWRSZWNpcGVzJywgSlNPTi5zdHJpbmdpZnkoc2F2ZWRSZWNpcGVzKSwgZCk7XHJcbiAgICB9LFxyXG4gICAgZ2V0U2F2ZWRSZWNpcGVzKCkge1xyXG4gICAgICBjb25zdCBjb29raWUgPSBJQ0EubGVnYWN5LmdldENvb2tpZSgnY3JvX3N0YXJ0X3NhdmVkUmVjaXBlcycpO1xyXG4gICAgICByZXR1cm4gY29va2llID8gSlNPTi5wYXJzZShjb29raWUpIDogW107XHJcbiAgICB9LFxyXG4gICAgY2hhbmdlT2ZmZXJTdGF0dXMocmVzcG9uc2UsIGNvdXBvbikge1xyXG4gICAgICBpZiAocmVzcG9uc2Uub2spIHtcclxuICAgICAgICAkRUxNLmdldChgI2NvdXBvbi0ke2NvdXBvbi5PZmZlcklkfS0ke2NvdXBvbi5yZWNpcGVJZH1gKS5jc3MoJ29mZmVyLWxvYWRlZCcpO1xyXG4gICAgICAgICRFTE0uZ2V0KGAjY291cG9uLSR7Y291cG9uLk9mZmVySWR9LSR7Y291cG9uLnJlY2lwZUlkfSAuY291cG9uLWJ1dHRvbmApLnRleHQoJ0t1cG9uZyBsYWRkYWQnKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIC8vIGhvdGphclRyaWdnZXJlZDogZmFsc2UsXHJcbiAgICBsb2FkZXJJc0FjdGl2ZTogZmFsc2UsXHJcbiAgICBidXR0b25IYW5kbGVyUG9sbFRpbWVvdXQ6IG51bGwsXHJcbiAgICBzaG93TG9hZGVyKCkge1xyXG4gICAgICBjb25zdCBjb250YWluZXIgPSAkKCcuY3JvLWlmcmFtZS1jb250YWluZXInKTtcclxuICAgICAgY29udGFpbmVyLmZpbmQoJy5sb2FkZXInKS5zaG93KCk7XHJcbiAgICAgIGNvbnRhaW5lci5maW5kKCdpZnJhbWUnKS5jc3MoJ29wYWNpdHknLCAnMCcpO1xyXG4gICAgICB0aGlzLmxvYWRlcklzQWN0aXZlID0gdHJ1ZTtcclxuICAgIH0sXHJcbiAgICBoaWRlTG9hZGVyKCkge1xyXG4gICAgICBjb25zdCBjb250YWluZXIgPSAkKCcuY3JvLWlmcmFtZS1jb250YWluZXInKTtcclxuICAgICAgY29udGFpbmVyLmZpbmQoJy5sb2FkZXInKS5oaWRlKCk7XHJcbiAgICAgIGNvbnRhaW5lci5maW5kKCdpZnJhbWUnKS5jc3MoJ29wYWNpdHknLCAnMScpO1xyXG4gICAgICB0aGlzLmxvYWRlcklzQWN0aXZlID0gZmFsc2U7XHJcbiAgICB9LFxyXG4gICAgYWRkQnV0dG9uSGFuZGxlclBvbGwoKSB7XHJcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG4gICAgICBjb25zdCBpZnJhbWUgPSAkKCcuY3JvLWlmcmFtZS1jb250YWluZXIgaWZyYW1lJyk7XHJcbiAgICAgIGNvbnN0IGUgPSBpZnJhbWUuY29udGVudHMoKS5maW5kKCcucmVtb2RhbC13cmFwcGVyICNncmV5LWNhcmQtYnRuLCAucmVtb2RhbC13cmFwcGVyIC5waW5rLWNhcmQtYnRuJyk7XHJcblxyXG4gICAgICBpZiAoZS5sZW5ndGgpIHtcclxuICAgICAgICBlLmNsaWNrKCgpID0+IHtcclxuICAgICAgICAgIHNlbGYuc2hvd0xvYWRlcigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoc2VsZi5idXR0b25IYW5kbGVyUG9sbFRpbWVvdXQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNlbGYuYnV0dG9uSGFuZGxlclBvbGxUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoXHJcbiAgICAgICAgICBzZWxmLmFkZEJ1dHRvbkhhbmRsZXJQb2xsLmJpbmQoc2VsZiksXHJcbiAgICAgICAgICAxMDAwLFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBhZGRFdmVudExpc3RlbmVycygpIHtcclxuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAkKCcuaGVhZGVyJykub2ZmKCdtb3VzZWRvd24nKTtcclxuXHJcbiAgICAgICQod2luZG93KS5vbignbWVzc2FnZSBvbm1lc3NhZ2UnLCAoZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IG9yaWdpbiA9IGAke3dpbmRvdy5sb2NhdGlvbi5wcm90b2NvbH0vLyR7d2luZG93LmxvY2F0aW9uLmhvc3R9YDtcclxuICAgICAgICBpZiAoZS5vcmlnaW5hbEV2ZW50Lm9yaWdpbiA9PT0gb3JpZ2luICYmIC9tb2JpbGViYW5raWQvaS50ZXN0KGUub3JpZ2luYWxFdmVudC5kYXRhKSkge1xyXG4gICAgICAgICAgc2VsZi5zaG93TG9hZGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH0sXHJcbiAgICBnZXRJZnJhbWVTdHlsZXMoKSB7XHJcbiAgICAgIHJldHVybiBgPHN0eWxlIHR5cGU9XCJ0ZXh0L2Nzc1wiPlxyXG4gICAgICAgIEBtZWRpYSAgKG1heC13aWR0aDogNzY3cHgpIHtcclxuICAgICAgICBoMy5ncmVldGluZywgaDMuY2FyZC1oZWFkaW5nIHsgZm9udC1zaXplOiAxOHB4OyB9XHJcbiAgICAgICAgaW1nLmNhcmQtaWNvbiB7IHdpZHRoOiA1MHB4OyB9XHJcbiAgICAgICAgLnNlbGVjdC1jYXJkLW1vZGFsIHsgYm9yZGVyOiAwOyBwYWRkaW5nOiAwOyBtYXJnaW46IDA7IH1cclxuICAgICAgICAucmVtb2RhbC13cmFwcGVyIHsgcGFkZGluZzogMDsgfVxyXG4gICAgICAgIH1cclxuICAgICAgICA8L3N0eWxlPmA7XHJcbiAgICB9LFxyXG4gICAgY3JlYXRlTW9kYWwoYWN0aW9uID0gTE9HSU5fQUNUSU9OLlNBVkVfUkVDSVBFKSB7XHJcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG4gICAgICBjb25zdCBtb2RhbCA9IG5ldyBjb3JlQ29tcG9uZW50cy5tb2RhbCh7XHJcbiAgICAgICAgdHBsOiAkKCcuY3JvLWlmcmFtZS1jb250YWluZXInKS5nZXQoMCksXHJcbiAgICAgICAgc2l6ZTogJ21kJyxcclxuICAgICAgICBjb250YWluZXI6ICQoJy5tb2RhbC1jb250YWluZXInKS5nZXQoMCksXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgc2VsZi5zaG93TG9hZGVyKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGlmcmFtZSA9ICQoJy5jcm8taWZyYW1lLWNvbnRhaW5lciBpZnJhbWUnKTtcclxuXHJcbiAgICAgICAgaWZyYW1lLm9uKCdsb2FkJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKGBeJHt3aW5kb3cubG9jYXRpb24uaHJlZn0kYCwgJ2dpJyk7XHJcbiAgICAgICAgICBpZiAocmVnZXgudGVzdCh0aGlzLmNvbnRlbnRXaW5kb3cubG9jYXRpb24pKSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQodHJ1ZSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKHRoaXMuY29udGVudFdpbmRvdy5sb2NhdGlvbi5ocmVmLmluZGV4T2YoJ2xvZ2dhLWluJykgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIGxldCBoZWFkZXJCYXJUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoaGlkZUhlYWRlckJhciwgMTApO1xyXG4gICAgICAgICAgICBsZXQgYXBwZW5kSGVhZGVyVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGFwcGVuZEhlYWRlciwgMTApO1xyXG4gICAgICAgICAgICBsZXQgYWRkU3R5bGVzVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGFkZFN0eWxlcywgMTApO1xyXG4gICAgICAgICAgICBsZXQgYWRkSWZyYW1lVHJhY2tpbmdUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoYWRkSWZyYW1lVHJhY2tpbmcsIDEwKTtcclxuICAgICAgICAgICAgY29uc3QgaGlkZUhlYWRlckJhckRlZmVycmVkID0gJC5EZWZlcnJlZCgpO1xyXG4gICAgICAgICAgICBjb25zdCBhcHBlbmRIZWFkZXJEZWZlcnJlZCA9ICQuRGVmZXJyZWQoKTtcclxuICAgICAgICAgICAgY29uc3QgYWRkU3R5bGVzRGVmZXJyZWQgPSAkLkRlZmVycmVkKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGFkZElmcmFtZVRyYWNraW5nRGVmZXJyZWQgPSAkLkRlZmVycmVkKCk7XHJcblxyXG4gICAgICAgICAgICAkLndoZW4oXHJcbiAgICAgICAgICAgICAgaGlkZUhlYWRlckJhckRlZmVycmVkLFxyXG4gICAgICAgICAgICAgIGFwcGVuZEhlYWRlckRlZmVycmVkLFxyXG4gICAgICAgICAgICAgIGFkZFN0eWxlc0RlZmVycmVkLFxyXG4gICAgICAgICAgICAgIGFkZElmcmFtZVRyYWNraW5nRGVmZXJyZWQsXHJcbiAgICAgICAgICAgICkuZG9uZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgc2VsZi5oaWRlTG9hZGVyKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gaGlkZUhlYWRlckJhcigpIHtcclxuICAgICAgICAgICAgICBjb25zdCBlID0gJCgnLmNyby1pZnJhbWUtY29udGFpbmVyIGlmcmFtZScpLmNvbnRlbnRzKCkuZmluZCgnLmhlYWRlci1iYXInKTtcclxuICAgICAgICAgICAgICBpZiAoZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGUuaGlkZSgpO1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChoZWFkZXJCYXJUaW1lb3V0KTtcclxuICAgICAgICAgICAgICAgIGhpZGVIZWFkZXJCYXJEZWZlcnJlZC5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGhlYWRlckJhclRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChoaWRlSGVhZGVyQmFyLCAwKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGFwcGVuZEhlYWRlcigpIHtcclxuICAgICAgICAgICAgICBjb25zdCBlID0gJCgnLmNyby1pZnJhbWUtY29udGFpbmVyIGlmcmFtZScpLmNvbnRlbnRzKCkuZmluZCgnaDEnKTtcclxuICAgICAgICAgICAgICBpZiAoZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAoYWN0aW9uID09PSBMT0dJTl9BQ1RJT04uU0FWRV9SRUNJUEUpXHJcbiAgICAgICAgICAgICAgICAgID8gJyBmw7ZyIGF0dCBsw6RnZ2EgdGlsbCBpIGlua8O2cHNsaXN0YW4gb2NoIHNwYXJhIHJlY2VwdCdcclxuICAgICAgICAgICAgICAgICAgOiAnIGbDtnIgYXR0IGxhZGRhIGt1cG9uZ2VuJztcclxuICAgICAgICAgICAgICAgIGUuYXBwZW5kKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgZS5jc3MoeyAnZm9udC1mYW1pbHknOiAnaWNhaGFuZCwgYXJpYWwsIHNhbnMtc2VyaWYnLCAnZm9udC1zaXplJzogJzNyZW0nIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuc2NyZWVuLndpZHRoIDwgNzY4KSB7XHJcbiAgICAgICAgICAgICAgICAgIGUuY3NzKCdmb250LXNpemUnLCAnMThweCcpO1xyXG4gICAgICAgICAgICAgICAgICBlLnBhcmVudCgpLmNzcygnbWFyZ2luJywgJzAnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoYXBwZW5kSGVhZGVyVGltZW91dCk7XHJcbiAgICAgICAgICAgICAgICBhcHBlbmRIZWFkZXJEZWZlcnJlZC5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGFwcGVuZEhlYWRlclRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChhcHBlbmRIZWFkZXIsIDApO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gYWRkU3R5bGVzKCkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IGUgPSAkKCcuY3JvLWlmcmFtZS1jb250YWluZXIgaWZyYW1lJykuY29udGVudHMoKS5maW5kKCdib2R5Jyk7XHJcbiAgICAgICAgICAgICAgaWYgKGUubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBlLmFwcGVuZChzZWxmLmdldElmcmFtZVN0eWxlcygpKTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoYWRkU3R5bGVzVGltZW91dCk7XHJcbiAgICAgICAgICAgICAgICBhZGRTdHlsZXNEZWZlcnJlZC5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGFkZFN0eWxlc1RpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChhZGRTdHlsZXMsIDApO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gYWRkSWZyYW1lVHJhY2tpbmcoKSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgZSA9ICQoJy5jcm8taWZyYW1lLWNvbnRhaW5lciBpZnJhbWUnKS5jb250ZW50cygpO1xyXG4gICAgICAgICAgICAgIGlmIChlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnRBY3Rpb24gPSAoYWN0aW9uID09PSBMT0dJTl9BQ1RJT04uU0FWRV9SRUNJUEUpXHJcbiAgICAgICAgICAgICAgICAgID8gJ1NwYXJhIHJlY2VwdCBmcsOlbiBzdGFydHNpZGFuJ1xyXG4gICAgICAgICAgICAgICAgICA6ICdMYWRkYSBrdXBvbmcgZnLDpW4gc3RhcnRzaWRhJztcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGb3J0c8OkdHQgKE1vYmlsdCBCYW5rSWQpXHJcbiAgICAgICAgICAgICAgICBlLmZpbmQoJyNzdWJtaXQtbG9naW4tbW9iaWxlLWJhbmstaWQnKS5vbignY2xpY2snLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgIGdhKCdzZW5kJywgJ2V2ZW50JywgJ0EvQicsIGV2ZW50QWN0aW9uLCAnTG9nZ2EgaW4gLSBNb2JpbHQgQmFua0lkJyk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBCZWjDtnZlciBkdSBoasOkbHAgKE1vYmlsdCBCYW5rSWQpXHJcbiAgICAgICAgICAgICAgICBlLmZpbmQoJy5sb2dpbi1zdXBwb3J0LWJhbmstaWQtbGluaycpLm9uKCdjbGljaycsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgZ2EoJ3NlbmQnLCAnZXZlbnQnLCAnQS9CJywgZXZlbnRBY3Rpb24sICdCZWjDtnZlciBkdSBoasOkbHAnKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNrYXBhIGtvbnRvIChNb2JpbHQgQmFua0lkKVxyXG4gICAgICAgICAgICAgICAgZS5maW5kKCcuZ2V0LW1vYmlsZS1iYW5rLWlkLWxpbmsnKS5vbignY2xpY2snLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgIGdhKCdzZW5kJywgJ2V2ZW50JywgJ0EvQicsIGV2ZW50QWN0aW9uLCAnU2thcGEga29udG8gLSBNb2JpbHQgQmFua0lkJyk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBMb2dnYSBpbiAoTMO2c2Vub3JkKVxyXG4gICAgICAgICAgICAgICAgZS5maW5kKCcjbG9nLWluLXN1Ym1pdCcpLm9uKCdjbGljaycsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgZ2EoJ3NlbmQnLCAnZXZlbnQnLCAnQS9CJywgZXZlbnRBY3Rpb24sICdMb2dnYSBpbiAtIEzDtnNlbm9yZCcpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gR2zDtm10IGzDtnNlbm9yZCAoTMO2c2Vub3JkKVxyXG4gICAgICAgICAgICAgICAgZS5maW5kKCcubG9naW4tc3VwcG9ydC1wYXNzd29yZC1saW5rJykub24oJ2NsaWNrJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICBnYSgnc2VuZCcsICdldmVudCcsICdBL0InLCBldmVudEFjdGlvbiwgJ0dsw7ZtdCBsw7ZzZW5vcmQnKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNrYXBhIGtvbnRvIChMw7ZzZW5vcmQpXHJcbiAgICAgICAgICAgICAgICBlLmZpbmQoJy5jcmVhdGUtYWNjb3VudC1saW5rJykub24oJ2NsaWNrJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICBnYSgnc2VuZCcsICdldmVudCcsICdBL0InLCBldmVudEFjdGlvbiwgJ1NrYXBhIGtvbnRvIC0gTMO2c2Vub3JkJyk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGFkZElmcmFtZVRyYWNraW5nVGltZW91dCk7XHJcbiAgICAgICAgICAgICAgICBhZGRJZnJhbWVUcmFja2luZ0RlZmVycmVkLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYWRkSWZyYW1lVHJhY2tpbmdUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoYWRkSWZyYW1lVHJhY2tpbmcsIDApO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICQoJy5jcm8taWZyYW1lLWNvbnRhaW5lciBpZnJhbWUnKS5jb250ZW50cygpLmZpbmQoJ2Zvcm0nKS5vbignc3VibWl0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoISQodGhpcykuZmluZCgnaW5wdXQuZXJyb3InKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICBzZWxmLnNob3dMb2FkZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgJCgnLmNyby1pZnJhbWUtY29udGFpbmVyIGlmcmFtZScpLmNvbnRlbnRzKCkuZmluZCgnI3N1Ym1pdC1sb2dpbi1tb2JpbGUtYmFuay1pZCcpLm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCEkKHRoaXMpLmZpbmQoJ2lucHV0LmVycm9yJykubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgc2VsZi5idXR0b25IYW5kbGVyUG9sbFRpbWVvdXQgPSBzZXRUaW1lb3V0KFxyXG4gICAgICAgICAgICAgICAgc2VsZi5hZGRCdXR0b25IYW5kbGVyUG9sbC5iaW5kKHNlbGYpLFxyXG4gICAgICAgICAgICAgICAgMTAwMCxcclxuICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAkKCcuY3JvLWlmcmFtZS1jb250YWluZXIgaWZyYW1lJykuY29udGVudHMoKS5maW5kKCdhW2hyZWYqPVwid3d3LmljYS5zZVwiXScpLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAkKHRoaXMpLmF0dHIoJ2hyZWYnLCAkKHRoaXMpLmF0dHIoJ2hyZWYnKS5yZXBsYWNlKCdodHRwOi8vJywgJ2h0dHBzOi8vJykpO1xyXG4gICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmNsaWNrKGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSAkKHRoaXMpLmF0dHIoJ2hyZWYnKTtcclxuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyB0cmlnZ2EgaG90amFyIGhlYXRtYXAgZsO2cnN0YSBnw6VuZ2VuIG1vZGFsZW4gw7ZwcG5hdHNcclxuICAgICAgICAvLyBpZiAodHlwZW9mIGhqID09PSAnZnVuY3Rpb24nICYmICFzZWxmLmhvdGphclRyaWdnZXJlZCkge1xyXG4gICAgICAgIC8vICAgICBoaigndHJpZ2dlcicsICd2YXJpYW50Jyk7XHJcbiAgICAgICAgLy8gICAgIHNlbGYuaG90amFyVHJpZ2dlcmVkID0gdHJ1ZTtcclxuICAgICAgICAvLyB9XHJcbiAgICAgIH0sIDUwKTtcclxuICAgIH0sXHJcbiAgICBsb2FkQ291cG9uRGF0YShjb3Vwb24pIHtcclxuICAgICAgcmV0dXJuIGxvYWRlZENvdXBvbnNbY291cG9uLk9mZmVySWRdXHJcbiAgICAgICAgPyBQcm9taXNlLnJlc29sdmUobG9hZGVkQ291cG9uc1tjb3Vwb24uT2ZmZXJJZF0pXHJcbiAgICAgICAgOiB3aW5kb3cuZmV0Y2goYC9hcGkvanNvbmhzZS8ke2NvdXBvbi5pZH1gLCB7IGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nIH0pXHJcbiAgICAgICAgICAudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5qc29uKCkpXHJcbiAgICAgICAgICAudGhlbigoanNvbikgPT4ge1xyXG4gICAgICAgICAgICBsb2FkZWRDb3Vwb25zW2NvdXBvbi5PZmZlcklkXSA9IGpzb247XHJcbiAgICAgICAgICAgIHJldHVybiBqc29uO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgbG9hZENvdXBvbk9uQ2FyZChjb3Vwb24pIHtcclxuICAgICAgY29uc3Qgb3B0cyA9IHtcclxuICAgICAgICBPZmZlcklkOiBjb3Vwb24uT2ZmZXJJZCxcclxuICAgICAgICBDYW1wYWlnbklkOiBjb3Vwb24uQ2FtcGFpZ25JZCxcclxuICAgICAgICBTdG9yZUlkOiAwLFxyXG4gICAgICAgIFN0b3JlR3JvdXBJZDogMCxcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHJldHVybiB3aW5kb3cuZmV0Y2goXHJcbiAgICAgICAgJy9hcGkvanNvbmhzZS9DbGFpbW9mZmVyJyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyxcclxuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShvcHRzKSxcclxuICAgICAgICB9LFxyXG4gICAgICApLnRoZW4oKHJlc3BvbnNlKSA9PiB7XHJcbiAgICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgICBpY2FkYXRhbGF5ZXIuYWRkKCdIU0UnLCB7XHJcbiAgICAgICAgICAgIEhTRToge1xyXG4gICAgICAgICAgICAgIGFjdGlvbjogJ2NvdXBvbi1sb2FkZWQnLFxyXG4gICAgICAgICAgICAgIG5hbWU6IGNvdXBvbi5QYWdlTmFtZSxcclxuICAgICAgICAgICAgICBvZmZlcjogY291cG9uLnRpdGxlLFxyXG4gICAgICAgICAgICAgIGhzZXVybDogY291cG9uLnVybCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuICB9O1xyXG5cclxuICAkKGRvY3VtZW50KS5yZWFkeSgoKSA9PiB7XHJcbiAgICBjb25zdCBJQyA9IElDQUNSTygpO1xyXG4gICAgaWYgKC9eaHR0cHM6XFwvXFwvd3d3LmljYS5zZVxcLyQvLnRlc3Qod2luZG93LmxvY2F0aW9uKSkge1xyXG4gICAgICBPYmplY3QuYXNzaWduKHRlc3QsIElDKTtcclxuICAgICAgdGVzdC5jaGVja0FjdGlvbkNvb2tpZXMoKTtcclxuICAgICAgdGVzdC5tYW5pcHVsYXRlRG9tKCk7XHJcbiAgICAgIHRlc3QuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcclxuICAgIH1cclxuICAgIGlmICgvXmh0dHBzOlxcL1xcL3d3dy5pY2Euc2VcXC9lcmJqdWRhbmRlblxcL2J1dGlrc2VyYmp1ZGFuZGVuXFwvYWxsYS1kaWdpdGFsYS1rdXBvbmdlclxcLyQvLnRlc3Qod2luZG93LmxvY2F0aW9uKSkge1xyXG4gICAgICBjb3Vwb25zLm1hbmlwdWxhdGVEb20oSUMsICgpID0+IHtcclxuICAgICAgICB0ZXN0LmNyZWF0ZU1vZGFsKExPR0lOX0FDVElPTi5MT0FEX0NPVVBPTik7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KShqUXVlcnkpO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc3RhcnQtcGFnZS92YXJpYW50LmpzIiwicmVxdWlyZSgnLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnByb21pc2UnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3LnByb21pc2UuZmluYWxseScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcucHJvbWlzZS50cnknKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9fY29yZScpLlByb21pc2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vcHJvbWlzZS5qc1xuLy8gbW9kdWxlIGlkID0gNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuLy8gdHJ1ZSAgLT4gU3RyaW5nI2F0XG4vLyBmYWxzZSAtPiBTdHJpbmcjY29kZVBvaW50QXRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRPX1NUUklORykge1xuICByZXR1cm4gZnVuY3Rpb24gKHRoYXQsIHBvcykge1xuICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpO1xuICAgIHZhciBpID0gdG9JbnRlZ2VyKHBvcyk7XG4gICAgdmFyIGwgPSBzLmxlbmd0aDtcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAoaSA8IDAgfHwgaSA+PSBsKSByZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgYSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsIHx8IChiID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgYiA+IDB4ZGZmZlxuICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcbiAgICAgIDogVE9fU1RSSU5HID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zdHJpbmctYXQuanNcbi8vIG1vZHVsZSBpZCA9IDU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnZGl2JyksICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBTKSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICghUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1wcmltaXRpdmUuanNcbi8vIG1vZHVsZSBpZCA9IDU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faGlkZScpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3JlZGVmaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSA1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGRlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19oaWRlJykoSXRlcmF0b3JQcm90b3R5cGUsIHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpIHtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7IG5leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBkUHMgPSByZXF1aXJlKCcuL19vYmplY3QtZHBzJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG52YXIgRW1wdHkgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdpZnJhbWUnKTtcbiAgdmFyIGkgPSBlbnVtQnVnS2V5cy5sZW5ndGg7XG4gIHZhciBsdCA9ICc8JztcbiAgdmFyIGd0ID0gJz4nO1xuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICByZXF1aXJlKCcuL19odG1sJykuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0Oic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2NyaXB0LXVybFxuICAvLyBjcmVhdGVEaWN0ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuT2JqZWN0O1xuICAvLyBodG1sLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUobHQgKyAnc2NyaXB0JyArIGd0ICsgJ2RvY3VtZW50LkY9T2JqZWN0JyArIGx0ICsgJy9zY3JpcHQnICsgZ3QpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICBjcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjtcbiAgd2hpbGUgKGktLSkgZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5KCk7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1jcmVhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyA9IGdldEtleXMoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgUDtcbiAgd2hpbGUgKGxlbmd0aCA+IGkpIGRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XG4gIHJldHVybiBPO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHBzLmpzXG4vLyBtb2R1bGUgaWQgPSA2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGFycmF5SW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JT2JqZWN0KG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSBpZiAoa2V5ICE9IElFX1BST1RPKSBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qc1xuLy8gbW9kdWxlIGlkID0gNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pIHtcbiAgICAgIGlmIChPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanNcbi8vIG1vZHVsZSBpZCA9IDYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWFic29sdXRlLWluZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjIuOSAvIDE1LjIuMy4yIE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiAoTykge1xuICBPID0gdG9PYmplY3QoTyk7XG4gIGlmIChoYXMoTywgSUVfUFJPVE8pKSByZXR1cm4gT1tJRV9QUk9UT107XG4gIGlmICh0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG8gOiBudWxsO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ3BvLmpzXG4vLyBtb2R1bGUgaWQgPSA2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpO1xudmFyIHN0ZXAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5cbi8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKClcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUua2V5cygpXG4vLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpXG4vLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgTyA9IHRoaXMuX3Q7XG4gIHZhciBraW5kID0gdGhpcy5faztcbiAgdmFyIGluZGV4ID0gdGhpcy5faSsrO1xuICBpZiAoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpIHtcbiAgICB0aGlzLl90ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzdGVwKDEpO1xuICB9XG4gIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHN0ZXAoMCwgaW5kZXgpO1xuICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xuICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanNcbi8vIG1vZHVsZSBpZCA9IDY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRvbmUsIHZhbHVlKSB7XG4gIHJldHVybiB7IHZhbHVlOiB2YWx1ZSwgZG9uZTogISFkb25lIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItc3RlcC5qc1xuLy8gbW9kdWxlIGlkID0gNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG52YXIgdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXQ7XG52YXIgbWljcm90YXNrID0gcmVxdWlyZSgnLi9fbWljcm90YXNrJykoKTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSA9IHJlcXVpcmUoJy4vX25ldy1wcm9taXNlLWNhcGFiaWxpdHknKTtcbnZhciBwZXJmb3JtID0gcmVxdWlyZSgnLi9fcGVyZm9ybScpO1xudmFyIHByb21pc2VSZXNvbHZlID0gcmVxdWlyZSgnLi9fcHJvbWlzZS1yZXNvbHZlJyk7XG52YXIgUFJPTUlTRSA9ICdQcm9taXNlJztcbnZhciBUeXBlRXJyb3IgPSBnbG9iYWwuVHlwZUVycm9yO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciAkUHJvbWlzZSA9IGdsb2JhbFtQUk9NSVNFXTtcbnZhciBpc05vZGUgPSBjbGFzc29mKHByb2Nlc3MpID09ICdwcm9jZXNzJztcbnZhciBlbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBJbnRlcm5hbCwgbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5LCBPd25Qcm9taXNlQ2FwYWJpbGl0eSwgV3JhcHBlcjtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlLmY7XG5cbnZhciBVU0VfTkFUSVZFID0gISFmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgLy8gY29ycmVjdCBzdWJjbGFzc2luZyB3aXRoIEBAc3BlY2llcyBzdXBwb3J0XG4gICAgdmFyIHByb21pc2UgPSAkUHJvbWlzZS5yZXNvbHZlKDEpO1xuICAgIHZhciBGYWtlUHJvbWlzZSA9IChwcm9taXNlLmNvbnN0cnVjdG9yID0ge30pW3JlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyldID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgICAgIGV4ZWMoZW1wdHksIGVtcHR5KTtcbiAgICB9O1xuICAgIC8vIHVuaGFuZGxlZCByZWplY3Rpb25zIHRyYWNraW5nIHN1cHBvcnQsIE5vZGVKUyBQcm9taXNlIHdpdGhvdXQgaXQgZmFpbHMgQEBzcGVjaWVzIHRlc3RcbiAgICByZXR1cm4gKGlzTm9kZSB8fCB0eXBlb2YgUHJvbWlzZVJlamVjdGlvbkV2ZW50ID09ICdmdW5jdGlvbicpICYmIHByb21pc2UudGhlbihlbXB0eSkgaW5zdGFuY2VvZiBGYWtlUHJvbWlzZTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG59KCk7XG5cbi8vIGhlbHBlcnNcbnZhciBpc1RoZW5hYmxlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmIHR5cGVvZiAodGhlbiA9IGl0LnRoZW4pID09ICdmdW5jdGlvbicgPyB0aGVuIDogZmFsc2U7XG59O1xudmFyIG5vdGlmeSA9IGZ1bmN0aW9uIChwcm9taXNlLCBpc1JlamVjdCkge1xuICBpZiAocHJvbWlzZS5fbikgcmV0dXJuO1xuICBwcm9taXNlLl9uID0gdHJ1ZTtcbiAgdmFyIGNoYWluID0gcHJvbWlzZS5fYztcbiAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92O1xuICAgIHZhciBvayA9IHByb21pc2UuX3MgPT0gMTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHJ1biA9IGZ1bmN0aW9uIChyZWFjdGlvbikge1xuICAgICAgdmFyIGhhbmRsZXIgPSBvayA/IHJlYWN0aW9uLm9rIDogcmVhY3Rpb24uZmFpbDtcbiAgICAgIHZhciByZXNvbHZlID0gcmVhY3Rpb24ucmVzb2x2ZTtcbiAgICAgIHZhciByZWplY3QgPSByZWFjdGlvbi5yZWplY3Q7XG4gICAgICB2YXIgZG9tYWluID0gcmVhY3Rpb24uZG9tYWluO1xuICAgICAgdmFyIHJlc3VsdCwgdGhlbjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgaWYgKCFvaykge1xuICAgICAgICAgICAgaWYgKHByb21pc2UuX2ggPT0gMikgb25IYW5kbGVVbmhhbmRsZWQocHJvbWlzZSk7XG4gICAgICAgICAgICBwcm9taXNlLl9oID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhhbmRsZXIgPT09IHRydWUpIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGRvbWFpbikgZG9tYWluLmVudGVyKCk7XG4gICAgICAgICAgICByZXN1bHQgPSBoYW5kbGVyKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChkb21haW4pIGRvbWFpbi5leGl0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2UpIHtcbiAgICAgICAgICAgIHJlamVjdChUeXBlRXJyb3IoJ1Byb21pc2UtY2hhaW4gY3ljbGUnKSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGVuID0gaXNUaGVuYWJsZShyZXN1bHQpKSB7XG4gICAgICAgICAgICB0aGVuLmNhbGwocmVzdWx0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSByZWplY3QodmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB3aGlsZSAoY2hhaW4ubGVuZ3RoID4gaSkgcnVuKGNoYWluW2krK10pOyAvLyB2YXJpYWJsZSBsZW5ndGggLSBjYW4ndCB1c2UgZm9yRWFjaFxuICAgIHByb21pc2UuX2MgPSBbXTtcbiAgICBwcm9taXNlLl9uID0gZmFsc2U7XG4gICAgaWYgKGlzUmVqZWN0ICYmICFwcm9taXNlLl9oKSBvblVuaGFuZGxlZChwcm9taXNlKTtcbiAgfSk7XG59O1xudmFyIG9uVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgdGFzay5jYWxsKGdsb2JhbCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3Y7XG4gICAgdmFyIHVuaGFuZGxlZCA9IGlzVW5oYW5kbGVkKHByb21pc2UpO1xuICAgIHZhciByZXN1bHQsIGhhbmRsZXIsIGNvbnNvbGU7XG4gICAgaWYgKHVuaGFuZGxlZCkge1xuICAgICAgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpc05vZGUpIHtcbiAgICAgICAgICBwcm9jZXNzLmVtaXQoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChoYW5kbGVyID0gZ2xvYmFsLm9udW5oYW5kbGVkcmVqZWN0aW9uKSB7XG4gICAgICAgICAgaGFuZGxlcih7IHByb21pc2U6IHByb21pc2UsIHJlYXNvbjogdmFsdWUgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoKGNvbnNvbGUgPSBnbG9iYWwuY29uc29sZSkgJiYgY29uc29sZS5lcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbicsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyBCcm93c2VycyBzaG91bGQgbm90IHRyaWdnZXIgYHJlamVjdGlvbkhhbmRsZWRgIGV2ZW50IGlmIGl0IHdhcyBoYW5kbGVkIGhlcmUsIE5vZGVKUyAtIHNob3VsZFxuICAgICAgcHJvbWlzZS5faCA9IGlzTm9kZSB8fCBpc1VuaGFuZGxlZChwcm9taXNlKSA/IDIgOiAxO1xuICAgIH0gcHJvbWlzZS5fYSA9IHVuZGVmaW5lZDtcbiAgICBpZiAodW5oYW5kbGVkICYmIHJlc3VsdC5lKSB0aHJvdyByZXN1bHQudjtcbiAgfSk7XG59O1xudmFyIGlzVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgaWYgKHByb21pc2UuX2ggPT0gMSkgcmV0dXJuIGZhbHNlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9hIHx8IHByb21pc2UuX2M7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlYWN0aW9uO1xuICB3aGlsZSAoY2hhaW4ubGVuZ3RoID4gaSkge1xuICAgIHJlYWN0aW9uID0gY2hhaW5baSsrXTtcbiAgICBpZiAocmVhY3Rpb24uZmFpbCB8fCAhaXNVbmhhbmRsZWQocmVhY3Rpb24ucHJvbWlzZSkpIHJldHVybiBmYWxzZTtcbiAgfSByZXR1cm4gdHJ1ZTtcbn07XG52YXIgb25IYW5kbGVVbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhhbmRsZXI7XG4gICAgaWYgKGlzTm9kZSkge1xuICAgICAgcHJvY2Vzcy5lbWl0KCdyZWplY3Rpb25IYW5kbGVkJywgcHJvbWlzZSk7XG4gICAgfSBlbHNlIGlmIChoYW5kbGVyID0gZ2xvYmFsLm9ucmVqZWN0aW9uaGFuZGxlZCkge1xuICAgICAgaGFuZGxlcih7IHByb21pc2U6IHByb21pc2UsIHJlYXNvbjogcHJvbWlzZS5fdiB9KTtcbiAgICB9XG4gIH0pO1xufTtcbnZhciAkcmVqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHZhciBwcm9taXNlID0gdGhpcztcbiAgaWYgKHByb21pc2UuX2QpIHJldHVybjtcbiAgcHJvbWlzZS5fZCA9IHRydWU7XG4gIHByb21pc2UgPSBwcm9taXNlLl93IHx8IHByb21pc2U7IC8vIHVud3JhcFxuICBwcm9taXNlLl92ID0gdmFsdWU7XG4gIHByb21pc2UuX3MgPSAyO1xuICBpZiAoIXByb21pc2UuX2EpIHByb21pc2UuX2EgPSBwcm9taXNlLl9jLnNsaWNlKCk7XG4gIG5vdGlmeShwcm9taXNlLCB0cnVlKTtcbn07XG52YXIgJHJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIHByb21pc2UgPSB0aGlzO1xuICB2YXIgdGhlbjtcbiAgaWYgKHByb21pc2UuX2QpIHJldHVybjtcbiAgcHJvbWlzZS5fZCA9IHRydWU7XG4gIHByb21pc2UgPSBwcm9taXNlLl93IHx8IHByb21pc2U7IC8vIHVud3JhcFxuICB0cnkge1xuICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkgdGhyb3cgVHlwZUVycm9yKFwiUHJvbWlzZSBjYW4ndCBiZSByZXNvbHZlZCBpdHNlbGZcIik7XG4gICAgaWYgKHRoZW4gPSBpc1RoZW5hYmxlKHZhbHVlKSkge1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSB7IF93OiBwcm9taXNlLCBfZDogZmFsc2UgfTsgLy8gd3JhcFxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoZW4uY2FsbCh2YWx1ZSwgY3R4KCRyZXNvbHZlLCB3cmFwcGVyLCAxKSwgY3R4KCRyZWplY3QsIHdyYXBwZXIsIDEpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICRyZWplY3QuY2FsbCh3cmFwcGVyLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgICAgIHByb21pc2UuX3MgPSAxO1xuICAgICAgbm90aWZ5KHByb21pc2UsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAkcmVqZWN0LmNhbGwoeyBfdzogcHJvbWlzZSwgX2Q6IGZhbHNlIH0sIGUpOyAvLyB3cmFwXG4gIH1cbn07XG5cbi8vIGNvbnN0cnVjdG9yIHBvbHlmaWxsXG5pZiAoIVVTRV9OQVRJVkUpIHtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgJFByb21pc2UgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkUHJvbWlzZSwgUFJPTUlTRSwgJ19oJyk7XG4gICAgYUZ1bmN0aW9uKGV4ZWN1dG9yKTtcbiAgICBJbnRlcm5hbC5jYWxsKHRoaXMpO1xuICAgIHRyeSB7XG4gICAgICBleGVjdXRvcihjdHgoJHJlc29sdmUsIHRoaXMsIDEpLCBjdHgoJHJlamVjdCwgdGhpcywgMSkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgJHJlamVjdC5jYWxsKHRoaXMsIGVycik7XG4gICAgfVxuICB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgSW50ZXJuYWwgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgdGhpcy5fYyA9IFtdOyAgICAgICAgICAgICAvLyA8LSBhd2FpdGluZyByZWFjdGlvbnNcbiAgICB0aGlzLl9hID0gdW5kZWZpbmVkOyAgICAgIC8vIDwtIGNoZWNrZWQgaW4gaXNVbmhhbmRsZWQgcmVhY3Rpb25zXG4gICAgdGhpcy5fcyA9IDA7ICAgICAgICAgICAgICAvLyA8LSBzdGF0ZVxuICAgIHRoaXMuX2QgPSBmYWxzZTsgICAgICAgICAgLy8gPC0gZG9uZVxuICAgIHRoaXMuX3YgPSB1bmRlZmluZWQ7ICAgICAgLy8gPC0gdmFsdWVcbiAgICB0aGlzLl9oID0gMDsgICAgICAgICAgICAgIC8vIDwtIHJlamVjdGlvbiBzdGF0ZSwgMCAtIGRlZmF1bHQsIDEgLSBoYW5kbGVkLCAyIC0gdW5oYW5kbGVkXG4gICAgdGhpcy5fbiA9IGZhbHNlOyAgICAgICAgICAvLyA8LSBub3RpZnlcbiAgfTtcbiAgSW50ZXJuYWwucHJvdG90eXBlID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJykoJFByb21pc2UucHJvdG90eXBlLCB7XG4gICAgLy8gMjUuNC41LjMgUHJvbWlzZS5wcm90b3R5cGUudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZClcbiAgICB0aGVuOiBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICB2YXIgcmVhY3Rpb24gPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgJFByb21pc2UpKTtcbiAgICAgIHJlYWN0aW9uLm9rID0gdHlwZW9mIG9uRnVsZmlsbGVkID09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IHRydWU7XG4gICAgICByZWFjdGlvbi5mYWlsID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT0gJ2Z1bmN0aW9uJyAmJiBvblJlamVjdGVkO1xuICAgICAgcmVhY3Rpb24uZG9tYWluID0gaXNOb2RlID8gcHJvY2Vzcy5kb21haW4gOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9jLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYgKHRoaXMuX2EpIHRoaXMuX2EucHVzaChyZWFjdGlvbik7XG4gICAgICBpZiAodGhpcy5fcykgbm90aWZ5KHRoaXMsIGZhbHNlKTtcbiAgICAgIHJldHVybiByZWFjdGlvbi5wcm9taXNlO1xuICAgIH0sXG4gICAgLy8gMjUuNC41LjEgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2gob25SZWplY3RlZClcbiAgICAnY2F0Y2gnOiBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgfSk7XG4gIE93blByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9taXNlID0gbmV3IEludGVybmFsKCk7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB0aGlzLnJlc29sdmUgPSBjdHgoJHJlc29sdmUsIHByb21pc2UsIDEpO1xuICAgIHRoaXMucmVqZWN0ID0gY3R4KCRyZWplY3QsIHByb21pc2UsIDEpO1xuICB9O1xuICBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoQykge1xuICAgIHJldHVybiBDID09PSAkUHJvbWlzZSB8fCBDID09PSBXcmFwcGVyXG4gICAgICA/IG5ldyBPd25Qcm9taXNlQ2FwYWJpbGl0eShDKVxuICAgICAgOiBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gIH07XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHsgUHJvbWlzZTogJFByb21pc2UgfSk7XG5yZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpKCRQcm9taXNlLCBQUk9NSVNFKTtcbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoUFJPTUlTRSk7XG5XcmFwcGVyID0gcmVxdWlyZSgnLi9fY29yZScpW1BST01JU0VdO1xuXG4vLyBzdGF0aWNzXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC41IFByb21pc2UucmVqZWN0KHIpXG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpIHtcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHRoaXMpO1xuICAgIHZhciAkJHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgICQkcmVqZWN0KHIpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTElCUkFSWSB8fCAhVVNFX05BVElWRSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjYgUHJvbWlzZS5yZXNvbHZlKHgpXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCkge1xuICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZShMSUJSQVJZICYmIHRoaXMgPT09IFdyYXBwZXIgPyAkUHJvbWlzZSA6IHRoaXMsIHgpO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIShVU0VfTkFUSVZFICYmIHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24gKGl0ZXIpIHtcbiAgJFByb21pc2UuYWxsKGl0ZXIpWydjYXRjaCddKGVtcHR5KTtcbn0pKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuMSBQcm9taXNlLmFsbChpdGVyYWJsZSlcbiAgYWxsOiBmdW5jdGlvbiBhbGwoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgICB2YXIgcmVzb2x2ZSA9IGNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciByZW1haW5pbmcgPSAxO1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICB2YXIgJGluZGV4ID0gaW5kZXgrKztcbiAgICAgICAgdmFyIGFscmVhZHlDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFsdWVzLnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgcmVtYWluaW5nKys7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIGlmIChhbHJlYWR5Q2FsbGVkKSByZXR1cm47XG4gICAgICAgICAgYWxyZWFkeUNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgdmFsdWVzWyRpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmUpIHJlamVjdChyZXN1bHQudik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfSxcbiAgLy8gMjUuNC40LjQgUHJvbWlzZS5yYWNlKGl0ZXJhYmxlKVxuICByYWNlOiBmdW5jdGlvbiByYWNlKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oY2FwYWJpbGl0eS5yZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lKSByZWplY3QocmVzdWx0LnYpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnByb21pc2UuanNcbi8vIG1vZHVsZSBpZCA9IDY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBDb25zdHJ1Y3RvciwgbmFtZSwgZm9yYmlkZGVuRmllbGQpIHtcbiAgaWYgKCEoaXQgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikgfHwgKGZvcmJpZGRlbkZpZWxkICE9PSB1bmRlZmluZWQgJiYgZm9yYmlkZGVuRmllbGQgaW4gaXQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKG5hbWUgKyAnOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLWluc3RhbmNlLmpzXG4vLyBtb2R1bGUgaWQgPSA3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4vX2l0ZXItY2FsbCcpO1xudmFyIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBnZXRJdGVyRm4gPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xudmFyIEJSRUFLID0ge307XG52YXIgUkVUVVJOID0ge307XG52YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCBlbnRyaWVzLCBmbiwgdGhhdCwgSVRFUkFUT1IpIHtcbiAgdmFyIGl0ZXJGbiA9IElURVJBVE9SID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXRlcmFibGU7IH0gOiBnZXRJdGVyRm4oaXRlcmFibGUpO1xuICB2YXIgZiA9IGN0eChmbiwgdGhhdCwgZW50cmllcyA/IDIgOiAxKTtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxlbmd0aCwgc3RlcCwgaXRlcmF0b3IsIHJlc3VsdDtcbiAgaWYgKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ZXJhYmxlICsgJyBpcyBub3QgaXRlcmFibGUhJyk7XG4gIC8vIGZhc3QgY2FzZSBmb3IgYXJyYXlzIHdpdGggZGVmYXVsdCBpdGVyYXRvclxuICBpZiAoaXNBcnJheUl0ZXIoaXRlckZuKSkgZm9yIChsZW5ndGggPSB0b0xlbmd0aChpdGVyYWJsZS5sZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgIHJlc3VsdCA9IGVudHJpZXMgPyBmKGFuT2JqZWN0KHN0ZXAgPSBpdGVyYWJsZVtpbmRleF0pWzBdLCBzdGVwWzFdKSA6IGYoaXRlcmFibGVbaW5kZXhdKTtcbiAgICBpZiAocmVzdWx0ID09PSBCUkVBSyB8fCByZXN1bHQgPT09IFJFVFVSTikgcmV0dXJuIHJlc3VsdDtcbiAgfSBlbHNlIGZvciAoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChpdGVyYWJsZSk7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTspIHtcbiAgICByZXN1bHQgPSBjYWxsKGl0ZXJhdG9yLCBmLCBzdGVwLnZhbHVlLCBlbnRyaWVzKTtcbiAgICBpZiAocmVzdWx0ID09PSBCUkVBSyB8fCByZXN1bHQgPT09IFJFVFVSTikgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcbmV4cG9ydHMuQlJFQUsgPSBCUkVBSztcbmV4cG9ydHMuUkVUVVJOID0gUkVUVVJOO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Zvci1vZi5qc1xuLy8gbW9kdWxlIGlkID0gNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gZmFzdCBhcHBseSwgaHR0cDovL2pzcGVyZi5sbmtpdC5jb20vZmFzdC1hcHBseS81XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgYXJncywgdGhhdCkge1xuICB2YXIgdW4gPSB0aGF0ID09PSB1bmRlZmluZWQ7XG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiB1biA/IGZuKClcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCk7XG4gICAgY2FzZSAxOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgY2FzZSA0OiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgfSByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJncyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2ludm9rZS5qc1xuLy8gbW9kdWxlIGlkID0gNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIG1hY3JvdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXQ7XG52YXIgT2JzZXJ2ZXIgPSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgUHJvbWlzZSA9IGdsb2JhbC5Qcm9taXNlO1xudmFyIGlzTm9kZSA9IHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBoZWFkLCBsYXN0LCBub3RpZnk7XG5cbiAgdmFyIGZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXJlbnQsIGZuO1xuICAgIGlmIChpc05vZGUgJiYgKHBhcmVudCA9IHByb2Nlc3MuZG9tYWluKSkgcGFyZW50LmV4aXQoKTtcbiAgICB3aGlsZSAoaGVhZCkge1xuICAgICAgZm4gPSBoZWFkLmZuO1xuICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZuKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChoZWFkKSBub3RpZnkoKTtcbiAgICAgICAgZWxzZSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gbGFzdCA9IHVuZGVmaW5lZDtcbiAgICBpZiAocGFyZW50KSBwYXJlbnQuZW50ZXIoKTtcbiAgfTtcblxuICAvLyBOb2RlLmpzXG4gIGlmIChpc05vZGUpIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgICB9O1xuICAvLyBicm93c2VycyB3aXRoIE11dGF0aW9uT2JzZXJ2ZXJcbiAgfSBlbHNlIGlmIChPYnNlcnZlcikge1xuICAgIHZhciB0b2dnbGUgPSB0cnVlO1xuICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIG5ldyBPYnNlcnZlcihmbHVzaCkub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgbm9kZS5kYXRhID0gdG9nZ2xlID0gIXRvZ2dsZTtcbiAgICB9O1xuICAvLyBlbnZpcm9ubWVudHMgd2l0aCBtYXliZSBub24tY29tcGxldGVseSBjb3JyZWN0LCBidXQgZXhpc3RlbnQgUHJvbWlzZVxuICB9IGVsc2UgaWYgKFByb21pc2UgJiYgUHJvbWlzZS5yZXNvbHZlKSB7XG4gICAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9taXNlLnRoZW4oZmx1c2gpO1xuICAgIH07XG4gIC8vIGZvciBvdGhlciBlbnZpcm9ubWVudHMgLSBtYWNyb3Rhc2sgYmFzZWQgb246XG4gIC8vIC0gc2V0SW1tZWRpYXRlXG4gIC8vIC0gTWVzc2FnZUNoYW5uZWxcbiAgLy8gLSB3aW5kb3cucG9zdE1lc3NhZ1xuICAvLyAtIG9ucmVhZHlzdGF0ZWNoYW5nZVxuICAvLyAtIHNldFRpbWVvdXRcbiAgfSBlbHNlIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBzdHJhbmdlIElFICsgd2VicGFjayBkZXYgc2VydmVyIGJ1ZyAtIHVzZSAuY2FsbChnbG9iYWwpXG4gICAgICBtYWNyb3Rhc2suY2FsbChnbG9iYWwsIGZsdXNoKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgIHZhciB0YXNrID0geyBmbjogZm4sIG5leHQ6IHVuZGVmaW5lZCB9O1xuICAgIGlmIChsYXN0KSBsYXN0Lm5leHQgPSB0YXNrO1xuICAgIGlmICghaGVhZCkge1xuICAgICAgaGVhZCA9IHRhc2s7XG4gICAgICBub3RpZnkoKTtcbiAgICB9IGxhc3QgPSB0YXNrO1xuICB9O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19taWNyb3Rhc2suanNcbi8vIG1vZHVsZSBpZCA9IDczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzcmMsIHNhZmUpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGlmIChzYWZlICYmIHRhcmdldFtrZXldKSB0YXJnZXRba2V5XSA9IHNyY1trZXldO1xuICAgIGVsc2UgaGlkZSh0YXJnZXQsIGtleSwgc3JjW2tleV0pO1xuICB9IHJldHVybiB0YXJnZXQ7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3JlZGVmaW5lLWFsbC5qc1xuLy8gbW9kdWxlIGlkID0gNzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgU1BFQ0lFUyA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSkge1xuICB2YXIgQyA9IHR5cGVvZiBjb3JlW0tFWV0gPT0gJ2Z1bmN0aW9uJyA/IGNvcmVbS0VZXSA6IGdsb2JhbFtLRVldO1xuICBpZiAoREVTQ1JJUFRPUlMgJiYgQyAmJiAhQ1tTUEVDSUVTXSkgZFAuZihDLCBTUEVDSUVTLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfVxuICB9KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXNwZWNpZXMuanNcbi8vIG1vZHVsZSBpZCA9IDc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXByb21pc2UtZmluYWxseVxuJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKTtcbnZhciBwcm9taXNlUmVzb2x2ZSA9IHJlcXVpcmUoJy4vX3Byb21pc2UtcmVzb2x2ZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuUiwgJ1Byb21pc2UnLCB7ICdmaW5hbGx5JzogZnVuY3Rpb24gKG9uRmluYWxseSkge1xuICB2YXIgQyA9IHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCBjb3JlLlByb21pc2UgfHwgZ2xvYmFsLlByb21pc2UpO1xuICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiBvbkZpbmFsbHkgPT0gJ2Z1bmN0aW9uJztcbiAgcmV0dXJuIHRoaXMudGhlbihcbiAgICBpc0Z1bmN0aW9uID8gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZShDLCBvbkZpbmFsbHkoKSkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiB4OyB9KTtcbiAgICB9IDogb25GaW5hbGx5LFxuICAgIGlzRnVuY3Rpb24gPyBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKEMsIG9uRmluYWxseSgpKS50aGVuKGZ1bmN0aW9uICgpIHsgdGhyb3cgZTsgfSk7XG4gICAgfSA6IG9uRmluYWxseVxuICApO1xufSB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5wcm9taXNlLmZpbmFsbHkuanNcbi8vIG1vZHVsZSBpZCA9IDc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXByb21pc2UtdHJ5XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gcmVxdWlyZSgnLi9fbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xudmFyIHBlcmZvcm0gPSByZXF1aXJlKCcuL19wZXJmb3JtJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUHJvbWlzZScsIHsgJ3RyeSc6IGZ1bmN0aW9uIChjYWxsYmFja2ZuKSB7XG4gIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5LmYodGhpcyk7XG4gIHZhciByZXN1bHQgPSBwZXJmb3JtKGNhbGxiYWNrZm4pO1xuICAocmVzdWx0LmUgPyBwcm9taXNlQ2FwYWJpbGl0eS5yZWplY3QgOiBwcm9taXNlQ2FwYWJpbGl0eS5yZXNvbHZlKShyZXN1bHQudik7XG4gIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eS5wcm9taXNlO1xufSB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5wcm9taXNlLnRyeS5qc1xuLy8gbW9kdWxlIGlkID0gNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJyk7XG52YXIgJEpTT04gPSBjb3JlLkpTT04gfHwgKGNvcmUuSlNPTiA9IHsgc3RyaW5naWZ5OiBKU09OLnN0cmluZ2lmeSB9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3RyaW5naWZ5KGl0KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgcmV0dXJuICRKU09OLnN0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJndW1lbnRzKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vanNvbi9zdHJpbmdpZnkuanNcbi8vIG1vZHVsZSBpZCA9IDc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5hc3NpZ247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2Fzc2lnbi5qc1xuLy8gbW9kdWxlIGlkID0gNzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMS4zLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GLCAnT2JqZWN0JywgeyBhc3NpZ246IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKSB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzXG4vLyBtb2R1bGUgaWQgPSA4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyAxOS4xLjIuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlLCAuLi4pXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciAkYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG5tb2R1bGUuZXhwb3J0cyA9ICEkYXNzaWduIHx8IHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICB2YXIgQSA9IHt9O1xuICB2YXIgQiA9IHt9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgdmFyIFMgPSBTeW1ib2woKTtcbiAgdmFyIEsgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW1NdID0gNztcbiAgSy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoaykgeyBCW2tdID0gazsgfSk7XG4gIHJldHVybiAkYXNzaWduKHt9LCBBKVtTXSAhPSA3IHx8IE9iamVjdC5rZXlzKCRhc3NpZ24oe30sIEIpKS5qb2luKCcnKSAhPSBLO1xufSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgVCA9IHRvT2JqZWN0KHRhcmdldCk7XG4gIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMTtcbiAgdmFyIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIHZhciBpc0VudW0gPSBwSUUuZjtcbiAgd2hpbGUgKGFMZW4gPiBpbmRleCkge1xuICAgIHZhciBTID0gSU9iamVjdChhcmd1bWVudHNbaW5kZXgrK10pO1xuICAgIHZhciBrZXlzID0gZ2V0U3ltYm9scyA/IGdldEtleXMoUykuY29uY2F0KGdldFN5bWJvbHMoUykpIDogZ2V0S2V5cyhTKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGogPSAwO1xuICAgIHZhciBrZXk7XG4gICAgd2hpbGUgKGxlbmd0aCA+IGopIGlmIChpc0VudW0uY2FsbChTLCBrZXkgPSBrZXlzW2orK10pKSBUW2tleV0gPSBTW2tleV07XG4gIH0gcmV0dXJuIFQ7XG59IDogJGFzc2lnbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtYXNzaWduLmpzXG4vLyBtb2R1bGUgaWQgPSA4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BzLmpzXG4vLyBtb2R1bGUgaWQgPSA4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzLmYgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtcGllLmpzXG4vLyBtb2R1bGUgaWQgPSA4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vbnVtYmVyL2lzLWludGVnZXJcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvbnVtYmVyL2lzLWludGVnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm51bWJlci5pcy1pbnRlZ2VyJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5OdW1iZXIuaXNJbnRlZ2VyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL251bWJlci9pcy1pbnRlZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4xLjIuMyBOdW1iZXIuaXNJbnRlZ2VyKG51bWJlcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywgeyBpc0ludGVnZXI6IHJlcXVpcmUoJy4vX2lzLWludGVnZXInKSB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5udW1iZXIuaXMtaW50ZWdlci5qc1xuLy8gbW9kdWxlIGlkID0gODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjAuMS4yLjMgTnVtYmVyLmlzSW50ZWdlcihudW1iZXIpXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzSW50ZWdlcihpdCkge1xuICByZXR1cm4gIWlzT2JqZWN0KGl0KSAmJiBpc0Zpbml0ZShpdCkgJiYgZmxvb3IoaXQpID09PSBpdDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtaW50ZWdlci5qc1xuLy8gbW9kdWxlIGlkID0gODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9rZXlzXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSA4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3Qua2V5cycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LmtleXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2tleXMuanNcbi8vIG1vZHVsZSBpZCA9IDg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMi4xNCBPYmplY3Qua2V5cyhPKVxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2tleXMnLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBrZXlzKGl0KSB7XG4gICAgcmV0dXJuICRrZXlzKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3Qua2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gOTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gbW9zdCBPYmplY3QgbWV0aG9kcyBieSBFUzYgc2hvdWxkIGFjY2VwdCBwcmltaXRpdmVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZLCBleGVjKSB7XG4gIHZhciBmbiA9IChjb3JlLk9iamVjdCB8fCB7fSlbS0VZXSB8fCBPYmplY3RbS0VZXTtcbiAgdmFyIGV4cCA9IHt9O1xuICBleHBbS0VZXSA9IGV4ZWMoZm4pO1xuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uICgpIHsgZm4oMSk7IH0pLCAnT2JqZWN0JywgZXhwKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXNhcC5qc1xuLy8gbW9kdWxlIGlkID0gOTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5hcnJheS5mcm9tJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5BcnJheS5mcm9tO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL2FycmF5L2Zyb20uanNcbi8vIG1vZHVsZSBpZCA9IDkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJyk7XG52YXIgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2NyZWF0ZS1wcm9wZXJ0eScpO1xudmFyIGdldEl0ZXJGbiA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24gKGl0ZXIpIHsgQXJyYXkuZnJvbShpdGVyKTsgfSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4yLjEgQXJyYXkuZnJvbShhcnJheUxpa2UsIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICBmcm9tOiBmdW5jdGlvbiBmcm9tKGFycmF5TGlrZSAvKiAsIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkICovKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdChhcnJheUxpa2UpO1xuICAgIHZhciBDID0gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBBcnJheTtcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIG1hcGZuID0gYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGl0ZXJGbiA9IGdldEl0ZXJGbihPKTtcbiAgICB2YXIgbGVuZ3RoLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yO1xuICAgIGlmIChtYXBwaW5nKSBtYXBmbiA9IGN0eChtYXBmbiwgYUxlbiA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQsIDIpO1xuICAgIC8vIGlmIG9iamVjdCBpc24ndCBpdGVyYWJsZSBvciBpdCdzIGFycmF5IHdpdGggZGVmYXVsdCBpdGVyYXRvciAtIHVzZSBzaW1wbGUgY2FzZVxuICAgIGlmIChpdGVyRm4gIT0gdW5kZWZpbmVkICYmICEoQyA9PSBBcnJheSAmJiBpc0FycmF5SXRlcihpdGVyRm4pKSkge1xuICAgICAgZm9yIChpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKE8pLCByZXN1bHQgPSBuZXcgQygpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7IGluZGV4KyspIHtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IGNhbGwoaXRlcmF0b3IsIG1hcGZuLCBbc3RlcC52YWx1ZSwgaW5kZXhdLCB0cnVlKSA6IHN0ZXAudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgICBmb3IgKHJlc3VsdCA9IG5ldyBDKGxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBtYXBmbihPW2luZGV4XSwgaW5kZXgpIDogT1tpbmRleF0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQubGVuZ3RoID0gaW5kZXg7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuZnJvbS5qc1xuLy8gbW9kdWxlIGlkID0gOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgaW5kZXgsIHZhbHVlKSB7XG4gIGlmIChpbmRleCBpbiBvYmplY3QpICRkZWZpbmVQcm9wZXJ0eS5mKG9iamVjdCwgaW5kZXgsIGNyZWF0ZURlc2MoMCwgdmFsdWUpKTtcbiAgZWxzZSBvYmplY3RbaW5kZXhdID0gdmFsdWU7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NyZWF0ZS1wcm9wZXJ0eS5qc1xuLy8gbW9kdWxlIGlkID0gOTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZnJvbSA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL2FycmF5L2Zyb21cIik7XG5cbnZhciBfZnJvbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mcm9tKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgYXJyMltpXSA9IGFycltpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyMjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKDAsIF9mcm9tMi5kZWZhdWx0KShhcnIpO1xuICB9XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy90b0NvbnN1bWFibGVBcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL2lzLWl0ZXJhYmxlXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL2lzLWl0ZXJhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSA5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL2NvcmUuaXMtaXRlcmFibGUnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9pcy1pdGVyYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmlzSXRlcmFibGUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8gPSBPYmplY3QoaXQpO1xuICByZXR1cm4gT1tJVEVSQVRPUl0gIT09IHVuZGVmaW5lZFxuICAgIHx8ICdAQGl0ZXJhdG9yJyBpbiBPXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgIHx8IEl0ZXJhdG9ycy5oYXNPd25Qcm9wZXJ0eShjbGFzc29mKE8pKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmlzLWl0ZXJhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSA5OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vZ2V0LWl0ZXJhdG9yXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL2dldC1pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gOTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvcicpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL2dldC1pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMTAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGdldCA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvciA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgaXRlckZuID0gZ2V0KGl0KTtcbiAgaWYgKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgaXRlcmFibGUhJyk7XG4gIHJldHVybiBhbk9iamVjdChpdGVyRm4uY2FsbChpdCkpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKHN0YXJzKSB7XHJcbiAgY29uc3QgYXJyID0gWycwJywgJzI2JywgJzUyJywgJzc4JywgJzEwNCddO1xyXG4gIGNvbnN0IHN0cnMgPSBhcnIubWFwKCh4LCBpbmRleCkgPT4gKFxyXG4gICAgYDxnIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgke3h9IDApXCIgY2xhc3M9XCIke2luZGV4IDwgc3RhcnMgPyAnYWN0aXZlJyA6ICcnfVwiPlxyXG4gICAgICA8cGF0aCBkPVwiTTIzLjIgMTAuMzAzcS4xOTQuNTA5LS4wNzMuOTctMS4xODggMi4xODItNS4wNjcgNS40NzkgMS4wMTggNC4xOTQgMS4yMTIgNi43MTUuMDQ5LjY3OS0uNTMzIDEuMDY3LS4zMTUuMTk0LS42My4xOTQtLjI0MiAwLS41MzMtLjEyMS0uNDEyLS4yNDItMS4zMzMtLjY3OS0zLjI3My0xLjYyNC00LjYwNi0yLjQ3My0xLjMzMy44NDktNC42MDYgMi40NzMtLjkyMS40MzYtMS4zMzMuNjc5LS42MDYuMzE1LTEuMTY0LS4wNzMtLjU4Mi0uMzg4LS41MzMtMS4wNjcuMTk0LTIuNTIxIDEuMjEyLTYuNzE1LTMuODc5LTMuMjk3LTUuMDY3LTUuNDc5LS4yNjctLjQ2MS0uMDczLS45Ny4xNy0uNTA5LjYzLS42NzkgMS4zNTgtLjYwNiA2Ljg2MS0uOCAxLjk4OC01Ljc3IDMuMjQ4LTcuMDMuMzg4LS4zMzkuODI0LS4zMzkuNDYxIDAgLjguMzM5IDEuMjg1IDEuMjYxIDMuMjczIDcuMDMgNS41MDMuMTk0IDYuODYxLjguNDYxLjE5NC42My42Nzl6XCI+PC9wYXRoPlxyXG4gICAgICA8L2c+YCkpO1xyXG4gIHJldHVybiBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIi0wLjEyMDk5NjI2NjYwMzQ2OTg1IDEuNDU1MDAwMTYyMTI0NjMzOCAxMjcuMzk0MDAxMjE1Njk2MzMgMjUuMzQ2MDA0Njk0NzAwMjRcIj5cclxuICA8bGluZWFyR3JhZGllbnQgaWQ9XCJoYWxmXCIgeDE9XCIwXCIgeDI9XCIxMDAlXCIgeTE9XCIwXCIgeTI9XCIwXCI+XHJcbiAgPHN0b3Agb2Zmc2V0PVwiNTAlXCIgc3RvcC1jb2xvcj1cImN1cnJlbnRDb2xvclwiPjwvc3RvcD5cclxuICA8c3RvcCBvZmZzZXQ9XCI1MCVcIiBzdG9wLWNvbG9yPVwiI2Q1ZDdkYVwiPjwvc3RvcD5cclxuICA8L2xpbmVhckdyYWRpZW50PlxyXG4gICR7c3Rycy5qb2luKCcnKX1cclxuICA8L3N2Zz5gO1xyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy91dGlsL21vZHVsZXMvcmF0aW5ncy5qcyIsImV4cG9ydCBkZWZhdWx0IFtcclxuICB7XHJcbiAgICByZWNpcGVJZDogNzE4MzgyLFxyXG4gICAgdGl0bGU6ICdMYXNhZ25lIG1lZCBoYWxsb3VtaSwgc3BlbmF0IG9jaCBwdW1wYWvDpHJub3InLFxyXG4gICAgc3RhcnM6IDQsXHJcbiAgICBjb29rVGltZTogJzYwIE1JTiB8IE1FREVMJyxcclxuICAgIGltYWdlOiAnaHR0cHM6Ly93d3cuaWNhLnNlL2ltYWdldmF1bHRmaWxlcy9pZF8xMDY3MzQvY2ZfMjU5L2xhc2FnbmUtbWVkLWhhbGxvdW1pLXNwZW5hdC1vY2gtcHVtcGFrYXJub3ItNzE4MzgyLnBuZycsXHJcbiAgICB1cmw6ICdodHRwczovL3d3dy5pY2Euc2UvcmVjZXB0L2xhc2FnbmUtbWVkLWhhbGxvdW1pLXNwZW5hdC1vY2gtcHVtcGFrYXJub3ItNzE4MzgyLycsXHJcbiAgICBjb3Vwb25zOiBbXHJcbiAgICAgIHtcclxuICAgICAgICBpZDogNDU4Mjc4LFxyXG4gICAgICAgIHJlY2lwZUlkOiA3MTgzODIsXHJcbiAgICAgICAgdGl0bGU6ICdCw7ZucGFzdGEvIGxhc2FnbmVwbGF0dG9yJyxcclxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vd3d3LmljYS5zZS9IYW5kbGVycy9JbWFnZS5hc2h4P3c9MTUwJmg9MTUwJm09cCZiZ3I9ZmZmJnU9aHR0cDovL2V4dGJpbGQuaWNhLnNlLy9QaWN0dXJlV2ViLzgwLzEwMzAvMTRfMTAwMDU1NTMwOS5qcGcnLFxyXG4gICAgICAgIGRpc2NvdW50OiAnMjAlIHJhYmF0dCcsXHJcbiAgICAgICAgc3VidGl0bGU6ICdSaXNlbnRhIDEyMC0yMDAgZycsXHJcbiAgICAgICAgdXJsOiAnL2thbXBhbmovaHNlLzQ1ODI3OCcsXHJcbiAgICAgICAgUGFnZU5hbWU6ICdMU1IgMTAzMCBCw7ZucGFzdGEvbGFzYWduZXBsYXR0b3InLFxyXG4gICAgICAgIE9mZmVySWQ6IDEwMDA1NTUzMDksXHJcbiAgICAgICAgQ2FtcGFpZ25JZDogMTAzMCxcclxuICAgICAgfSxcclxuICAgICAge1xyXG4gICAgICAgIGlkOiA0NTgyNzYsXHJcbiAgICAgICAgcmVjaXBlSWQ6IDcxODM4MixcclxuICAgICAgICB0aXRsZTogJ0J1bGpvbmdrdWJlcicsXHJcbiAgICAgICAgaW1hZ2U6ICdodHRwczovL3d3dy5pY2Euc2UvSGFuZGxlcnMvSW1hZ2UuYXNoeD93PTE1MCZoPTE1MCZtPXAmYmdyPWZmZiZ1PWh0dHA6Ly9leHRiaWxkLmljYS5zZS8vUGljdHVyZVdlYi84MC8xMDI4LzE0XzEwMDA1NTUzMDcuanBnJyxcclxuICAgICAgICBkaXNjb3VudDogJzI1JSByYWJhdHQnLFxyXG4gICAgICAgIHN1YnRpdGxlOiAnS25vcnIgNi1wYWNrJyxcclxuICAgICAgICB1cmw6ICcva2FtcGFuai9oc2UvNDU4Mjc2JyxcclxuICAgICAgICBQYWdlTmFtZTogJ0xTUiAxMDI4IEJ1bGpvbmcnLFxyXG4gICAgICAgIE9mZmVySWQ6IDEwMDA1NTUzMDcsXHJcbiAgICAgICAgQ2FtcGFpZ25JZDogMTAyOCxcclxuICAgICAgfSxcclxuICAgIF0sXHJcbiAgfSxcclxuICB7XHJcbiAgICByZWNpcGVJZDogNzIyODAzLFxyXG4gICAgdGl0bGU6ICdQYXN0YSBtZWQgZmFsYWZlbCBvY2ggw6RydHBlc3RvJyxcclxuICAgIHN0YXJzOiAzLFxyXG4gICAgY29va1RpbWU6ICc0NSBNSU4gfCBNRURFTCcsXHJcbiAgICBpbWFnZTogJ2h0dHBzOi8vd3d3LmljYS5zZS9pbWFnZXZhdWx0ZmlsZXMvaWRfMTY4ODUxL2NmXzI1OS9wYXN0YS1tZWQtZmFsYWZlbC1hcnRwZXN0by03MjI4MDMtNzAweDY1NC5qcGcnLFxyXG4gICAgdXJsOiAnaHR0cHM6Ly93d3cuaWNhLnNlL3JlY2VwdC9wYXN0YS1tZWQtZmFsYWZlbC1vY2gtYXJ0cGVzdG8tNzIyODAzLycsXHJcbiAgICBjb3Vwb25zOiBbXHJcbiAgICAgIHtcclxuICAgICAgICBpZDogNDU4MjgwLFxyXG4gICAgICAgIHJlY2lwZUlkOiA3MjI4MDMsXHJcbiAgICAgICAgdGl0bGU6ICdGYWxhZmVsJyxcclxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vd3d3LmljYS5zZS9IYW5kbGVycy9JbWFnZS5hc2h4P3c9MTUwJmg9MTUwJm09cCZiZ3I9ZmZmJnU9aHR0cDovL2V4dGJpbGQuaWNhLnNlLy9QaWN0dXJlV2ViLzgwLzEwMzEvMTRfMTAwMDU1NTMxMC5qcGcnLFxyXG4gICAgICAgIGRpc2NvdW50OiAnNSBrciByYWJhdHQnLFxyXG4gICAgICAgIHN1YnRpdGxlOiAnRmluZHVzIDQ1MCBnJyxcclxuICAgICAgICB1cmw6ICcva2FtcGFuai9oc2UvNDU4MjgwJyxcclxuICAgICAgICBQYWdlTmFtZTogJ0xTUiAxMDMxIEZhbGFmZWwnLFxyXG4gICAgICAgIE9mZmVySWQ6IDEwMDA1NTUzMTAsXHJcbiAgICAgICAgQ2FtcGFpZ25JZDogMTAzMSxcclxuICAgICAgfSxcclxuICAgICAge1xyXG4gICAgICAgIGlkOiA0NTgyNzcsXHJcbiAgICAgICAgcmVjaXBlSWQ6IDcyMjgwMyxcclxuICAgICAgICB0aXRsZTogJ2lNYXQnLFxyXG4gICAgICAgIGltYWdlOiAnaHR0cHM6Ly93d3cuaWNhLnNlL0hhbmRsZXJzL0ltYWdlLmFzaHg/dz0xNTAmaD0xNTAmbT1wJmJncj1mZmYmdT1odHRwOi8vZXh0YmlsZC5pY2Euc2UvL1BpY3R1cmVXZWIvODAvMTAyOS8xNF8xMDAwNTU1MzA4LmpwZycsXHJcbiAgICAgICAgZGlzY291bnQ6ICcxNSUgcmFiYXR0JyxcclxuICAgICAgICBzdWJ0aXRsZTogJ09hdGx5IDI1MCBnJyxcclxuICAgICAgICB1cmw6ICcva2FtcGFuai9oc2UvNDU4Mjc3JyxcclxuICAgICAgICBQYWdlTmFtZTogJ0xTUiAxMDI5IGlNYXQnLFxyXG4gICAgICAgIE9mZmVySWQ6IDEwMDA1NTUzMDgsXHJcbiAgICAgICAgQ2FtcGFpZ25JZDogMTAyOSxcclxuICAgICAgfSxcclxuICAgIF0sXHJcbiAgfSxcclxuICB7XHJcbiAgICByZWNpcGVJZDogNzIyODY3LFxyXG4gICAgdGl0bGU6ICdGcnlzdCBjaGVlc2VjYWtlIG1lZCBzYWZmcmFuJyxcclxuICAgIHN0YXJzOiA0LFxyXG4gICAgY29va1RpbWU6ICcxLTQgVElNIHwgTUVERUwnLFxyXG4gICAgaW1hZ2U6ICdodHRwczovL3d3dy5pY2Euc2UvaW1hZ2V2YXVsdGZpbGVzL2lkXzE3MDgwMC9jZl8yNTkvZnJ5c3QtY2hlZXNlY2FrZS1tZWQtc2FmZnJhbi03MjI4NjctbGl0ZW4uanBnJyxcclxuICAgIHVybDogJ2h0dHBzOi8vd3d3LmljYS5zZS9yZWNlcHQvZnJ5c3QtY2hlZXNlY2FrZS1tZWQtc2FmZnJhbi03MjI4NjcvJyxcclxuICAgIGNvdXBvbnM6IFtcclxuICAgICAge1xyXG4gICAgICAgIGlkOiA0NTgyODIsXHJcbiAgICAgICAgcmVjaXBlSWQ6IDcyMjg2NyxcclxuICAgICAgICB0aXRsZTogJ0bDpHJza29zdCcsXHJcbiAgICAgICAgaW1hZ2U6ICdodHRwczovL3d3dy5pY2Euc2UvSGFuZGxlcnMvSW1hZ2UuYXNoeD93PTE1MCZoPTE1MCZtPXAmYmdyPWZmZiZ1PWh0dHA6Ly9leHRiaWxkLmljYS5zZS8vUGljdHVyZVdlYi84MC8xMDMzLzE0XzEwMDA1NTUzMTIuanBnJyxcclxuICAgICAgICBkaXNjb3VudDogJzMga3IgcmFiYXR0JyxcclxuICAgICAgICBzdWJ0aXRsZTogJ1BoaWxhZGVscGhpYSAxNzUtMzAwIGcnLFxyXG4gICAgICAgIHVybDogJy9rYW1wYW5qL2hzZS80NTgyODInLFxyXG4gICAgICAgIFBhZ2VOYW1lOiAnTFNSIDEwMzMgRsOkcnNrb3N0IFBoaWxhZGVscGlhJyxcclxuICAgICAgICBPZmZlcklkOiAxMDAwNTU1MzEyLFxyXG4gICAgICAgIENhbXBhaWduSWQ6IDEwMzMsXHJcbiAgICAgIH0sXHJcbiAgICAgIHtcclxuICAgICAgICBpZDogNDU4Mjc0LFxyXG4gICAgICAgIHJlY2lwZUlkOiA3MjI4NjcsXHJcbiAgICAgICAgdGl0bGU6ICdNYXJnYXJpbicsXHJcbiAgICAgICAgaW1hZ2U6ICdodHRwczovL3d3dy5pY2Euc2UvSGFuZGxlcnMvSW1hZ2UuYXNoeD93PTE1MCZoPTE1MCZtPXAmYmdyPWZmZiZ1PWh0dHA6Ly9leHRiaWxkLmljYS5zZS8vUGljdHVyZVdlYi84MC8xMDI2LzE0XzEwMDA1NTUzMDUuanBnJyxcclxuICAgICAgICBkaXNjb3VudDogJzUga3IgcmFiYXR0JyxcclxuICAgICAgICBzdWJ0aXRsZTogJ01pbGRhIDEga2cnLFxyXG4gICAgICAgIHVybDogJy9rYW1wYW5qL2hzZS80NTgyNzQnLFxyXG4gICAgICAgIFBhZ2VOYW1lOiAnTFNSIDEwMjYgTWFyZ2FyaW4nLFxyXG4gICAgICAgIE9mZmVySWQ6IDEwMDA1NTUzMDUsXHJcbiAgICAgICAgQ2FtcGFpZ25JZDogMTAyNixcclxuICAgICAgfSxcclxuICAgIF0sXHJcbiAgfSxcclxuICB7XHJcbiAgICByZWNpcGVJZDogNzE5Mzc0LFxyXG4gICAgdGl0bGU6ICdUb3JzayBpIHVnbiBtZWQgZGlsbC0gb2NoIGNpdHJvbnPDpXMnLFxyXG4gICAgc3RhcnM6IDQsXHJcbiAgICBjb29rVGltZTogJzMwIE1JTiB8IE1FREVMJyxcclxuICAgIGltYWdlOiAnaHR0cHM6Ly93d3cuaWNhLnNlL2ltYWdldmF1bHRmaWxlcy9pZF8xMjI3MjcvY2ZfMjU5L3RvcnNrLWktdWduLW1lZC1kaWxsLW9jaC1jaXRyb25zYXMtdjM4LTIwMTUtNzE5Mzc0LmpwZycsXHJcbiAgICB1cmw6ICdodHRwczovL3d3dy5pY2Euc2UvcmVjZXB0L3RvcnNrLWktdWduLW1lZC1kaWxsLW9jaC1jaXRyb25zYXMtNzE5Mzc0LycsXHJcbiAgICBjb3Vwb25zOiBbXHJcbiAgICAgIHtcclxuICAgICAgICBpZDogNDU4Mjg4LFxyXG4gICAgICAgIHJlY2lwZUlkOiA3MTkzNzQsXHJcbiAgICAgICAgdGl0bGU6ICdUb3Jza2ZpbMOpJyxcclxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vd3d3LmljYS5zZS9IYW5kbGVycy9JbWFnZS5hc2h4P3c9MTUwJmg9MTUwJm09cCZiZ3I9ZmZmJnU9aHR0cDovL2V4dGJpbGQuaWNhLnNlLy9QaWN0dXJlV2ViLzgwLzEwMzgvMTRfMTAwMDU1NTMxNy5qcGcnLFxyXG4gICAgICAgIGRpc2NvdW50OiAnMjUlIHJhYmF0dCcsXHJcbiAgICAgICAgc3VidGl0bGU6ICdJQ0EgNjAwIGcnLFxyXG4gICAgICAgIHVybDogJy9rYW1wYW5qL2hzZS80NTgyODgnLFxyXG4gICAgICAgIFBhZ2VOYW1lOiAnTFNSIDEwMzggVG9yc2tmaWzDqScsXHJcbiAgICAgICAgT2ZmZXJJZDogMTAwMDU1NTMxNyxcclxuICAgICAgICBDYW1wYWlnbklkOiAxMDM4LFxyXG4gICAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAgaWQ6IDQ1ODI3NCxcclxuICAgICAgICByZWNpcGVJZDogNzE5Mzc0LFxyXG4gICAgICAgIHRpdGxlOiAnTWFyZ2FyaW4nLFxyXG4gICAgICAgIGltYWdlOiAnaHR0cHM6Ly93d3cuaWNhLnNlL0hhbmRsZXJzL0ltYWdlLmFzaHg/dz0xNTAmaD0xNTAmbT1wJmJncj1mZmYmdT1odHRwOi8vZXh0YmlsZC5pY2Euc2UvL1BpY3R1cmVXZWIvODAvMTAyNi8xNF8xMDAwNTU1MzA1LmpwZycsXHJcbiAgICAgICAgZGlzY291bnQ6ICc1IGtyIHJhYmF0dCcsXHJcbiAgICAgICAgc3VidGl0bGU6ICdNaWxkYSAxIGtnJyxcclxuICAgICAgICB1cmw6ICcva2FtcGFuai9oc2UvNDU4Mjc0JyxcclxuICAgICAgICBQYWdlTmFtZTogJ0xTUiAxMDI2IE1hcmdhcmluJyxcclxuICAgICAgICBPZmZlcklkOiAxMDAwNTU1MzA1LFxyXG4gICAgICAgIENhbXBhaWduSWQ6IDEwMjYsXHJcbiAgICAgIH0sXHJcbiAgICBdLFxyXG4gIH0sXHJcbiAge1xyXG4gICAgcmVjaXBlSWQ6IDcyMTMxMCxcclxuICAgIHRpdGxlOiAnR2x1dGVuZnJpIHNhZmZyYW5za2FrYScsXHJcbiAgICBzdGFyczogNCxcclxuICAgIGNvb2tUaW1lOiAnMS00IFRJTSB8IE1FREVMJyxcclxuICAgIGltYWdlOiAnaHR0cHM6Ly93d3cuaWNhLnNlL2ltYWdldmF1bHRmaWxlcy9pZF8xNTAzOTcvY2ZfMjU5L2dsdXRlbmZyaS1zYWZmcmFuc2tha2EtNzIxMzEwLWxpdGVuLmpwZycsXHJcbiAgICB1cmw6ICdodHRwczovL3d3dy5pY2Euc2UvcmVjZXB0L2dsdXRlbmZyaS1zYWZmcmFuc2tha2EtNzIxMzEwLycsXHJcbiAgICBjb3Vwb25zOiBbXHJcbiAgICAgIHtcclxuICAgICAgICBpZDogNDU4Mjk4LFxyXG4gICAgICAgIHJlY2lwZUlkOiA3MjEzMTAsXHJcbiAgICAgICAgdGl0bGU6ICdNYW5kZWxtYXNzYScsXHJcbiAgICAgICAgaW1hZ2U6ICdodHRwczovL3d3dy5pY2Euc2UvSGFuZGxlcnMvSW1hZ2UuYXNoeD93PTE1MCZoPTE1MCZtPXAmYmdyPWZmZiZ1PWh0dHA6Ly9leHRiaWxkLmljYS5zZS8vUGljdHVyZVdlYi84MC8xMDQ0LzE0XzEwMDA1NTUzMjMuanBnJyxcclxuICAgICAgICBkaXNjb3VudDogJzI1ICUgcmFiYXR0JyxcclxuICAgICAgICBzdWJ0aXRsZTogJ0lDQSAyMDAgZycsXHJcbiAgICAgICAgdXJsOiAnL2thbXBhbmovaHNlLzQ1ODI5OCcsXHJcbiAgICAgICAgUGFnZU5hbWU6ICdMU1IgMTA0NCBNYW5kZWxtYXNzYScsXHJcbiAgICAgICAgT2ZmZXJJZDogMTAwMDU1NTMyMyxcclxuICAgICAgICBDYW1wYWlnbklkOiAxMDQ0LFxyXG4gICAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAgaWQ6IDQ1ODI3NCxcclxuICAgICAgICByZWNpcGVJZDogNzIxMzEwLFxyXG4gICAgICAgIHRpdGxlOiAnTWFyZ2FyaW4nLFxyXG4gICAgICAgIGltYWdlOiAnaHR0cHM6Ly93d3cuaWNhLnNlL0hhbmRsZXJzL0ltYWdlLmFzaHg/dz0xNTAmaD0xNTAmbT1wJmJncj1mZmYmdT1odHRwOi8vZXh0YmlsZC5pY2Euc2UvL1BpY3R1cmVXZWIvODAvMTAyNi8xNF8xMDAwNTU1MzA1LmpwZycsXHJcbiAgICAgICAgZGlzY291bnQ6ICc1IGtyIHJhYmF0dCcsXHJcbiAgICAgICAgc3VidGl0bGU6ICdNaWxkYSAxIGtnJyxcclxuICAgICAgICB1cmw6ICcva2FtcGFuai9oc2UvNDU4Mjc0JyxcclxuICAgICAgICBQYWdlTmFtZTogJ0xTUiAxMDI2IE1hcmdhcmluJyxcclxuICAgICAgICBPZmZlcklkOiAxMDAwNTU1MzA1LFxyXG4gICAgICAgIENhbXBhaWduSWQ6IDEwMjYsXHJcbiAgICAgIH0sXHJcbiAgICBdLFxyXG4gIH0sXHJcbiAge1xyXG4gICAgcmVjaXBlSWQ6IDcyMjkyMixcclxuICAgIHRpdGxlOiAnTW96YXJ0a3Vsb3InLFxyXG4gICAgc3RhcnM6IDUsXHJcbiAgICBjb29rVGltZTogJzMwIE1JTiB8IE1FREVMJyxcclxuICAgIGltYWdlOiAnaHR0cHM6Ly93d3cuaWNhLnNlL2ltYWdldmF1bHRmaWxlcy9pZF8xNzI0OTkvY2ZfMjU5L21vemFydGt1bG9yLTcyMjkyMi01ODB4NTgwLmpwZycsXHJcbiAgICB1cmw6ICdodHRwczovL3d3dy5pY2Euc2UvcmVjZXB0L21vemFydGt1bG9yLTcyMjkyMi8nLFxyXG4gICAgY291cG9uczogW1xyXG4gICAgICB7XHJcbiAgICAgICAgaWQ6IDQ1ODI5OCxcclxuICAgICAgICByZWNpcGVJZDogNzIyOTIyLFxyXG4gICAgICAgIHRpdGxlOiAnTWFuZGVsbWFzc2EnLFxyXG4gICAgICAgIGltYWdlOiAnaHR0cHM6Ly93d3cuaWNhLnNlL0hhbmRsZXJzL0ltYWdlLmFzaHg/dz0xNTAmaD0xNTAmbT1wJmJncj1mZmYmdT1odHRwOi8vZXh0YmlsZC5pY2Euc2UvL1BpY3R1cmVXZWIvODAvMTA0NC8xNF8xMDAwNTU1MzIzLmpwZycsXHJcbiAgICAgICAgZGlzY291bnQ6ICcyNSAlIHJhYmF0dCcsXHJcbiAgICAgICAgc3VidGl0bGU6ICdJQ0EgMjAwIGcnLFxyXG4gICAgICAgIHVybDogJy9rYW1wYW5qL2hzZS80NTgyOTgnLFxyXG4gICAgICAgIFBhZ2VOYW1lOiAnTFNSIDEwNDQgTWFuZGVsbWFzc2EnLFxyXG4gICAgICAgIE9mZmVySWQ6IDEwMDA1NTUzMjMsXHJcbiAgICAgICAgQ2FtcGFpZ25JZDogMTA0NCxcclxuICAgICAgfSxcclxuICAgICAge1xyXG4gICAgICAgIGlkOiA0NTgyOTcsXHJcbiAgICAgICAgcmVjaXBlSWQ6IDcyMjkyMixcclxuICAgICAgICB0aXRsZTogJ0Jha25vdWdhdCcsXHJcbiAgICAgICAgaW1hZ2U6ICdodHRwczovL3d3dy5pY2Euc2UvSGFuZGxlcnMvSW1hZ2UuYXNoeD93PTE1MCZoPTE1MCZtPXAmYmdyPWZmZiZ1PWh0dHA6Ly9leHRiaWxkLmljYS5zZS8vUGljdHVyZVdlYi84MC8xMDQzLzE0XzEwMDA1NTUzMjIuanBnJyxcclxuICAgICAgICBkaXNjb3VudDogJzUga3IgcmFiYXR0JyxcclxuICAgICAgICBzdWJ0aXRsZTogJ0lDQSAyNTAgZycsXHJcbiAgICAgICAgdXJsOiAnL2thbXBhbmovaHNlLzQ1ODI5NycsXHJcbiAgICAgICAgUGFnZU5hbWU6ICdMU1IgMTA0MyBCYWtub3VnYXQnLFxyXG4gICAgICAgIE9mZmVySWQ6IDEwMDA1NTUzMjIsXHJcbiAgICAgICAgQ2FtcGFpZ25JZDogMTA0MyxcclxuICAgICAgfSxcclxuICAgIF0sXHJcbiAgfSxcclxuXTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3N0YXJ0LXBhZ2UvYmFubmVycy5qcyIsImltcG9ydCB7ICRFTE0gfSBmcm9tICcuLi91dGlsL21haW4nO1xyXG5pbXBvcnQgJy4vY291cG9ucy1zdHlsZS5jc3MnO1xyXG5cclxuY29uc3QgY291cG9ucyA9IHtcclxuICBwcmludEJhbm5lcihjb250ZW50LCB7XHJcbiAgICB0aXRsZSxcclxuICAgIGRpc2NvdW50LFxyXG4gICAgcHJlYW1ibGUsXHJcbiAgICB1cmwsXHJcbiAgICBpbWcsXHJcbiAgICBpc1VzZWQsXHJcbiAgICBpZCxcclxuICAgIGRhdGEsXHJcbiAgfSkge1xyXG4gICAgY29uc3QgaXNVc2VkQ2xhc3MgPSBpc1VzZWQgPyAnIGlzLXVzZWQnIDogJyc7XHJcbiAgICBjb25zdCBbXHJcbiAgICAgIGJhbm5lckVsZW1lbnQsXHJcbiAgICAgIGJhbm5lclJvdyxcclxuICAgICAgYmFubmVyQ29sdW1uMSxcclxuICAgICAgYmFubmVyQ29sdW1uMixcclxuICAgICAgYmFubmVyQ29sdW1uMyxcclxuICAgICAgaW1nRWxlbWVudCxcclxuICAgICAgdGl0bGVFbGVtZW50LFxyXG4gICAgICBkaXNjb3VudEVsZW1lbnQsXHJcbiAgICAgIHByZWFtYmxlRWxlbWVudCxcclxuICAgICAgaW1nSG9sZGVyLFxyXG4gICAgICByZWFkTW9yZSxcclxuICAgICAgZG93bkxvYWQsXHJcbiAgICBdID0gJEVMTS5jcmVhdGUoXHJcbiAgICAgIGBiYW5uZXJgLFxyXG4gICAgICAnYmFubmVyLXJvdycsXHJcbiAgICAgICdiYW5uZXItY29sdW1uJyxcclxuICAgICAgJ2Jhbm5lci1jb2x1bW4gZ3Jvdy1vbmUnLFxyXG4gICAgICAnYmFubmVyLWNvbHVtbicsXHJcbiAgICAgICdiYW5uZXItY29sdW1uX19pbWFnZScsXHJcbiAgICAgIGBoMWAsXHJcbiAgICAgIGBzcGFuYCxcclxuICAgICAgYHBgLFxyXG4gICAgICBgaW1nYCxcclxuICAgICAgJ2EnLFxyXG4gICAgICBgYnV0dG9uIC5idXR0b24gZG93bmxvYWQgJHtpc1VzZWRDbGFzc31gLFxyXG4gICAgKTtcclxuICAgIGNvbnN0IGJ1dHRvblRleHQgPSBpc1VzZWQgPyAnS3Vwb25nIGxhZGRhZCcgOiAnTGFkZGEga3Vwb25nJztcclxuXHJcbiAgICBpbWdIb2xkZXIuaW1hZ2UoaW1nKTtcclxuICAgIGltZ0VsZW1lbnQuYXBwZW5kKGltZ0hvbGRlcik7XHJcblxyXG4gICAgcmVhZE1vcmUuaHJlZihgL2thbXBhbmovaHNlLyR7aWR9YCkudGV4dCgnTMOkcyBtZXInKTtcclxuICAgIGRvd25Mb2FkLmhyZWYodXJsKS50ZXh0KGJ1dHRvblRleHQpO1xyXG5cclxuICAgIHRpdGxlRWxlbWVudC5odG1sKHRpdGxlKTtcclxuICAgIGRpc2NvdW50RWxlbWVudC5odG1sKGRpc2NvdW50KTtcclxuICAgIHByZWFtYmxlRWxlbWVudC5odG1sKHByZWFtYmxlKTtcclxuXHJcbiAgICBiYW5uZXJDb2x1bW4xLmFwcGVuZChpbWdFbGVtZW50KTtcclxuICAgIGJhbm5lckNvbHVtbjIuYXBwZW5kQWxsKHRpdGxlRWxlbWVudCwgZGlzY291bnRFbGVtZW50LCBwcmVhbWJsZUVsZW1lbnQsIHJlYWRNb3JlKTtcclxuICAgIGJhbm5lckNvbHVtbjMuYXBwZW5kKGRvd25Mb2FkKTtcclxuXHJcbiAgICBiYW5uZXJSb3cuYXBwZW5kQWxsKGJhbm5lckNvbHVtbjEsIGJhbm5lckNvbHVtbjIsIGJhbm5lckNvbHVtbjMpO1xyXG4gICAgYmFubmVyRWxlbWVudC5hcHBlbmQoYmFubmVyUm93KTtcclxuICAgIGNvbnRlbnQuYXBwZW5kKGJhbm5lckVsZW1lbnQpO1xyXG5cclxuICAgIGRvd25Mb2FkLmNsaWNrKGV2ZW50ID0+IHRoaXMub25DbGljayhldmVudCwgZGF0YSkpO1xyXG4gICAgJEVMTS5zYXZlKGlkLCBiYW5uZXJFbGVtZW50KTtcclxuXHJcbiAgICBpY2FkYXRhbGF5ZXIuYWRkKCdIU0UnLCB7XHJcbiAgICAgIEhTRToge1xyXG4gICAgICAgIGFjdGlvbjogJ2Rpc3BsYXknLFxyXG4gICAgICAgIHRpdGxlOiBkYXRhLlBhZ2VOYW1lLFxyXG4gICAgICAgIGhzZXVybDogYC9rYW1wYW5qL2hzZS8ke2RhdGEuQ2FtcGFpZ25JZH1gLFxyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcbiAgfSxcclxuICBhc3luYyBsb2FkQ291cG9uT25DYXJkKGRhdGEpIHtcclxuICAgIGF3YWl0IHRoaXMubG9hZChgL2FwaS9qc29uaHNlL0NsYWltb2ZmZXJgLCB7XHJcbiAgICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nLFxyXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgIEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgIH0sXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxyXG4gICAgfSk7XHJcbiAgfSxcclxuICBjaGVja0FjdGlvbkNvb2tpZSgpIHtcclxuICAgIGNvbnN0IGNvdXBvbiA9IHRoaXMuc3RvcmFnZS5nZXQoJ2NvdXBvbicpO1xyXG4gICAgaWYgKGNvdXBvbiAmJiB0aGlzLmlzTG9nZ2VkSW4oKSkge1xyXG4gICAgICB0aGlzLnN0b3JhZ2UucmVtb3ZlKCdjb3Vwb24nKTtcclxuICAgICAgdGhpcy5sb2FkQ291cG9uT25DYXJkKGNvdXBvbik7XHJcbiAgICB9XHJcbiAgfSxcclxuICBkZWFjdGl2YXRlQ291cG9uKGlkKSB7XHJcbiAgICAkRUxNLmdldChpZCkuZ2V0KCdidXR0b24nKS5jc3MoJ2lzLXVzZWQnKTtcclxuICB9LFxyXG4gIGFzeW5jIG9uQ2xpY2soZXZlbnQsIGRhdGEpIHtcclxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICBpZiAodGhpcy5pc0xvZ2dlZEluKCkpIHtcclxuICAgICAgdGhpcy5kZWFjdGl2YXRlQ291cG9uKGRhdGEuQ2FtcGFpZ25JZCk7XHJcbiAgICAgIGF3YWl0IHRoaXMubG9hZENvdXBvbk9uQ2FyZChkYXRhKTtcclxuICAgICAgaWNhZGF0YWxheWVyLmFkZCgnSFNFJywge1xyXG4gICAgICAgIEhTRToge1xyXG4gICAgICAgICAgYWN0aW9uOiAnY291cG9uLWxvYWRlZCcsXHJcbiAgICAgICAgICBuYW1lOiBkYXRhLlBhZ2VOYW1lLFxyXG4gICAgICAgICAgb2ZmZXI6IGRhdGEuUHJvZHVjdE5hbWUsXHJcbiAgICAgICAgICBoc2V1cmw6IGAva2FtcGFuai9oc2UvJHtkYXRhLkNhbXBhaWduSWR9YCxcclxuICAgICAgICB9LFxyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGljYWRhdGFsYXllci5hZGQoJ0hTRScsIHtcclxuICAgICAgICBIU0U6IHtcclxuICAgICAgICAgIGFjdGlvbjogJ2xvZ2luLW1vdXNlZG93bicsXHJcbiAgICAgICAgICBuYW1lOiBkYXRhLlBhZ2VOYW1lLFxyXG4gICAgICAgICAgaHNldXJsOiBgL2thbXBhbmovaHNlLyR7ZGF0YS5DYW1wYWlnbklkfWAsXHJcbiAgICAgICAgfSxcclxuICAgICAgfSk7XHJcbiAgICAgIHRoaXMuc3RvcmFnZS5zZXQoJ2NvdXBvbicsIGRhdGEpO1xyXG4gICAgICB0aGlzLmNyZWF0ZU1vZGFsKCk7XHJcbiAgICB9XHJcbiAgfSxcclxuICBsb2FkQmFubmVycyhpZHMsIGNvbnRlbnQpIHtcclxuICAgIGlkcy5mb3JFYWNoKChpZCkgPT4ge1xyXG4gICAgICB0aGlzLmxvYWQoYGh0dHBzOi8vd3d3LmljYS5zZS9hcGkvanNvbmhzZS8ke2lkfWAsIHsgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicgfSlcclxuICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcclxuICAgICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgICAgUGFnZU5hbWUsXHJcbiAgICAgICAgICAgIEhlYWRlcixcclxuICAgICAgICAgICAgT2ZmZXIsXHJcbiAgICAgICAgICAgIENhbXBhaWduSWQsXHJcbiAgICAgICAgICAgIFN0b3JlR3JvdXBJZCxcclxuICAgICAgICAgICAgU3RvcmVJZCxcclxuICAgICAgICAgIH0gPSByZXNwb25zZTtcclxuICAgICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgICAgUHJvZHVjdE5hbWUsXHJcbiAgICAgICAgICAgIExvYWRlZE9uQ2FyZCxcclxuICAgICAgICAgICAgT2ZmZXJDb25kaXRpb24sXHJcbiAgICAgICAgICAgIEJyYW5kLFxyXG4gICAgICAgICAgICBTaXplT3JRdWFudGl0eSxcclxuICAgICAgICAgICAgT2ZmZXJJZCxcclxuICAgICAgICAgIH0gPSBPZmZlcjtcclxuXHJcbiAgICAgICAgICBjb25zdCBkYXRhID0ge1xyXG4gICAgICAgICAgICBDYW1wYWlnbklkLFxyXG4gICAgICAgICAgICBQcm9kdWN0TmFtZSxcclxuICAgICAgICAgICAgQ2FtcGFpZ25JZCxcclxuICAgICAgICAgICAgUGFnZU5hbWUsXHJcbiAgICAgICAgICAgIE9mZmVySWQsXHJcbiAgICAgICAgICAgIFN0b3JlSWQsXHJcbiAgICAgICAgICAgIFN0b3JlR3JvdXBJZCxcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgICB0aGlzLnByaW50QmFubmVyKGNvbnRlbnQsIHtcclxuICAgICAgICAgICAgZGF0YSxcclxuICAgICAgICAgICAgaWQ6IENhbXBhaWduSWQsXHJcbiAgICAgICAgICAgIGlzVXNlZDogTG9hZGVkT25DYXJkLFxyXG4gICAgICAgICAgICB0aXRsZTogSGVhZGVyLFxyXG4gICAgICAgICAgICBkaXNjb3VudDogT2ZmZXJDb25kaXRpb24uQ29uZGl0aW9uc1swXSxcclxuICAgICAgICAgICAgcHJlYW1ibGU6IGAke0JyYW5kfSAke1NpemVPclF1YW50aXR5LlRleHR9YCxcclxuICAgICAgICAgICAgdXJsOiAnJyxcclxuICAgICAgICAgICAgaW1nOiBPZmZlci5JbWFnZS5JbWFnZVVybCxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfSxcclxuICBhZGRJZnJhbWUoKSB7XHJcbiAgICBjb25zdCByZXR1cm5VcmwgPSBlbmNvZGVVUklDb21wb25lbnQod2luZG93LmxvY2F0aW9uLmhyZWYpO1xyXG4gICAgY29uc3QgaWZyYW1lID0gJEVMTS5jcmVhdGUoJ2Nyby1pZnJhbWUtY29udGFpbmVyJyk7XHJcbiAgICBjb25zdCBpZnJhbWVDb250YWluZXIgPSBgPHNwYW4gY2xhc3M9XCJsb2FkZXJcIj48L3NwYW4+PGlmcmFtZSBzcmM9XCIvL3d3dy5pY2Euc2UvbG9nZ2EtaW4vP3JldHVybnVybD0ke3JldHVyblVybH1cIiBmcmFtZWJvcmRlcj1cIjBcIj48L2lmcmFtZT5gO1xyXG4gICAgaWZyYW1lLmh0bWwoaWZyYW1lQ29udGFpbmVyKTtcclxuICAgICRFTE0uZ2V0KCdib2R5JykuYXBwZW5kKGlmcmFtZSk7XHJcbiAgfSxcclxuICBtYW5pcHVsYXRlRG9tKElDQUNSTywgY3JlYXRlTW9kYWwpIHtcclxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgSUNBQ1JPLCB7IGNyZWF0ZU1vZGFsIH0pO1xyXG4gICAgY29uc3QgY29udGVudCA9ICRFTE0uZ2V0KCcjY29udGVudCcpO1xyXG4gICAgY29uc3QgcmVnZXhwID0gL3d3dy5pY2Euc2VcXC9rYW1wYW5qXFwvaHNlL2c7XHJcbiAgICBjb25zdCBiYW5uZXJzID0gdGhpcy5nZXRFbGVtZW50Q29udGVudEJ5VGFnQW5kQXR0cihyZWdleHAsICdhJywgJ2hyZWYnKTtcclxuICAgIGNvbnN0IGlkcyA9IGJhbm5lcnMubWFwKGJhbm5lciA9PiBiYW5uZXIubWF0Y2goL1xcZCskLylbMF0pO1xyXG4gICAgdGhpcy5hZGRJZnJhbWUoKTtcclxuICAgIGNvbnRlbnQuaHRtbCgnICcpO1xyXG4gICAgdGhpcy5sb2FkQmFubmVycyhpZHMsIGNvbnRlbnQpO1xyXG4gICAgdGhpcy5jaGVja0FjdGlvbkNvb2tpZSgpO1xyXG4gICAgdGhpcy5zdG9yYWdlLmNsZWFyKCk7XHJcbiAgfSxcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNvdXBvbnM7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zdGFydC1wYWdlL2NvdXBvbnMuanMiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIik7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVmaW5lUHJvcGVydHkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkuanNcbi8vIG1vZHVsZSBpZCA9IDEwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0eVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eScpO1xudmFyICRPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKSB7XG4gIHJldHVybiAkT2JqZWN0LmRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2MpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbi8vIDE5LjEuMi40IC8gMTUuMi4zLjYgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpLCAnT2JqZWN0JywgeyBkZWZpbmVQcm9wZXJ0eTogcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZiB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVnZW5lcmF0b3ItcnVudGltZVwiKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEwOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBUaGlzIG1ldGhvZCBvZiBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QgbmVlZHMgdG8gYmVcbi8vIGtlcHQgaWRlbnRpY2FsIHRvIHRoZSB3YXkgaXQgaXMgb2J0YWluZWQgaW4gcnVudGltZS5qc1xudmFyIGcgPSAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzIH0pKCkgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xuXG4vLyBVc2UgYGdldE93blByb3BlcnR5TmFtZXNgIGJlY2F1c2Ugbm90IGFsbCBicm93c2VycyBzdXBwb3J0IGNhbGxpbmdcbi8vIGBoYXNPd25Qcm9wZXJ0eWAgb24gdGhlIGdsb2JhbCBgc2VsZmAgb2JqZWN0IGluIGEgd29ya2VyLiBTZWUgIzE4My5cbnZhciBoYWRSdW50aW1lID0gZy5yZWdlbmVyYXRvclJ1bnRpbWUgJiZcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZykuaW5kZXhPZihcInJlZ2VuZXJhdG9yUnVudGltZVwiKSA+PSAwO1xuXG4vLyBTYXZlIHRoZSBvbGQgcmVnZW5lcmF0b3JSdW50aW1lIGluIGNhc2UgaXQgbmVlZHMgdG8gYmUgcmVzdG9yZWQgbGF0ZXIuXG52YXIgb2xkUnVudGltZSA9IGhhZFJ1bnRpbWUgJiYgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG5cbi8vIEZvcmNlIHJlZXZhbHV0YXRpb24gb2YgcnVudGltZS5qcy5cbmcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3J1bnRpbWVcIik7XG5cbmlmIChoYWRSdW50aW1lKSB7XG4gIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHJ1bnRpbWUuXG4gIGcucmVnZW5lcmF0b3JSdW50aW1lID0gb2xkUnVudGltZTtcbn0gZWxzZSB7XG4gIC8vIFJlbW92ZSB0aGUgZ2xvYmFsIHByb3BlcnR5IGFkZGVkIGJ5IHJ1bnRpbWUuanMuXG4gIHRyeSB7XG4gICAgZGVsZXRlIGcucmVnZW5lcmF0b3JSdW50aW1lO1xuICB9IGNhdGNoKGUpIHtcbiAgICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLW1vZHVsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvbWFzdGVyL0xJQ0VOU0UgZmlsZS4gQW5cbiAqIGFkZGl0aW9uYWwgZ3JhbnQgb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpblxuICogdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbiEoZnVuY3Rpb24oZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgdmFyIGluTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIjtcbiAgdmFyIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lO1xuICBpZiAocnVudGltZSkge1xuICAgIGlmIChpbk1vZHVsZSkge1xuICAgICAgLy8gSWYgcmVnZW5lcmF0b3JSdW50aW1lIGlzIGRlZmluZWQgZ2xvYmFsbHkgYW5kIHdlJ3JlIGluIGEgbW9kdWxlLFxuICAgICAgLy8gbWFrZSB0aGUgZXhwb3J0cyBvYmplY3QgaWRlbnRpY2FsIHRvIHJlZ2VuZXJhdG9yUnVudGltZS5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gcnVudGltZTtcbiAgICB9XG4gICAgLy8gRG9uJ3QgYm90aGVyIGV2YWx1YXRpbmcgdGhlIHJlc3Qgb2YgdGhpcyBmaWxlIGlmIHRoZSBydW50aW1lIHdhc1xuICAgIC8vIGFscmVhZHkgZGVmaW5lZCBnbG9iYWxseS5cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBEZWZpbmUgdGhlIHJ1bnRpbWUgZ2xvYmFsbHkgKGFzIGV4cGVjdGVkIGJ5IGdlbmVyYXRlZCBjb2RlKSBhcyBlaXRoZXJcbiAgLy8gbW9kdWxlLmV4cG9ydHMgKGlmIHdlJ3JlIGluIGEgbW9kdWxlKSBvciBhIG5ldywgZW1wdHkgb2JqZWN0LlxuICBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZSA9IGluTW9kdWxlID8gbW9kdWxlLmV4cG9ydHMgOiB7fTtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBydW50aW1lLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZVt0b1N0cmluZ1RhZ1N5bWJvbF0gPVxuICAgIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIHJ1bnRpbWUubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBydW50aW1lLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi4gSWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQsIGhvd2V2ZXIsIHRoZVxuICAgICAgICAgIC8vIHJlc3VsdCBmb3IgdGhpcyBpdGVyYXRpb24gd2lsbCBiZSByZWplY3RlZCB3aXRoIHRoZSBzYW1lXG4gICAgICAgICAgLy8gcmVhc29uLiBOb3RlIHRoYXQgcmVqZWN0aW9ucyBvZiB5aWVsZGVkIFByb21pc2VzIGFyZSBub3RcbiAgICAgICAgICAvLyB0aHJvd24gYmFjayBpbnRvIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIGFzIGlzIHRoZSBjYXNlXG4gICAgICAgICAgLy8gd2hlbiBhbiBhd2FpdGVkIFByb21pc2UgaXMgcmVqZWN0ZWQuIFRoaXMgZGlmZmVyZW5jZSBpblxuICAgICAgICAgIC8vIGJlaGF2aW9yIGJldHdlZW4geWllbGQgYW5kIGF3YWl0IGlzIGltcG9ydGFudCwgYmVjYXVzZSBpdFxuICAgICAgICAgIC8vIGFsbG93cyB0aGUgY29uc3VtZXIgdG8gZGVjaWRlIHdoYXQgdG8gZG8gd2l0aCB0aGUgeWllbGRlZFxuICAgICAgICAgIC8vIHJlamVjdGlvbiAoc3dhbGxvdyBpdCBhbmQgY29udGludWUsIG1hbnVhbGx5IC50aHJvdyBpdCBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgZ2VuZXJhdG9yLCBhYmFuZG9uIGl0ZXJhdGlvbiwgd2hhdGV2ZXIpLiBXaXRoXG4gICAgICAgICAgLy8gYXdhaXQsIGJ5IGNvbnRyYXN0LCB0aGVyZSBpcyBubyBvcHBvcnR1bml0eSB0byBleGFtaW5lIHRoZVxuICAgICAgICAgIC8vIHJlamVjdGlvbiByZWFzb24gb3V0c2lkZSB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBzbyB0aGVcbiAgICAgICAgICAvLyBvbmx5IG9wdGlvbiBpcyB0byB0aHJvdyBpdCBmcm9tIHRoZSBhd2FpdCBleHByZXNzaW9uLCBhbmRcbiAgICAgICAgICAvLyBsZXQgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiBoYW5kbGUgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgQXN5bmNJdGVyYXRvci5wcm90b3R5cGVbYXN5bmNJdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIHJ1bnRpbWUuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIHJ1bnRpbWUuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KVxuICAgICk7XG5cbiAgICByZXR1cm4gcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICBpZiAoISBpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIEdwW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yXCI7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgcnVudGltZS5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIHJ1bnRpbWUudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG59KShcbiAgLy8gSW4gc2xvcHB5IG1vZGUsIHVuYm91bmQgYHRoaXNgIHJlZmVycyB0byB0aGUgZ2xvYmFsIG9iamVjdCwgZmFsbGJhY2sgdG9cbiAgLy8gRnVuY3Rpb24gY29uc3RydWN0b3IgaWYgd2UncmUgaW4gZ2xvYmFsIHN0cmljdCBtb2RlLiBUaGF0IGlzIHNhZGx5IGEgZm9ybVxuICAvLyBvZiBpbmRpcmVjdCBldmFsIHdoaWNoIHZpb2xhdGVzIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5LlxuICAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzIH0pKCkgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpXG4pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfcHJvbWlzZSA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL3Byb21pc2VcIik7XG5cbnZhciBfcHJvbWlzZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9taXNlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGdlbiA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIG5ldyBfcHJvbWlzZTIuZGVmYXVsdChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBmdW5jdGlvbiBzdGVwKGtleSwgYXJnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIF9wcm9taXNlMi5kZWZhdWx0LnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBzdGVwKFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgc3RlcChcInRocm93XCIsIGVycik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0ZXAoXCJuZXh0XCIpO1xuICAgIH0pO1xuICB9O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMTEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2NvdXBvbnMtc3R5bGUuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2NvdXBvbnMtc3R5bGUuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2NvdXBvbnMtc3R5bGUuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9zdGFydC1wYWdlL2NvdXBvbnMtc3R5bGUuY3NzXG4vLyBtb2R1bGUgaWQgPSAxMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh1bmRlZmluZWQpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLmNybyAuZ3Jvdy1vbmUgeyBmbGV4LWdyb3c6IDE7IH1cXHJcXG4uY3JvIC5iYW5uZXIgeyBkaXNwbGF5OmZsZXg7IGJhY2tncm91bmQtY29sb3I6ICNGOEVCRjM7IG1hcmdpbi1ib3R0b206IDEwcHg7IH1cXHJcXG4uY3JvIC5iYW5uZXIuaXMtdXNlZCB7IGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjQ3LDI0NywyNDcsMSk7IH1cXHJcXG4uY3JvIC5iYW5uZXItcm93IHtcXHJcXG5kaXNwbGF5OmZsZXg7XFxyXFxud2lkdGg6MTAwJTtcXHJcXG5hbGlnbi1pdGVtczogY2VudGVyO1xcclxcbmJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcclxcbm1hcmdpbjogMTBweCAxNXB4O1xcclxcbnBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG59XFxyXFxuLmNybyAuYmFubmVyLXJvdzo6YWZ0ZXIge1xcclxcbmJhY2tncm91bmQ6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBEOTRiV3dnZG1WeWMybHZiajBpTVM0d0lpQmxibU52WkdsdVp6MGlkWFJtTFRnaVB6NEtQQ0V0TFNCSFpXNWxjbUYwYjNJNklFRmtiMkpsSUVsc2JIVnpkSEpoZEc5eUlESXhMakF1TVN3Z1UxWkhJRVY0Y0c5eWRDQlFiSFZuTFVsdUlDNGdVMVpISUZabGNuTnBiMjQ2SURZdU1EQWdRblZwYkdRZ01Da2dJQzB0UGdvOGMzWm5JSFpsY25OcGIyNDlJakV1TVNJZ2FXUTlJa3hoZVdWeVh6RWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SWdlRzFzYm5NNmVHeHBibXM5SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpFNU9Ua3ZlR3hwYm1zaUlIZzlJakJ3ZUNJZ2VUMGlNSEI0SWdvSklIWnBaWGRDYjNnOUlqQWdNQ0F4TUNBeU1DSWdjM1I1YkdVOUltVnVZV0pzWlMxaVlXTnJaM0p2ZFc1a09tNWxkeUF3SURBZ01UQWdNakE3SWlCNGJXdzZjM0JoWTJVOUluQnlaWE5sY25abElqNEtQSE4wZVd4bElIUjVjR1U5SW5SbGVIUXZZM056SWo0S0NTNXpkREI3Wm1sc2JEb2pSamhGUWtZek8zMEtQQzl6ZEhsc1pUNEtQSEJoZEdnZ1kyeGhjM005SW5OME1DSWdaRDBpVFRJdU5EazNNREl4TERrdU9UZzRPREEzWXpBc05DNHhOREl4TlRFc015NHpOVGM0TkRrc055NDFNREF3TURFc055NDFMRGN1TlRBd01EQXhkaTB4TlFvSlF6VXVPRFUwT0Rjc01pNDBPRGc0TURjc01pNDBPVGN3TWpFc05TNDRORFkyTlRZc01pNDBPVGN3TWpFc09TNDVPRGc0TURkNklpOCtDand2YzNablBnbz1cXFwiKSBzcGFjZTtcXHJcXG5iYWNrZ3JvdW5kLXNpemU6IDEzcHggMjZweDtcXHJcXG5ib3R0b206IDA7XFxyXFxuY29udGVudDogJyc7XFxyXFxuZGlzcGxheTogYmxvY2s7XFxyXFxuaGVpZ2h0OiAxMDAlO1xcclxcbnBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG5yaWdodDogMDtcXHJcXG50b3A6IDA7XFxyXFxud2lkdGg6IDEzcHg7XFxyXFxufVxcclxcbi5jcm8gLmJhbm5lciAuYmFubmVyLWNvbHVtbjpmaXJzdC1jaGlsZCB7IG1hcmdpbi1sZWZ0OiAxMHB4OyB9XFxyXFxuLmNybyAuYmFubmVyIC5iYW5uZXItY29sdW1uOmxhc3QtY2hpbGQgeyAgbWFyZ2luLXJpZ2h0OiAxMHB4OyB9XFxyXFxuLmNybyAuYmFubmVyIC5iYW5uZXItY29sdW1uIHsgcGFkZGluZzogMTBweDsgfVxcclxcbi5jcm8gLmJhbm5lciAuYmFubmVyLWNvbHVtbiAuZG93bmxvYWQge1xcclxcbiAgZm9udC1zaXplOiAxMnB4O1xcclxcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXHJcXG4gIGJhY2tncm91bmQ6ICNGOEVCRjM7XFxyXFxuICBmb250LXdlaWdodDogYm9sZDtcXHJcXG4gIGNvbG9yOiByZ2JhKDE2MCw0MSwxMTMsMSk7XFxyXFxuICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcclxcbiAgbWFyZ2luOiAxMHB4IDEwcHggMTBweCAwO1xcclxcbiAgYm9yZGVyLXJhZGl1czogNnJlbTtcXHJcXG4gIHdpZHRoOiAxMDBweDtcXHJcXG4gIGxpbmUtaGVpZ2h0OiAxLjRyZW07XFxyXFxuICBwYWRkaW5nLWJvdHRvbTogMTBweDtcXHJcXG59XFxyXFxuLmNybyAuYmFubmVyIC5iYW5uZXItY29sdW1uIC5kb3dubG9hZC5pcy11c2VkIHtcXHJcXG4gIGJhY2tncm91bmQ6ICNEREU5QkY7XFxyXFxuICBjb2xvcjogIzhEQjcyQztcXHJcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcbiAgdHJhbnNpdGlvbjogd2lkdGggLjJzIGVhc2UsIGNvbG9yIC4ycyAyNTBtcyBlYXNlLCBiYWNrZ3JvdW5kIC4ycyBlYXNlXFxyXFxufVxcclxcbi5jcm8gLmJhbm5lciAuYmFubmVyLWNvbHVtbiBoMSB7IGZvbnQtc2l6ZTogMS42cmVtOyB3b3JkLWJyZWFrOiBicmVhay1hbGw7fVxcclxcbi5jcm8gLmJhbm5lciAuYmFubmVyLWNvbHVtbiBzcGFuIHtcXHJcXG4gIGNvbG9yOiAjRUIxRjA3O1xcclxcbiAgZm9udC1mYW1pbHk6IGljYXJ1YnJpaztcXHJcXG4gIGZvbnQtc2l6ZTogMi4ycmVtO1xcclxcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxyXFxufVxcclxcbi5jcm8gLmJhbm5lciAuYmFubmVyLWNvbHVtbiBwIHtcXHJcXG4gIGNvbG9yOiAjODA4MjgzO1xcclxcbiAgZm9udC1zaXplOiAxLjNyZW07XFxyXFxuICBtYXJnaW46IDA7XFxyXFxufVxcclxcbi8qcmdiYSgxNDEsMTgzLDQ0LDEpKi9cXHJcXG4uY3JvIC5iYW5uZXIgLmJhbm5lci1jb2x1bW4gaDEuaXMtdXNlZCxcXHJcXG4uY3JvIC5iYW5uZXIgLmJhbm5lci1jb2x1bW4gc3Bhbi5pcy11c2VkLFxcclxcbi5jcm8gLmJhbm5lciAuYmFubmVyLWNvbHVtbiBwLmlzLXVzZWQgeyBjb2xvcjogI0Q1RDdEQTsgfVxcclxcbi5jcm8gLmJhbm5lciAuYmFubmVyLWNvbHVtbiAuYmFubmVyLWNvbHVtbl9fbW9yZS1pbmZvIHsgZm9udC1zaXplOiAyMHB4OyB9XFxyXFxuLmNybyAuYmFubmVyLWNvbHVtbl9faW1hZ2Uge1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXHJcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG4gIHdpZHRoOiAxNTBweDtcXHJcXG4gIGhlaWdodDogMTUwcHg7XFxyXFxufVxcclxcbi5jcm8gLmJhbm5lci1jb2x1bW5fX2ltYWdlIGltZyB7XFxyXFxuICBtYXgtd2lkdGg6IDEwMCU7XFxyXFxuICBtYXgtaGVpZ2h0OiAxMDAlO1xcclxcbiAgd2lkdGg6IGF1dG87XFxyXFxuICBoZWlnaHQ6IGF1dG87XFxyXFxufVxcclxcbi5jcm8gLmJhbm5lci1jb2x1bW5fX2ltYWdlIGltZy5pcy11c2VkIHtcXHJcXG4gIG9wYWNpdHk6IC4zO1xcclxcbn1cXHJcXG5AbWVkaWEgb25seSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDc4MHB4KXtcXHJcXG4gIC5jcm8gLmJhbm5lci1jb2x1bW5fX2ltYWdlIHtcXHJcXG4gICAgd2lkdGg6IDY1cHg7XFxyXFxuICAgIGhlaWdodDogNjVweDtcXHJcXG4gIH1cXHJcXG4gICNwYWdlIHtcXHJcXG4gICAgcGFkZGluZzogMCA1cHggNXB4O1xcclxcbiAgfVxcclxcbiAgLmNybyAuYmFubmVyIC5iYW5uZXItY29sdW1uOmZpcnN0LWNoaWxkIHsgcGFkZGluZzogMTBweDsgbWFyZ2luLWxlZnQ6IDA7IH1cXHJcXG4gIC5jcm8gLmJhbm5lciAuYmFubmVyLWNvbHVtbjpsYXN0LWNoaWxkIHsgcGFkZGluZzogMTBweCAxMHB4IDEwcHggMDsgbWFyZ2luLXJpZ2h0OiAwOyB9XFxyXFxuICAuY3JvIC5iYW5uZXIgLmJhbm5lci1jb2x1bW4geyBwYWRkaW5nOiAxMHB4IDA7IH1cXHJcXG59XFxyXFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlciEuL3NyYy9zdGFydC1wYWdlL2NvdXBvbnMtc3R5bGUuY3NzXG4vLyBtb2R1bGUgaWQgPSAxMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vKipcbiAqIFdoZW4gc291cmNlIG1hcHMgYXJlIGVuYWJsZWQsIGBzdHlsZS1sb2FkZXJgIHVzZXMgYSBsaW5rIGVsZW1lbnQgd2l0aCBhIGRhdGEtdXJpIHRvXG4gKiBlbWJlZCB0aGUgY3NzIG9uIHRoZSBwYWdlLiBUaGlzIGJyZWFrcyBhbGwgcmVsYXRpdmUgdXJscyBiZWNhdXNlIG5vdyB0aGV5IGFyZSByZWxhdGl2ZSB0byBhXG4gKiBidW5kbGUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBwYWdlLlxuICpcbiAqIE9uZSBzb2x1dGlvbiBpcyB0byBvbmx5IHVzZSBmdWxsIHVybHMsIGJ1dCB0aGF0IG1heSBiZSBpbXBvc3NpYmxlLlxuICpcbiAqIEluc3RlYWQsIHRoaXMgZnVuY3Rpb24gXCJmaXhlc1wiIHRoZSByZWxhdGl2ZSB1cmxzIHRvIGJlIGFic29sdXRlIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBwYWdlIGxvY2F0aW9uLlxuICpcbiAqIEEgcnVkaW1lbnRhcnkgdGVzdCBzdWl0ZSBpcyBsb2NhdGVkIGF0IGB0ZXN0L2ZpeFVybHMuanNgIGFuZCBjYW4gYmUgcnVuIHZpYSB0aGUgYG5wbSB0ZXN0YCBjb21tYW5kLlxuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3MpIHtcbiAgLy8gZ2V0IGN1cnJlbnQgbG9jYXRpb25cbiAgdmFyIGxvY2F0aW9uID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubG9jYXRpb247XG5cbiAgaWYgKCFsb2NhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImZpeFVybHMgcmVxdWlyZXMgd2luZG93LmxvY2F0aW9uXCIpO1xuICB9XG5cblx0Ly8gYmxhbmsgb3IgbnVsbD9cblx0aWYgKCFjc3MgfHwgdHlwZW9mIGNzcyAhPT0gXCJzdHJpbmdcIikge1xuXHQgIHJldHVybiBjc3M7XG4gIH1cblxuICB2YXIgYmFzZVVybCA9IGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgbG9jYXRpb24uaG9zdDtcbiAgdmFyIGN1cnJlbnREaXIgPSBiYXNlVXJsICsgbG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvXFwvW15cXC9dKiQvLCBcIi9cIik7XG5cblx0Ly8gY29udmVydCBlYWNoIHVybCguLi4pXG5cdC8qXG5cdFRoaXMgcmVndWxhciBleHByZXNzaW9uIGlzIGp1c3QgYSB3YXkgdG8gcmVjdXJzaXZlbHkgbWF0Y2ggYnJhY2tldHMgd2l0aGluXG5cdGEgc3RyaW5nLlxuXG5cdCAvdXJsXFxzKlxcKCAgPSBNYXRjaCBvbiB0aGUgd29yZCBcInVybFwiIHdpdGggYW55IHdoaXRlc3BhY2UgYWZ0ZXIgaXQgYW5kIHRoZW4gYSBwYXJlbnNcblx0ICAgKCAgPSBTdGFydCBhIGNhcHR1cmluZyBncm91cFxuXHQgICAgICg/OiAgPSBTdGFydCBhIG5vbi1jYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAgICAgW14pKF0gID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICg/OiAgPSBTdGFydCBhbm90aGVyIG5vbi1jYXB0dXJpbmcgZ3JvdXBzXG5cdCAgICAgICAgICAgICAgICAgW14pKF0rICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgICAgICBbXikoXSogID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgXFwpICA9IE1hdGNoIGEgZW5kIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICApICA9IEVuZCBHcm91cFxuICAgICAgICAgICAgICAqXFwpID0gTWF0Y2ggYW55dGhpbmcgYW5kIHRoZW4gYSBjbG9zZSBwYXJlbnNcbiAgICAgICAgICApICA9IENsb3NlIG5vbi1jYXB0dXJpbmcgZ3JvdXBcbiAgICAgICAgICAqICA9IE1hdGNoIGFueXRoaW5nXG4gICAgICAgKSAgPSBDbG9zZSBjYXB0dXJpbmcgZ3JvdXBcblx0IFxcKSAgPSBNYXRjaCBhIGNsb3NlIHBhcmVuc1xuXG5cdCAvZ2kgID0gR2V0IGFsbCBtYXRjaGVzLCBub3QgdGhlIGZpcnN0LiAgQmUgY2FzZSBpbnNlbnNpdGl2ZS5cblx0ICovXG5cdHZhciBmaXhlZENzcyA9IGNzcy5yZXBsYWNlKC91cmxcXHMqXFwoKCg/OlteKShdfFxcKCg/OlteKShdK3xcXChbXikoXSpcXCkpKlxcKSkqKVxcKS9naSwgZnVuY3Rpb24oZnVsbE1hdGNoLCBvcmlnVXJsKSB7XG5cdFx0Ly8gc3RyaXAgcXVvdGVzIChpZiB0aGV5IGV4aXN0KVxuXHRcdHZhciB1bnF1b3RlZE9yaWdVcmwgPSBvcmlnVXJsXG5cdFx0XHQudHJpbSgpXG5cdFx0XHQucmVwbGFjZSgvXlwiKC4qKVwiJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KVxuXHRcdFx0LnJlcGxhY2UoL14nKC4qKSckLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pO1xuXG5cdFx0Ly8gYWxyZWFkeSBhIGZ1bGwgdXJsPyBubyBjaGFuZ2Vcblx0XHRpZiAoL14oI3xkYXRhOnxodHRwOlxcL1xcL3xodHRwczpcXC9cXC98ZmlsZTpcXC9cXC9cXC8pL2kudGVzdCh1bnF1b3RlZE9yaWdVcmwpKSB7XG5cdFx0ICByZXR1cm4gZnVsbE1hdGNoO1xuXHRcdH1cblxuXHRcdC8vIGNvbnZlcnQgdGhlIHVybCB0byBhIGZ1bGwgdXJsXG5cdFx0dmFyIG5ld1VybDtcblxuXHRcdGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi8vXCIpID09PSAwKSB7XG5cdFx0ICBcdC8vVE9ETzogc2hvdWxkIHdlIGFkZCBwcm90b2NvbD9cblx0XHRcdG5ld1VybCA9IHVucXVvdGVkT3JpZ1VybDtcblx0XHR9IGVsc2UgaWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiL1wiKSA9PT0gMCkge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJhc2UgdXJsXG5cdFx0XHRuZXdVcmwgPSBiYXNlVXJsICsgdW5xdW90ZWRPcmlnVXJsOyAvLyBhbHJlYWR5IHN0YXJ0cyB3aXRoICcvJ1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byBjdXJyZW50IGRpcmVjdG9yeVxuXHRcdFx0bmV3VXJsID0gY3VycmVudERpciArIHVucXVvdGVkT3JpZ1VybC5yZXBsYWNlKC9eXFwuXFwvLywgXCJcIik7IC8vIFN0cmlwIGxlYWRpbmcgJy4vJ1xuXHRcdH1cblxuXHRcdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgdXJsKC4uLilcblx0XHRyZXR1cm4gXCJ1cmwoXCIgKyBKU09OLnN0cmluZ2lmeShuZXdVcmwpICsgXCIpXCI7XG5cdH0pO1xuXG5cdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgY3NzXG5cdHJldHVybiBmaXhlZENzcztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL3VybHMuanNcbi8vIG1vZHVsZSBpZCA9IDExNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9zdHlsZS5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge1wiaG1yXCI6dHJ1ZX1cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vc3R5bGUuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL3N0eWxlLmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvc3RhcnQtcGFnZS9zdHlsZS5jc3Ncbi8vIG1vZHVsZSBpZCA9IDExNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHVuZGVmaW5lZCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIvKi5jcm8gaGVhZGVyIC5pbWFnZS1zbGlkZXIge1xcclxcbiAgcG9zaXRpb246IGFic29sdXRlICFpbXBvcnRhbnQ7XFxyXFxufSovXFxyXFxuXFxyXFxuLypcXHJcXG5iYWNrZ3JvdW5kLXBvc2l0aW9uOiAtMzM4cHggLTE4ODVweDsgcHJldlxcclxcblxcclxcblxcclxcbmJhY2tncm91bmQtcG9zaXRpb246IC00MzhweCAtMTg4NXB4O1xcclxcbiAqL1xcclxcblxcclxcbi5jcm8gI2hlYWRlciB7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcXHJcXG59XFxyXFxuXFxyXFxuLnNsaWNrLXNsaWRlLCAuc2xpY2stdHJhY2s6Zm9jdXMge1xcclxcbiAgb3V0bGluZTogbm9uZTtcXHJcXG59XFxyXFxuLnN0YXJ0LXBhZ2UtaWNhc2UgI2hlYWRlciB7XFxyXFxuICBoZWlnaHQ6IDEwMCU7XFxyXFxufVxcclxcbi5jb3Vwb24tYmFubmVyIHtcXHJcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG4gIG1hcmdpbi1ib3R0b206IDMwcHg7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjRjhFQkYzO1xcclxcbn1cXHJcXG4uY291cG9uLWJhbm5lciBpbWcge1xcclxcbiAgbWFyZ2luOiAxMHB4IDAgMDtcXHJcXG59XFxyXFxuLmNybyAuc2VhcmNoLXJlY2lwZS1jb250YWluZXIge1xcclxcbiAgbWFyZ2luLWJvdHRvbTogMjBweDtcXHJcXG59XFxyXFxuLmNybyAuc2VhcmNoLXJlY2lwZS1jb250YWluZXIgaW1nIHtcXHJcXG4gIG1hcmdpbi1ib3R0b206IDIwcHg7XFxyXFxufVxcclxcbi5jcm8gLnNlYXJjaC1yZWNpcGUtY29udGFpbmVyIGgxLCAuY291cG9uLWJhbm5lciBoMSB7XFxyXFxuICBmb250LXNpemU6IDIuOHJlbTtcXHJcXG59XFxyXFxuLmNybyAuc2VhcmNoLXJlY2lwZS1jb250YWluZXJfX2FsbC1yZWNpcGVzIHtcXHJcXG4gIGZvbnQtc2l6ZTogMi4ycmVtO1xcclxcbn1cXHJcXG4uY3JvIC5wbCAuY29udGFpbmVyLWJhY2tkcm9wIHtcXHJcXG4gIHBhZGRpbmc6IDE1cHggMTBweCAzMHB4O1xcclxcbn1cXHJcXG5cXHJcXG4uc2xpY2stcHJldjpiZWZvcmUsIC5zbGljay1uZXh0OmJlZm9yZSB7IGNvbnRlbnQ6ICcnIH1cXHJcXG4uc2xpY2stcHJldiB7XFxyXFxuICB0b3A6IDE3MHB4O1xcclxcbiAgbGVmdDogLTEwcHg7XFxyXFxuICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtMzM4cHggLTE4ODVweDtcXHJcXG4gIHdpZHRoOiA1MHB4ICFpbXBvcnRhbnQ7XFxyXFxuICBoZWlnaHQ6IDUwcHggIWltcG9ydGFudDtcXHJcXG59XFxyXFxuLnNsaWNrLW5leHQge1xcclxcbiAgdG9wOiAxNzBweDtcXHJcXG4gIHJpZ2h0OiAtMTBweDtcXHJcXG4gIGJhY2tncm91bmQtcG9zaXRpb246IC00MzhweCAtMTg4NXB4O1xcclxcbiAgd2lkdGg6IDUwcHggIWltcG9ydGFudDtcXHJcXG4gIGhlaWdodDogNTBweCAhaW1wb3J0YW50O1xcclxcbn1cXHJcXG5cXHJcXG4uY3JvIC5zbGljay1wcmV2OmhvdmVyLFxcclxcbi5jcm8gLnNsaWNrLXByZXY6Zm9jdXMsXFxyXFxuLmNybyAuc2xpY2stcHJldjphY3RpdmUge1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxyXFxuICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtMzM4cHggLTE4ODVweDtcXHJcXG59XFxyXFxuLmNybyAuc2xpY2stbmV4dDpob3ZlcixcXHJcXG4uY3JvIC5zbGljay1uZXh0OmZvY3VzLFxcclxcbi5jcm8gLnNsaWNrLW5leHQ6YWN0aXZlIHtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcclxcbiAgYmFja2dyb3VuZC1wb3NpdGlvbjogLTQzOHB4IC0xODg1cHg7XFxyXFxufVxcclxcbi5jcm8gLnNsaWNrLWFycm93IHtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcclxcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCcvVGVtcGxhdGVzL0dlbmVyYWwvVmlld3MvSW1hZ2VzL1JXRC9zcHJpdGVzL2dlbmVyYWxfc3ByaXRlMS5wbmc/MScpO1xcclxcbiAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXHJcXG59XFxyXFxuYnV0dG9uOmZvY3VzLCBidXR0b246YWN0aXZlIHtvdXRsaW5lOjA7fVxcclxcbi5zbGljay1pbml0aWFsaXplZCAuc2xpY2stc2xpZGVyIHtcXHJcXG4gIG91dGxpbmU6IG5vbmU7XFxyXFxufVxcclxcbi5jcm8gLmJhbm5lci1jb250YWluZXIge1xcclxcbiAgd2lkdGg6IDEwMCU7XFxyXFxuICBoZWlnaHQ6IDEwMCU7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcXHJcXG4gIHotaW5kZXg6IDIwICFpbXBvcnRhbnQ7XFxyXFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxyXFxufVxcclxcblxcclxcbi5jcm8gLmJhbm5lci1jb250YWluZXJfX2ltZyB7XFxyXFxuICB3aWR0aDogaW5oZXJpdDtcXHJcXG4gIGhlaWdodDogMzIwcHg7XFxyXFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICB0b3A6IDA7XFxyXFxuICBvdmVyZmxvdzogaGlkZGVuO1xcclxcbn1cXHJcXG5cXHJcXG4uY3JvIC5iYW5uZXItY29udGFpbmVyX19pbWcgaW1nIHsgaGVpZ2h0OiBhdXRvOyB3aWR0aDogMTAwJTsgfVxcclxcblxcclxcbi5jcm8gLmJhbm5lci1jb250YWluZXJfX3RleHQtY29udGFpbmVyIHtcXHJcXG4gIG1heC13aWR0aDogMTAwJTtcXHJcXG4gIG1hcmdpbjogMTEwcHggMzVweCAxMHB4O1xcclxcbiAgdGV4dC1zaGFkb3c6IDAgMCA1cHggcmdiYSgwLCAwLCAwLCAwLjQpO1xcclxcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcclxcbn1cXHJcXG5cXHJcXG4uY3JvIC50ZXh0LWNvbnRhaW5lcl9fdGl0bGUge1xcclxcbiAgZm9udC1zaXplOiAzNnB4O1xcclxcbiAgY29sb3I6IHdoaXRlO1xcclxcbiAgZm9udC1mYW1pbHk6IGljYXJ1YnJpaztcXHJcXG4gIGZvbnQtd2VpZ2h0OiA2MDA7XFxyXFxuICBsaW5lLWhlaWdodDogM3JlbTtcXHJcXG4gIHdoaXRlLXNwYWNlOiBub3JtYWw7XFxyXFxufVxcclxcblxcclxcbi5jcm8gLnRleHQtY29udGFpbmVyX19yYXRpbmdzIHN2ZyAuYWN0aXZlIHtcXHJcXG4gIGZpbGw6ICNFQjFGMDc7XFxyXFxufVxcclxcblxcclxcbi5jcm8gLnRleHQtY29udGFpbmVyX19yYXRpbmdzIHN2ZyB7XFxyXFxuICAvKmRpc3BsYXk6IGlubGluZS1ibG9jazsqL1xcclxcbiAgZGlzcGxheTogYmxvY2s7XFxyXFxuICBmaWxsOiAjRDVEN0RBO1xcclxcbiAgaGVpZ2h0OiAxOHB4O1xcclxcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXHJcXG4gIHdpZHRoOiA5MXB4O1xcclxcbiAgLXdlYmtpdC1maWx0ZXI6IGRyb3Atc2hhZG93KCAxcHggMXB4IDJweCByZ2JhKDAsMCwwLDAuNCkgKTtcXHJcXG4gIGZpbHRlcjogZHJvcC1zaGFkb3coIDFweCAxcHggMnB4IHJnYmEoMCwwLDAsMC40KSApO1xcclxcbn1cXHJcXG5cXHJcXG4uY3JvIC50ZXh0LWNvbnRhaW5lcl9fZGlmZmljdWx0eSB7XFxyXFxuICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xcclxcbiAgZm9udDogMTZweCBpY2F0ZXh0O1xcclxcbiAgZm9udC13ZWlnaHQ6IDkwMDtcXHJcXG4gIG1hcmdpbi10b3A6IDZweDtcXHJcXG4gIGNvbG9yOiB3aGl0ZTtcXHJcXG59XFxyXFxuXFxyXFxuLmNybyAuY291cG9ucy1jb250YWluZXIge1xcclxcbiAgd2lkdGg6IDEwMCU7XFxyXFxuICB6LWluZGV4OiA5OTk7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgZmxleC1kaXJlY3Rpb246IHJvdztcXHJcXG4gIHBhZGRpbmc6IDVweDtcXHJcXG4gIC8qbWFyZ2luLWJvdHRvbTogMjBweDsqL1xcclxcbn1cXHJcXG5cXHJcXG4uY3JvIC5jb3Vwb25zLWNvbnRhaW5lcl9faXRlbSB7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcXHJcXG4gIHdpZHRoOiA1MCU7XFxyXFxuICBtYXJnaW46IDAgNHB4O1xcclxcbiAgcGFkZGluZzogMTBweDtcXHJcXG4gIGJvcmRlcjogOHB4IHNvbGlkIHJnYmEoMjE3LDIwLDk5LDAuMSk7XFxyXFxuICBib3JkZXItYm90dG9tLXdpZHRoOiAxN3B4O1xcclxcbiAgYm9yZGVyLXJhZGl1czogNnB4O1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxyXFxuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxyXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxufVxcclxcblxcclxcbi5jcm8gLmNvdXBvbnMtY29udGFpbmVyX19pdGVtOmFmdGVyIHtcXHJcXG4gIGJhY2tncm91bmQ6IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBEOTRiV3dnZG1WeWMybHZiajBpTVM0d0lpQmxibU52WkdsdVp6MGlkWFJtTFRnaVB6NDhjM1puSUhabGNuTnBiMjQ5SWpFdU1TSWdhV1E5SWt4aGVXVnlYekVpSUhodGJHNXpQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh5TURBd0wzTjJaeUlnZUcxc2JuTTZlR3hwYm1zOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6RTVPVGt2ZUd4cGJtc2lJSGc5SWpCd2VDSWdlVDBpTUhCNElpQjJhV1YzUW05NFBTSXdJREFnTWpBZ01UQWlJSE4wZVd4bFBTSmxibUZpYkdVdFltRmphMmR5YjNWdVpEcHVaWGNnTUNBd0lESXdJREV3T3lJZ2VHMXNPbk53WVdObFBTSndjbVZ6WlhKMlpTSStQSE4wZVd4bElIUjVjR1U5SW5SbGVIUXZZM056SWo0dWMzUXdlMlpwYkd3NkkyWm1aanQ5UEM5emRIbHNaVDQ4Y0dGMGFDQmpiR0Z6Y3owaWMzUXdJaUJrUFNKTk1UQXNNaTQxWXkwMExqRXNNQzAzTGpVc015NDBMVGN1TlN3M0xqVm9NVFZETVRjdU5TdzFMamtzTVRRdU1pd3lMalVzTVRBc01pNDFlaUl2UGp3dmMzWm5QZz09KSBzcGFjZTtcXHJcXG4gIGJhY2tncm91bmQtc2l6ZTogMjZweCAxM3B4O1xcclxcbiAgY29udGVudDogJyc7XFxyXFxuICBkaXNwbGF5OiBibG9jaztcXHJcXG4gIHdpZHRoOiAxNDAlO1xcclxcbiAgaGVpZ2h0OiAxM3B4O1xcclxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgYm90dG9tOiAtMTdweDtcXHJcXG4gIGxlZnQ6IC0zMHB4O1xcclxcbn1cXHJcXG5cXHJcXG4uY3JvIC5jb3Vwb25zLWNvbnRhaW5lcl9faXRlbSBpbWcge1xcclxcbiAgd2lkdGg6IDYwJSAhaW1wb3J0YW50O1xcclxcbiAgaGVpZ2h0OiBhdXRvICFpbXBvcnRhbnQ7XFxyXFxuICBtYXJnaW46IDAgYXV0byAhaW1wb3J0YW50O1xcclxcbn1cXHJcXG5cXHJcXG4uY3JvIC5jb3Vwb25zLWNvbnRhaW5lciAuY291cG9ucy1jb250YWluZXJfX2l0ZW0gaDMge1xcclxcbiAgZm9udC1zaXplOiAxNnB4O1xcclxcbiAgbGluZS1oZWlnaHQ6IDEuM2VtO1xcclxcbn1cXHJcXG5cXHJcXG4uY3JvIC5jb3Vwb25zLWNvbnRhaW5lciAuY291cG9ucy1jb250YWluZXJfX2l0ZW0gaDEge1xcclxcbiAgZm9udC1zaXplOiAyMnB4O1xcclxcbiAgZm9udC13ZWlnaHQ6IDcwMDtcXHJcXG4gIGNvbG9yOiAjRUIxRjA3O1xcclxcbiAgbGluZS1oZWlnaHQ6IDE1cHg7XFxyXFxufVxcclxcblxcclxcbi5jcm8gLmNvdXBvbnMtY29udGFpbmVyIC5jb3Vwb25zLWNvbnRhaW5lcl9faXRlbSBoNCB7XFxyXFxuICBjb2xvcjogIzgwODI4MztcXHJcXG4gIGZvbnQtc2l6ZTogMS4zcmVtO1xcclxcbiAgbGluZS1oZWlnaHQ6IDE7XFxyXFxuICBmb250LWZhbWlseTogaWNhdGV4dDtcXHJcXG4gIGZvbnQtd2VpZ2h0OiBub3JtYWw7XFxyXFxufVxcclxcblxcclxcbi5jcm8gLmNvdXBvbnMtY29udGFpbmVyIC5jb3Vwb25zLWNvbnRhaW5lcl9faXRlbSBhIHtcXHJcXG4gIGZvbnQtc2l6ZTogMTRweDtcXHJcXG4gIGxpbmUtaGVpZ2h0OiAxNXB4O1xcclxcbiAgbWFyZ2luLWJvdHRvbTogNXB4O1xcclxcbn1cXHJcXG5cXHJcXG4uY3JvIC5jb3Vwb25zLWNvbnRhaW5lciAuY291cG9ucy1jb250YWluZXJfX2l0ZW0gLmNvdXBvbi1idXR0b24ge1xcclxcbiAgZm9udC1zaXplOiAxMnB4O1xcclxcbiAgbGluZS1oZWlnaHQ6IDIuMnJlbTtcXHJcXG4gIG1pbi13aWR0aDogYXV0bztcXHJcXG4gIGFsaWduLXNlbGY6IGNlbnRlcjtcXHJcXG4gIHdpZHRoOiAxMDAlO1xcclxcbiAgYmFja2dyb3VuZDogI0Y4RUJGMztcXHJcXG4gIGNvbG9yOiAjQTAyOTcxO1xcclxcbn1cXHJcXG5cXHJcXG4uY3JvIC5jb3Vwb25zLWNvbnRhaW5lciAuY291cG9ucy1jb250YWluZXJfX2l0ZW0ub2ZmZXItbG9hZGVkIC5jb3Vwb24tYnV0dG9uIHtcXHJcXG4gIGJhY2tncm91bmQ6ICNEREU5QkY7XFxyXFxuICBjb2xvcjogIzhEQjcyQztcXHJcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcbiAgdHJhbnNpdGlvbjogd2lkdGggLjJzIGVhc2UsIGNvbG9yIC4ycyAyNTBtcyBlYXNlLCBiYWNrZ3JvdW5kIC4ycyBlYXNlO1xcclxcbn1cXHJcXG5cXHJcXG4uY3JvIC5jb3Vwb25zLWNvbnRhaW5lciAuY291cG9ucy1jb250YWluZXJfX2l0ZW0gLmNvdXBvbnMtaW1hZ2Uge1xcclxcbiAgd2lkdGg6IDEwMCU7XFxyXFxuICBoZWlnaHQ6IDYwcHg7XFxyXFxuICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcclxcbiAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xcclxcbiAgYmFja2dyb3VuZC1wb3NpdGlvbjogY2VudGVyO1xcclxcbn1cXHJcXG5cXHJcXG4uY3JvIC5iYW5uZXItd3JhcHBlciAuYmFubmVyLWltYWdlIGltZyB7XFxyXFxuICB3aWR0aDogMTAwJTtcXHJcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG4gIG1hcmdpbi1sZWZ0OiAwICFpbXBvcnRhbnQ7XFxyXFxuICBoZWlnaHQ6IGF1dG8gIWltcG9ydGFudDtcXHJcXG4gIG1hcmdpbi10b3A6IDAgIWltcG9ydGFudDtcXHJcXG4gIG1pbi13aWR0aDogMzc1cHg7XFxyXFxufVxcclxcblxcclxcbi5jcm8gLmJ1dHRvbi13cmFwcGVyIHtcXHJcXG4gIG1hcmdpbjogMTBweDtcXHJcXG59XFxyXFxuXFxyXFxuLmNybyAuYmFubmVyLWJ1dHRvbiB7XFxyXFxuICB3aWR0aDogMTAwJTtcXHJcXG4gIGRpc3BsYXk6IGJsb2NrO1xcclxcbn1cXHJcXG4uY3JvIC5iYW5uZXItYnV0dG9uLnNhdmVkIHtcXHJcXG4gIGJhY2tncm91bmQ6ICNEREU5QkY7XFxyXFxuICBjb2xvcjogIzhEQjcyQztcXHJcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcbiAgdHJhbnNpdGlvbjogd2lkdGggLjJzIGVhc2UsIGNvbG9yIC4ycyAyNTBtcyBlYXNlLCBiYWNrZ3JvdW5kIC4ycyBlYXNlO1xcclxcbiAgZm9udC13ZWlnaHQ6IDQwMDtcXHJcXG59XFxyXFxuXFxyXFxuLmNybyAub2ZmZXJzLWJ1dHRvbiB7XFxyXFxuICB3aWR0aDogOTAlO1xcclxcbiAgbWFyZ2luLWJvdHRvbTogMjBweDtcXHJcXG59XFxyXFxuXFxyXFxuLmNybyAucmF0aW5nLXN0YXItY29udGFpbmVyIHtcXHJcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gIHotaW5kZXg6IDUwO1xcclxcbiAgbWFyZ2luOjEwcHg7XFxyXFxuICB0b3A6IDMwcHg7XFxyXFxuICBjb2xvcjogd2hpdGU7XFxyXFxuICB0ZXh0LXNoYWRvdzogMCAwIDVweCByZ2JhKDAsIDAsIDAsIDAuNCk7XFxyXFxufVxcclxcblxcclxcbi5jcm8gLmljYS1jYXJkLWNvbnRhaW5lciB7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG4gIG1pbi1oZWlnaHQ6IDI1MHB4O1xcclxcbn1cXHJcXG5cXHJcXG4uY3JvIC5pY2EtY2FyZC1jb250YWluZXIgaDEge1xcclxcbiAgY29sb3I6ICNFQjFGMDc7XFxyXFxufVxcclxcblxcclxcbi5jcm8gLmljYS1jYXJkLWNvbnRhaW5lciBhIHtcXHJcXG4gIGFsaWduLXNlbGY6IGZsZXgtc3RhcnQ7XFxyXFxuICBtYXgtd2lkdGg6IDI1MHB4O1xcclxcbiAgbWFyZ2luLXRvcDotMTYwcHg7XFxyXFxufVxcclxcblxcclxcbi5jcm8gLmljYS1jYXJkLWNvbnRhaW5lciBpbWcge1xcclxcbiAgbWF4LXdpZHRoOiAzODVweDtcXHJcXG4gIHdpZHRoOiA4MCU7XFxyXFxuICBhbGlnbi1zZWxmOiBmbGV4LWVuZDtcXHJcXG4gIG1hcmdpbi10b3A6LTEyMHB4O1xcclxcbn1cXHJcXG5cXHJcXG5AbWVkaWEgb25seSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDk2MHB4KXtcXHJcXG4gIC5jcm8gLmljYS1jYXJkLWNvbnRhaW5lciB7XFxyXFxuICAgIG1pbi1oZWlnaHQ6IG5vbmU7XFxyXFxuICB9XFxyXFxuXFxyXFxuICAuY3JvIC5pY2EtY2FyZC1jb250YWluZXIgaDEge1xcclxcbiAgICBsaW5lLWhlaWdodDogM3JlbTtcXHJcXG4gICAgZm9udC1zaXplOiAzcmVtO1xcclxcbiAgICBtYXJnaW4tYm90dG9tOiAyMHB4O1xcclxcbiAgfVxcclxcblxcclxcbiAgLmNybyAuaWNhLWNhcmQtY29udGFpbmVyIGEge1xcclxcbiAgICBhbGlnbi1zZWxmOiBjZW50ZXI7XFxyXFxuICAgIG1hcmdpbi10b3A6IDIwcHg7XFxyXFxuICAgIG1heC13aWR0aDogbm9uZTtcXHJcXG4gICAgd2lkdGg6IDEwMCU7XFxyXFxuICB9XFxyXFxuXFxyXFxuICAuY3JvIC5pY2EtY2FyZC1jb250YWluZXIgaW1nIHtcXHJcXG4gICAgYWxpZ24tc2VsZjogY2VudGVyO1xcclxcbiAgICBtYXJnaW4tdG9wOmF1dG87XFxyXFxuICB9XFxyXFxuXFxyXFxuICAuY3JvIC5vZmZlcnMtY29udGFpbmVyIHtcXHJcXG4gICAgd2lkdGg6IDEwMCU7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcclxcbiAgICAtd2Via2l0LWZpbHRlcjogZHJvcC1zaGFkb3coIDFweCAxcHggMnB4IHJnYmEoMCwwLDAsMC40KSApO1xcclxcbiAgICBmaWx0ZXI6IGRyb3Atc2hhZG93KCAxcHggMXB4IDJweCByZ2JhKDAsMCwwLDAuNCkgKTtcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIC5zdGFydC1wYWdlLWljYXNlID4gaGVhZGVyLmZ1bGwtc2l6ZS1pbWFnZSAuaW1hZ2Utc2xpZGVyLFxcclxcbiAgLnN0YXJ0LXBhZ2UtaWNhc2UgPiBoZWFkZXIuZnVsbC1zaXplLWltYWdlIC5pbWFnZS1zbGlkZXIgdWwsXFxyXFxuICAuc3RhcnQtcGFnZS1pY2FzZSA+IGhlYWRlci5mdWxsLXNpemUtaW1hZ2UgLmltYWdlLXNsaWRlciBsaSB7XFxyXFxuICAgIG1heC1oZWlnaHQ6IDEwMCU7XFxyXFxuICAgIHdpZHRoOiAxMDAlICFpbXBvcnRhbnQ7XFxyXFxuICAgIGhlaWdodDogMTAwJSAhaW1wb3J0YW50O1xcclxcbiAgfVxcclxcbn1cXHJcXG4uY3JvIC51bnNsaWRlci1jb250cm9scyB7IHBvaW50ZXItZXZlbnRzOiBub25lOyB9XFxyXFxuLmNybyAudW5zbGlkZXItYXJyb3cgeyBwb2ludGVyLWV2ZW50czogYXV0bzsgfVxcclxcblxcclxcbkBtZWRpYSAobWF4LXdpZHRoOiA3NjdweCkgeyAuY3JvIC5jcm8taWZyYW1lLWNvbnRhaW5lciB7IHBhZGRpbmctYm90dG9tOiAxMzUlICFpbXBvcnRhbnQ7IH0gfVxcclxcbi5jcm8gPiAuY3JvLWlmcmFtZS1jb250YWluZXIgeyBkaXNwbGF5OiBub25lOyB9XFxyXFxuLmNybyAubW9kYWwtY29wbnRhaW5lciAuY3JvLWlmcmFtZS1jb250YWluZXIgeyBkaXNwbGF5OiBpbml0aWFsOyB9XFxyXFxuLmNybyAuY29udGFpbmVyIHsgdGV4dC1hbGlnbjogY2VudGVyOyBtYXJnaW4tdG9wOiA1MHB4O31cXHJcXG4uY3JvIC5jb250YWluZXIgaDIgeyBmb250OiAyOHB4IGljYWhhbmQ7IG1hcmdpbi1ib3R0b206IDIwcHg7IH1cXHJcXG4uY3JvIC5jcm8taWZyYW1lLWNvbnRhaW5lciB7XFxyXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxuICBoZWlnaHQ6IDA7XFxyXFxuICBvdmVyZmxvdzogaGlkZGVuO1xcclxcbiAgcGFkZGluZy1ib3R0b206IDg1JTtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6ICNGM0YwRUI7XFxyXFxufVxcclxcbi5jcm8gLmNyby1pZnJhbWUtY29udGFpbmVyIGlmcmFtZSB7XFxyXFxuICBvcGFjaXR5OiAwO1xcclxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgdG9wOiAwO1xcclxcbiAgbGVmdDogMDtcXHJcXG4gIHdpZHRoOiAxMDAlO1xcclxcbiAgaGVpZ2h0OiAxMDAlO1xcclxcbn1cXHJcXG5cXHJcXG4uY3JvIC51c3AtbGlzdCB7IG1hcmdpbi1ib3R0b206IDEwcHg7IH1cXHJcXG5cXHJcXG4uY3JvIC51c3AtbGlzdCBsaSB7XFxyXFxuICBmb250OiAyNHB4IGljYXJ1YnJpaztcXHJcXG4gIGZvbnQtd2VpZ2h0OiA2MDA7XFxyXFxuICBtYXJnaW4tYm90dG9tOiAxNXB4O1xcclxcbn1cXHJcXG4uY3JvIC51c3AtbGlzdCBzdmcge1xcclxcbiAgZmlsbDogIzhEQjcyQztcXHJcXG4gIG1hcmdpbi1yaWdodDogNXB4O1xcclxcbn1cXHJcXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyIS4vc3JjL3N0YXJ0LXBhZ2Uvc3R5bGUuY3NzXG4vLyBtb2R1bGUgaWQgPSAxMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiY29uc3Qgc3RvcmFnZSA9ICgpID0+IHtcclxuICBjb25zdCBmYWxsQmFjayA9IHtcclxuICAgIHN0b3JhZ2U6IHt9LFxyXG4gICAgc2V0SXRlbShrZXksIHZhbHVlKSB7XHJcbiAgICAgIHRoaXMuc3RvcmFnZVtrZXldID0gdmFsdWU7XHJcbiAgICB9LFxyXG4gICAgZ2V0SXRlbShrZXkpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZVtrZXldO1xyXG4gICAgfSxcclxuICB9O1xyXG4gIGNvbnN0IGNob29zZVN0b3JhZ2UgPSAodHlwZU9mU3RvcmFnZSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKHR5cGVPZlN0b3JhZ2UgaW4gd2luZG93ICYmIHdpbmRvd1t0eXBlT2ZTdG9yYWdlXSAhPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiB3aW5kb3dbdHlwZU9mU3RvcmFnZV07XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZhbGxCYWNrO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgYXBpID0ge1xyXG4gICAgc2V0VXAoc3RvcmFnZU5hbWUsIHR5cGVPZlN0b3JhZ2UpIHtcclxuICAgICAgY29uc3Qgc3RvcmFnZVR5cGUgPSBjaG9vc2VTdG9yYWdlKHR5cGVPZlN0b3JhZ2UpO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHNldChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICBzdG9yYWdlVHlwZS5zZXRJdGVtKHN0b3JhZ2VOYW1lLCBKU09OLnN0cmluZ2lmeSh7IFtrZXldOiB2YWx1ZSB9KSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXQoa2V5KSB7XHJcbiAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShzdG9yYWdlVHlwZS5nZXRJdGVtKHN0b3JhZ2VOYW1lKSlba2V5XTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNsZWFyKCkge1xyXG4gICAgICAgICAgc3RvcmFnZVR5cGUuc2V0SXRlbShzdG9yYWdlTmFtZSwgSlNPTi5zdHJpbmdpZnkoe30pKTtcclxuICAgICAgICB9LFxyXG4gICAgICB9O1xyXG4gICAgfSxcclxuICB9O1xyXG4gIHJldHVybiB7XHJcbiAgICBzZXRVcChzdG9yYWdlTmFtZSA9ICdjcm8tY29va2llJywgdHlwZU9mU3RvcmFnZSA9ICdzZXNzaW9uU3RvcmFnZScpIHtcclxuICAgICAgY29uc3Qgc3RvcmFnZUFwaSA9IGFwaS5zZXRVcChzdG9yYWdlTmFtZSwgdHlwZU9mU3RvcmFnZSk7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgc2V0KGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgIHN0b3JhZ2VBcGkuc2V0KGtleSwgdmFsdWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0KGtleSkge1xyXG4gICAgICAgICAgcmV0dXJuIHN0b3JhZ2VBcGkuZ2V0KGtleSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjbGVhcigpIHtcclxuICAgICAgICAgIHN0b3JhZ2VBcGkuY2xlYXIoKTtcclxuICAgICAgICB9LFxyXG4gICAgICB9O1xyXG4gICAgfSxcclxuICB9O1xyXG59O1xyXG5cclxuY29uc3QgZGIgPSBzdG9yYWdlKCk7XHJcbmV4cG9ydCBkZWZhdWx0IGRiLnNldFVwKCk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy91dGlsL21vZHVsZXMvc3RvcmFnZS5qcyJdLCJzb3VyY2VSb290IjoiIn0=