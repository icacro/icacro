/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _promise = __webpack_require__(44);

var _promise2 = _interopRequireDefault(_promise);

var _stringify = __webpack_require__(59);

var _stringify2 = _interopRequireDefault(_stringify);

var _assign = __webpack_require__(60);

var _assign2 = _interopRequireDefault(_assign);

var _slicedToArray2 = __webpack_require__(62);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _main = __webpack_require__(1);

var _ratings = __webpack_require__(2);

var _ratings2 = _interopRequireDefault(_ratings);

var _banners = __webpack_require__(3);

var _banners2 = _interopRequireDefault(_banners);

var _coupons = __webpack_require__(9);

var _coupons2 = _interopRequireDefault(_coupons);

__webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(function ($) {
  'use strict';

  var LOGIN_ACTION = {
    SAVE_RECIPE: 'SPARA',
    LOAD_COUPON: 'LADDA'
  };
  var ACTION_COOKIES = {
    SAVE_RECIPE: 'cro_startpage_actionCookie_saveRecipe',
    LOAD_COUPON: 'cro_startpage_actionCookie_loadCoupon'
  };
  var loadedCoupons = [];

  // if (hj) hj('trigger','variant5');// eslint-disable-line
  var test = {
    create: function create(className, parent, text, type) {
      var t = type || 'div';
      var div = document.createElement(t);
      if (text && type === 'img') {
        div.src = text;
      } else if (text) {
        div.appendChild(document.createTextNode(text));
      }
      if (className) div.className = className;
      if (parent) parent.appendChild(div);
      return div;
    },
    addCoupon: function addCoupon(coupon) {
      var _this = this;

      var couponItem = _main.$ELM.create('coupons-container__item');
      var img = _main.$ELM.create('img');
      var title = _main.$ELM.create('h3');
      var discount = _main.$ELM.create('h1');
      var subtitle = _main.$ELM.create('h4');
      var moreInfo = _main.$ELM.create('a');
      var button = _main.$ELM.create('button .button coupon-button');

      title.text(coupon.title);
      discount.text(coupon.discount);
      subtitle.text(coupon.subtitle);
      moreInfo.text('Mer info');
      button.text('Ladda kupong');
      img.image(coupon.image);
      moreInfo.href(coupon.url);

      button.click(function () {
        if (_this.isLoggedIn()) {
          _this.loadCouponOnCard(coupon).then(function (response) {
            _this.changeOfferStatus(response, coupon);
          });
        } else {
          icadatalayer.add('HSE', {
            HSE: {
              action: 'login-mousedown',
              name: coupon.PageName,
              hseurl: coupon.url
            }
          });

          var cookieData = {
            PageName: coupon.PageName,
            recipeId: coupon.recipeId,
            title: coupon.PageName,
            url: coupon.PageName,
            OfferId: coupon.Offer,
            CampaignId: coupon.PageName
          };

          _this.setActionCookie(ACTION_COOKIES.LOAD_COUPON, cookieData);
          _this.createModal(LOGIN_ACTION.LOAD_COUPON);
        }
      });

      icadatalayer.add('HSE', {
        HSE: {
          action: 'display',
          title: coupon.PageName,
          hseurl: coupon.url
        }
      });
      couponItem.attr('id', 'coupon-' + coupon.OfferId + '-' + coupon.recipeId);
      this.loadCouponData(coupon).then(function (data) {
        if (data.Offer.LoadedOnCard) {
          couponItem.css('offer-loaded');
          button.text('Kupong laddad');
        }
      });
      couponItem.appendAll(img, title, discount, subtitle, moreInfo, button);
      return couponItem;
    },
    addBanner: function addBanner(banner) {
      var _this2 = this;

      var _$ELM$create = _main.$ELM.create('li banner-container', 'banner-container__img', 'img', 'banner-container__text-container', 'a text-container__link', 'h1 text-container__title', 'text-container__ratings', 'h4 text-container__difficulty', 'coupons-container'),
          _$ELM$create2 = (0, _slicedToArray3.default)(_$ELM$create, 9),
          bannerContainer = _$ELM$create2[0],
          bannerContainerImg = _$ELM$create2[1],
          img = _$ELM$create2[2],
          textContainer = _$ELM$create2[3],
          link = _$ELM$create2[4],
          title = _$ELM$create2[5],
          ratings = _$ELM$create2[6],
          difficulty = _$ELM$create2[7],
          couponsWrapper = _$ELM$create2[8];

      var saveButton = this.createSaveRecipeCTA(banner);

      img.image(banner.image);
      bannerContainerImg.append(img);
      bannerContainerImg.image(banner.image);

      ratings.html((0, _ratings2.default)(banner.stars));
      title.text(banner.title);
      difficulty.text(banner.cookTime);

      banner.coupons.forEach(function (coupon) {
        couponsWrapper.append(_this2.addCoupon(coupon));
      });

      link.href(banner.url);
      link.appendAll(title, ratings, difficulty);
      textContainer.append(link);
      bannerContainer.appendAll(bannerContainerImg, textContainer, saveButton, couponsWrapper);
      return bannerContainer;
    },
    addStyle: function addStyle(element, stl) {
      (0, _assign2.default)(element.style, stl);
    },
    addBanners: function addBanners() {
      var _this3 = this;

      var header = _main.$ELM.get('.header');
      var ul = _main.$ELM.create('ul cro-slider');
      header.html(' ');
      _banners2.default.forEach(function (banner) {
        ul.append(_this3.addBanner(banner));
      });
      header.append(ul);
      // console.log(ul.children('li')[0].height());
      // ul.style({
      //   width: `${100 * banners.length}%`,
      //   // height: `${ul.children('li')[0].height().toString()}px`,
      // });
      $('.cro-slider').slick({
        adaptiveHeight: true
      });
    },
    addIcaCard: function addIcaCard() {
      var self = this;
      var icaImageContainer = self.create('ica-card-container');
      self.create('', icaImageContainer, 'FÃ¥ rabatt med ICA-Kort', 'h1');
      var usps = self.create('usp-list', icaImageContainer, null, 'ul');
      usps.innerHTML = '\n      <li><svg viewBox="0 0 32 32" width="15px" height="15px"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="/Assets/icons/sprite.svg#check"></use></svg> ICA-kort med bonus</li>\n      <li><svg viewBox="0 0 32 32" width="15px" height="15px"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="/Assets/icons/sprite.svg#check"></use></svg> Personliga erbjudanden</li>\n      <li><svg viewBox="0 0 32 32" width="15px" height="15px"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="/Assets/icons/sprite.svg#check"></use></svg> Kortpriser varje vecka</li>\n      ';
      self.create('', icaImageContainer, 'https://www.ica.se/ImageVaultFiles/id_78649/cf_3/ICA_Kort_och_Bank.png', 'img');
      self.create('button', icaImageContainer, 'Skapa konto och bli medlem', 'a').href = '/ansokan/?step=6369766963666f726d';
      document.querySelector('.main').appendChild(icaImageContainer);
    },
    dinnerTonight: function dinnerTonight() {
      var container = _main.$ELM.get('.search-recipe-container');
      var recipeTrendingList = _main.$ELM.get('.recipe-trending-list');
      var img = _main.$ELM.create('img').image('/imagevaultfiles/id_124300/cf_259/nyttiga_recept.jpg');
      var seeAll = _main.$ELM.copy('.search-recipe-container__all-recipes');
      this.removeElements(['.search-recipe-container__all-recipes']);
      recipeTrendingList.append(seeAll);
      container.appendFirst(img);
      container.get('h1').text('Vad blir det fÃ¶r middag ikvÃ¤ll?');
    },
    manipulateDom: function manipulateDom() {
      this.removeElements(['.image-slider li', '.image-slider .lazy-spinner', '.header-content', '.push-items-list', '.quicklink-list', '.main .link-list', '.recipe-category-listing .banner-image', '.recipe-category-listing > .col-12 > h2', '.search-recipe-container__recipe-count', '.recipe-category-listing .recipe-list-items']);
      this.addBanners();
      this.createOffers();
      this.addIcaCard();
      this.dinnerTonight();
      var returnUrl = encodeURIComponent(window.location.href);
      var iframeContainer = $('<div class="cro-iframe-container"><span class="loader"></span><iframe src="//www.ica.se/logga-in/?returnurl=' + returnUrl + '" frameborder="0"></iframe></div>');
      $('body').append(iframeContainer);
    },
    createSaveRecipeCTA: function createSaveRecipeCTA(banner) {
      var _this4 = this;

      var container = _main.$ELM.create('button-wrapper');
      var cta = _main.$ELM.create('a .button banner-button');
      cta.html('<div class="layer"><svg viewBox="0 0 32 32" width="15px" height="15px"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="/Assets/icons/sprite.svg#check"></use></svg></div>LÃ¤gg recept i inkÃ¶pslistan');
      cta.href('#');
      cta.data('recipeId', banner.recipeId);
      cta.data('tracking', '{ "name": "' + banner.title + '", "URL": "' + banner.url + '" }');
      cta.css('js-add-to-new-shoppinglist banner-button-' + banner.recipeId);

      cta.click(function (e) {
        e.preventDefault();
        _this4.addRecipeToShoppingList(banner.recipeId);
        cta.toggle('added');
        _main.$ELM.get('#js-toggle-avatar').css('cro-startpage-shoppinglist-coachmark');
        setTimeout(function () {
          return cta.toggle('added');
        }, 1500);
      });
      container.append(cta);
      return container;
    },
    createOffers: function createOffers() {
      var main = _main.$ELM.get('.main');
      var container = _main.$ELM.create('div coupon-banner');
      var offerButton = _main.$ELM.create('a .button offers-button').text('GÃ¥ till ICAs kuponger').href('/erbjudanden/butikserbjudanden/alla-digitala-kuponger/');
      var img = _main.$ELM.create('img').image('https://raw.githubusercontent.com/Banzaci/ica/master/src/start-page/Coupons_image.png');
      container.appendAll(img, offerButton);
      main.append(container);
    },
    addRecipeToShoppingList: function addRecipeToShoppingList(recipeId) {
      // tracking sker via klassnamn

      ICA.ajax.post('/Templates/Recipes/Handlers/ShoppingListHandler.ashx', {
        recipeIds: [recipeId],
        ShoppingListId: 0,
        numberOfServings: 0,
        recipes: [],
        shoppingListName: createShoppingsListName()
      });

      function createShoppingsListName() {
        var d = new Date();
        var year = d.getFullYear();
        var month = d.getMonth();
        var day = d.getDate();
        var months = { 10: 'nov', 11: 'dec' }; // testet kommer endast ligga ute i nov, senast dec

        return 'Att handla, ' + day + ' ' + months[month] + ' ' + year;
      }
    },
    setActionCookie: function setActionCookie(cookieName, cookieData) {
      // TODO: Flytta till main.js
      var d = new Date();
      d.setDate(new Date().getDate() + 1); // expires tomorrow

      ICA.legacy.setCookie(cookieName, (0, _stringify2.default)(cookieData), d);
    },
    getActionCookie: function getActionCookie(cookieName) {
      // TODO: Flytta till main.js
      var actionCookie = ICA.legacy.getCookie(cookieName);

      if (!actionCookie) {
        return null;
      }

      ICA.legacy.killCookie(cookieName);
      return JSON.parse(actionCookie);
    },
    checkActionCookies: function checkActionCookies() {
      var _this5 = this;

      if (!this.isLoggedIn) return;

      var coupon = this.getActionCookie(ACTION_COOKIES.LOAD_COUPON);
      if (coupon) {
        this.loadCouponOnCard(coupon).then(function (response) {
          _this5.changeOfferStatus(response, coupon);
        });
      }
    },
    changeOfferStatus: function changeOfferStatus(response, coupon) {
      if (response.ok) {
        _main.$ELM.get('#coupon-' + coupon.OfferId + '-' + coupon.recipeId).css('offer-loaded');
        _main.$ELM.get('#coupon-' + coupon.OfferId + '-' + coupon.recipeId + ' .coupon-button').text('Kupong laddad');
      }
    },

    // hotjarTriggered: false,
    loaderIsActive: false,
    buttonHandlerPollTimeout: null,
    showLoader: function showLoader() {
      var container = $('.cro-iframe-container');
      container.find('.loader').show();
      container.find('iframe').css('opacity', '0');
      this.loaderIsActive = true;
    },
    hideLoader: function hideLoader() {
      var container = $('.cro-iframe-container');
      container.find('.loader').hide();
      container.find('iframe').css('opacity', '1');
      this.loaderIsActive = false;
    },
    addButtonHandlerPoll: function addButtonHandlerPoll() {
      var self = this;
      var iframe = $('.cro-iframe-container iframe');
      var e = iframe.contents().find('.remodal-wrapper #grey-card-btn, .remodal-wrapper .pink-card-btn');

      if (e.length) {
        e.click(function () {
          self.showLoader();
        });
        window.clearTimeout(self.buttonHandlerPollTimeout);
      } else {
        self.buttonHandlerPollTimeout = window.setTimeout(self.addButtonHandlerPoll.bind(self), 1000);
      }
    },
    addEventListeners: function addEventListeners() {
      var self = this;

      $('.header').off('mousedown');

      $(window).on('message onmessage', function (e) {
        var origin = window.location.protocol + '//' + window.location.host;
        if (e.originalEvent.origin === origin && /mobilebankid/i.test(e.originalEvent.data)) {
          self.showLoader();
        }
      });
    },
    getIframeStyles: function getIframeStyles() {
      return '<style type="text/css">\n        @media  (max-width: 767px) {\n        h3.greeting, h3.card-heading { font-size: 18px; }\n        img.card-icon { width: 50px; }\n        .select-card-modal { border: 0; padding: 0; margin: 0; }\n        .remodal-wrapper { padding: 0; }\n        }\n        </style>';
    },
    createModal: function createModal() {
      var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : LOGIN_ACTION.SAVE_RECIPE;

      var self = this;
      var modal = new coreComponents.modal({
        tpl: $('.cro-iframe-container').get(0),
        size: 'md',
        container: $('.modal-container').get(0)
      });

      setTimeout(function () {
        self.showLoader();

        var iframe = $('.cro-iframe-container iframe');

        iframe.on('load', function () {
          var regex = new RegExp('^' + window.location.href + '$', 'gi');
          if (regex.test(this.contentWindow.location)) {
            window.location.reload(true);
          }

          if (this.contentWindow.location.href.indexOf('logga-in') !== -1) {
            var _hideHeaderBar = function _hideHeaderBar() {
              var e = $('.cro-iframe-container iframe').contents().find('.header-bar');
              if (e.length) {
                e.hide();
                window.clearTimeout(headerBarTimeout);
                hideHeaderBarDeferred.resolve();
              } else {
                headerBarTimeout = window.setTimeout(_hideHeaderBar, 0);
              }
            };

            var _appendHeader = function _appendHeader() {
              var e = $('.cro-iframe-container iframe').contents().find('h1');
              if (e.length) {
                var message = action === LOGIN_ACTION.SAVE_RECIPE ? ' fÃ¶r att lÃ¤gga till i inkÃ¶pslistan och spara recept' : ' fÃ¶r att ladda kupongen';
                e.append(message);
                e.css({ 'font-family': 'icahand, arial, sans-serif', 'font-size': '3rem' });

                if (window.screen.width < 768) {
                  e.css('font-size', '18px');
                  e.parent().css('margin', '0');
                }
                window.clearTimeout(appendHeaderTimeout);
                appendHeaderDeferred.resolve();
              } else {
                appendHeaderTimeout = window.setTimeout(_appendHeader, 0);
              }
            };

            var _addStyles = function _addStyles() {
              var e = $('.cro-iframe-container iframe').contents().find('body');
              if (e.length) {
                e.append(self.getIframeStyles());
                window.clearTimeout(addStylesTimeout);
                addStylesDeferred.resolve();
              } else {
                addStylesTimeout = window.setTimeout(_addStyles, 0);
              }
            };

            var _addIframeTracking = function _addIframeTracking() {
              var e = $('.cro-iframe-container iframe').contents();
              if (e.length) {
                var eventAction = action === LOGIN_ACTION.SAVE_RECIPE ? 'Spara recept frÃ¥n startsidan' : 'Ladda kupong frÃ¥n startsida';

                // FortsÃ¤tt (Mobilt BankId)
                e.find('#submit-login-mobile-bank-id').on('click', function () {
                  ga('send', 'event', 'A/B', eventAction, 'Logga in - Mobilt BankId');
                });

                // BehÃ¶ver du hjÃ¤lp (Mobilt BankId)
                e.find('.login-support-bank-id-link').on('click', function () {
                  ga('send', 'event', 'A/B', eventAction, 'BehÃ¶ver du hjÃ¤lp');
                });

                // Skapa konto (Mobilt BankId)
                e.find('.get-mobile-bank-id-link').on('click', function () {
                  ga('send', 'event', 'A/B', eventAction, 'Skapa konto - Mobilt BankId');
                });

                // Logga in (LÃ¶senord)
                e.find('#log-in-submit').on('click', function () {
                  ga('send', 'event', 'A/B', eventAction, 'Logga in - LÃ¶senord');
                });

                // GlÃ¶mt lÃ¶senord (LÃ¶senord)
                e.find('.login-support-password-link').on('click', function () {
                  ga('send', 'event', 'A/B', eventAction, 'GlÃ¶mt lÃ¶senord');
                });

                // Skapa konto (LÃ¶senord)
                e.find('.create-account-link').on('click', function () {
                  ga('send', 'event', 'A/B', eventAction, 'Skapa konto - LÃ¶senord');
                });

                window.clearTimeout(addIframeTrackingTimeout);
                addIframeTrackingDeferred.resolve();
              } else {
                addIframeTrackingTimeout = window.setTimeout(_addIframeTracking, 0);
              }
            };

            var headerBarTimeout = window.setTimeout(_hideHeaderBar, 10);
            var appendHeaderTimeout = window.setTimeout(_appendHeader, 10);
            var addStylesTimeout = window.setTimeout(_addStyles, 10);
            var addIframeTrackingTimeout = window.setTimeout(_addIframeTracking, 10);
            var hideHeaderBarDeferred = $.Deferred();
            var appendHeaderDeferred = $.Deferred();
            var addStylesDeferred = $.Deferred();
            var addIframeTrackingDeferred = $.Deferred();

            $.when(hideHeaderBarDeferred, appendHeaderDeferred, addStylesDeferred, addIframeTrackingDeferred).done(function () {
              self.hideLoader();
            });
          }

          $('.cro-iframe-container iframe').contents().find('form').on('submit', function () {
            if (!$(this).find('input.error').length) {
              self.showLoader();
            }
          });

          $('.cro-iframe-container iframe').contents().find('#submit-login-mobile-bank-id').on('click', function () {
            if (!$(this).find('input.error').length) {
              self.buttonHandlerPollTimeout = setTimeout(self.addButtonHandlerPoll.bind(self), 1000);
            }
          });

          $('.cro-iframe-container iframe').contents().find('a[href*="www.ica.se"]').each(function () {
            $(this).attr('href', $(this).attr('href').replace('http://', 'https://'));
          }).click(function (e) {
            window.location.href = $(this).attr('href');
            e.preventDefault();
          });
        });

        // trigga hotjar heatmap fÃ¶rsta gÃ¥ngen modalen Ã¶ppnats
        // if (typeof hj === 'function' && !self.hotjarTriggered) {
        //     hj('trigger', 'variant');
        //     self.hotjarTriggered = true;
        // }
      }, 50);
    },
    loadCouponData: function loadCouponData(coupon) {
      return loadedCoupons[coupon.OfferId] ? _promise2.default.resolve(loadedCoupons[coupon.OfferId]) : window.fetch('/api/jsonhse/' + coupon.id, { credentials: 'same-origin' }).then(function (response) {
        return response.json();
      }).then(function (json) {
        loadedCoupons[coupon.OfferId] = json;
        return json;
      });
    },
    loadCouponOnCard: function loadCouponOnCard(coupon) {
      var opts = {
        OfferId: coupon.OfferId,
        CampaignId: coupon.CampaignId,
        StoreId: 0,
        StoreGroupId: 0
      };

      return window.fetch('/api/jsonhse/Claimoffer', {
        credentials: 'same-origin',
        method: 'POST',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        body: (0, _stringify2.default)(opts)
      }).then(function (response) {
        if (response.ok) {
          icadatalayer.add('HSE', {
            HSE: {
              action: 'coupon-loaded',
              name: coupon.PageName,
              offer: coupon.title,
              hseurl: coupon.url
            }
          });
        }
        return response;
      });
    },
    resetParallaxScrolling: function resetParallaxScrolling() {
      ICA.icaCallbacks.$parallaxContainers = $('.parallax');
    }
  };

  $(document).ready(function () {
    var IC = (0, _main.ICACRO)();
    if (/^https:\/\/www.ica.se\/$/.test(window.location)) {
      (0, _assign2.default)(test, IC);
      test.checkActionCookies();
      test.manipulateDom();
      test.addEventListeners();
      test.resetParallaxScrolling();
    }
    if (/^https:\/\/www.ica.se\/erbjudanden\/butikserbjudanden\/alla-digitala-kuponger\/$/.test(window.location)) {
      _coupons2.default.manipulateDom(IC, function () {
        test.createModal(LOGIN_ACTION.LOAD_COUPON);
      });
    }
  });
})(jQuery); /* eslint no-inner-declarations: "off" */
/* eslint no-use-before-define: "off" */

// ==UserScript==
// @name         Start-page
// @path         //./src/start-page/variant.js
// @namespace    http://tampermonkey.net/
// @version      0.1
// @match        https://www.ica.se/*
// @grant        none
// ==/UserScript==

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ICACRO = exports.$ELM = undefined;

var _isInteger = __webpack_require__(94);

var _isInteger2 = _interopRequireDefault(_isInteger);

var _keys = __webpack_require__(98);

var _keys2 = _interopRequireDefault(_keys);

var _assign = __webpack_require__(60);

var _assign2 = _interopRequireDefault(_assign);

var _from = __webpack_require__(61);

var _from2 = _interopRequireDefault(_from);

var _toConsumableArray2 = __webpack_require__(105);

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _slicedToArray2 = __webpack_require__(62);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _storage = __webpack_require__(120);

var _storage2 = _interopRequireDefault(_storage);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var reservedElements = ['div', 'body', 'head', 'img', 'style', 'span', 'ul', 'li', 'input', 'button', 'h1', 'h2', 'h3', 'h4', 'a', 'p', 'strong', 'svg']; /*
                                                                                                                                                          eslint no-param-reassign: [
                                                                                                                                                            "error", { "props": true, "ignorePropertyModificationsFor": ["element"] }
                                                                                                                                                          ]
                                                                                                                                                          */
/* eslint no-use-before-define: ["error", { "functions": false }] */
/* eslint-env es6 */

var GetElement = function GetElement(selector) {
  return document.querySelector(selector);
};

var $ELM_ELEMENT = function $ELM_ELEMENT(element) {
  var rect = function rect(arg) {
    return element.getBoundingClientRect()[arg];
  };
  return {
    attr: function attr() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (element) {
        var _ref = args.length === 2 ? [].concat((0, _toConsumableArray3.default)(args)) : args[0].split(':'),
            _ref2 = (0, _slicedToArray3.default)(_ref, 2),
            attr = _ref2[0],
            value = _ref2[1];

        if (value) {
          element.setAttribute(attr, value);
          return this;
        }
        return element.getAttribute(attr);
      }
      throw new Error(args + ' Element does not exist! Function \'attr\'');
    },
    height: function height() {
      return rect('height');
    },
    click: function click(callback) {
      if (element) {
        element.addEventListener('click', callback);
        return this;
      }
      throw new Error(callback + ' Element does not exist! Function \'click\'');
    },
    html: function html(str) {
      if (element) {
        if (!str) return element.innerHTML;
        element.innerHTML = str;
        return this;
      }
      throw new Error(str + ' Element does not exist! Function \'html\'');
    },
    text: function text(str) {
      if (element) {
        if (!str) return element.innerText || element.textContent;
        element.innerHTML = '';
        element.appendChild(document.createTextNode(str));
        return this;
      }
      throw new Error(str + ' Element does not exist! Function \'text\'');
    },
    image: function image(src) {
      if (element) {
        element.src = src;
        return this;
      }
      throw new Error(src + ' Element does not exist! Function \'image\'');
    },
    href: function href(url) {
      if (element) {
        element.href = url;
        return this;
      }
      throw new Error(url + ' Element does not exist! Function \'href\'');
    },
    appendFirst: function appendFirst(child) {
      var c = child.nodeType ? child : child.element;
      if (element) {
        element.insertBefore(c, element.childNodes[0]);
        return this;
      }
      throw new Error(child + ' Element does not exist! Function \'append\'');
    },
    append: function append(child) {
      var c = child.nodeType ? child : child.element;
      if (element) {
        element.appendChild(c);
        return this;
      }
      throw new Error(child + ' Element does not exist! Function \'append\'');
    },
    appendAll: function appendAll() {
      for (var _len2 = arguments.length, childs = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        childs[_key2] = arguments[_key2];
      }

      return childs.map(this.append);
    },
    css: function css(cn) {
      if (cn) {
        cn.split(' ').join(',').split(',').forEach(function (c) {
          return c && element && element.classList.add(c.replace(/\./g, '').trim());
        });
      }
      return this;
    },
    toggle: function toggle(cn) {
      if (cn) {
        element.classList.toggle(cn);
      }
      return this;
    },
    get: function get() {
      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      if (element) {
        if (args.length === 1) return $ELM_ELEMENT(element.querySelector(args[0]));
        return args.map(function (arg) {
          return $ELM_ELEMENT(element.querySelector(arg));
        });
      }
      throw new Error(args + ' Element does not exist! Function \'get\'');
    },
    children: function children(arg) {
      if (arg) {
        var _list = (0, _from2.default)(element.getElementsByTagName(arg));
        return _list.map(function (child) {
          return $ELM_ELEMENT(child);
        });
      }
      var list = (0, _from2.default)(element.childNodes);
      return list.map(function (child) {
        return $ELM_ELEMENT(child);
      });
    },
    style: function style(stl) {
      if (element) {
        (0, _assign2.default)(element.style, stl);
        return this;
      }
      throw new Error(stl + ' Element does not exist! Function \'style\'');
    },
    data: function data(key, value) {
      if (element) {
        element.dataset[key] = value;
        return this;
      }
      throw new Error(key + ' ' + value + ' Element does not exist! Function \'data\'');
    },

    element: element
  };
};

var CreateElement = function CreateElement(arg) {
  if (arg instanceof HTMLElement) return $ELM_ELEMENT(arg);
  var arr = arg.split(' ');
  var type = arr.reduce(function (acc, current) {
    if (reservedElements.includes(current)) {
      return current;
    }
    return acc;
  }, 'div');

  var classNames = arr.filter(function (current) {
    return !reservedElements.includes(current);
  }).join();
  var dom = document.createElement(type);
  return $ELM_ELEMENT(dom).css(classNames);
};

var CreateElementByObject = function CreateElementByObject(type, iterable) {
  var element = CreateElement(type);
  (0, _keys2.default)(iterable).forEach(function (item) {
    var func = element[item];
    if (func) {
      var value = iterable[item];
      if (value && value.length) {
        func(value);
      }
    }
  });
  return element;
};

var $ELM = exports.$ELM = {
  elms: {},
  create: function create() {
    for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }

    if (args.length === 1) return CreateElement(args[0]);
    return args.map(function (arg) {
      return CreateElement(arg);
    });
  },
  build: function build(type, iterable) {
    return CreateElementByObject(type, iterable);
  },
  get: function get() {
    var _this = this;

    for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }

    if (args.length === 1) {
      var key = (0, _isInteger2.default)(parseInt(args[0], 10)) ? parseInt(args[0], 10) : args[0];
      return this.elms[key] || $ELM_ELEMENT(GetElement(key));
    }
    return args.map(function (arg) {
      var key = (0, _isInteger2.default)(parseInt(arg, 10)) ? parseInt(arg, 10) : arg;
      return _this.elms[key] || $ELM_ELEMENT(GetElement(key));
    });
  },
  save: function save(id, element) {
    this.elms[id] = this.elms[id] || {};
    this.elms[id] = element;
  },
  copy: function copy(selector) {
    var child = GetElement(selector);
    if (child) {
      return CreateElement(child.cloneNode(true));
    }
    throw new Error(selector + ' Element does not exist! Function \'copy\'');
  }
};

var ICACRO = exports.ICACRO = function ICACRO() {
  $ELM.get('body').css('cro');
  return {
    getElementContentByTagAndAttr: function getElementContentByTagAndAttr(regexp, tag, attr) {
      var qsa = document.querySelectorAll(tag);
      return this.toArray(qsa).reduce(function (acc, element) {
        if (new RegExp(regexp).test(element[attr])) {
          acc.push(element[attr]);
        }
        return acc;
      }, []);
    },
    removeElements: function removeElements(classNames) {
      classNames.forEach(function (className) {
        var elm = document.querySelector(className);
        if (elm instanceof HTMLElement) elm.parentNode.removeChild(elm);
      });
    },
    toArray: function toArray(list) {
      return Array.prototype.slice.call(list);
    },
    load: function load() {
      for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }

      var _args = (0, _slicedToArray3.default)(args, 2),
          url = _args[0],
          options = _args[1];

      var ops = (0, _assign2.default)({}, { method: 'get' }, options);
      return fetch(url, ops).then(function (response) {
        return response.json();
      }).catch(function (err) {
        return err;
      });
    },
    style: function style(styles) {
      console.log('style is deprecated... use css and require.');
      var style = $ELM.create('style');
      style.attr('type', 'text/css');
      style.append(document.createTextNode(styles));
      $ELM.get('head').append(style);
    },
    isLoggedIn: function isLoggedIn() {
      return $ELM.get('#hdnIcaState').attr('value').length > 1;
    },
    gaPush: function gaPush(_ref3) {
      var _ref3$eventCategory = _ref3.eventCategory,
          eventCategory = _ref3$eventCategory === undefined ? 'A/B' : _ref3$eventCategory,
          eventAction = _ref3.eventAction,
          eventLabel = _ref3.eventLabel;

      if (ga) {
        ga('send', 'event', eventCategory, eventAction, eventLabel);
      }
    },

    storage: {
      set: function set(key, value) {
        _storage2.default.set(key, value);
      },
      get: function get(key) {
        return _storage2.default.get(key);
      },
      remove: function remove(key) {
        _storage2.default.remove(key);
      }
    }
  };
};

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (stars) {
  var arr = ['0', '26', '52', '78', '104'];
  var strs = arr.map(function (x, index) {
    return '<g transform="translate(' + x + ' 0)" class="' + (index < stars ? 'active' : '') + '">\n      <path d="M23.2 10.303q.194.509-.073.97-1.188 2.182-5.067 5.479 1.018 4.194 1.212 6.715.049.679-.533 1.067-.315.194-.63.194-.242 0-.533-.121-.412-.242-1.333-.679-3.273-1.624-4.606-2.473-1.333.849-4.606 2.473-.921.436-1.333.679-.606.315-1.164-.073-.582-.388-.533-1.067.194-2.521 1.212-6.715-3.879-3.297-5.067-5.479-.267-.461-.073-.97.17-.509.63-.679 1.358-.606 6.861-.8 1.988-5.77 3.248-7.03.388-.339.824-.339.461 0 .8.339 1.285 1.261 3.273 7.03 5.503.194 6.861.8.461.194.63.679z"></path>\n      </g>';
  });
  return '<svg xmlns="http://www.w3.org/2000/svg" viewBox="-0.12099626660346985 1.4550001621246338 127.39400121569633 25.34600469470024">\n  <linearGradient id="half" x1="0" x2="100%" y1="0" y2="0">\n  <stop offset="50%" stop-color="currentColor"></stop>\n  <stop offset="50%" stop-color="#d5d7da"></stop>\n  </linearGradient>\n  ' + strs.join('') + '\n  </svg>';
};

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = [{
  recipeId: 718382,
  title: 'Lasagne med halloumi, spenat och pumpakÃ¤rnor',
  stars: 4,
  cookTime: '60 MIN | MEDEL',
  image: 'https://www.ica.se/imagevaultfiles/id_106734/cf_259/lasagne-med-halloumi-spenat-och-pumpakarnor-718382.png',
  url: 'https://www.ica.se/recept/lasagne-med-halloumi-spenat-och-pumpakarnor-718382/',
  coupons: [{
    id: 458278,
    recipeId: 718382,
    title: 'BÃ¶npasta/ lasagneplattor',
    image: 'https://www.ica.se/Handlers/Image.ashx?w=150&h=150&m=p&bgr=fff&u=http://extbild.ica.se//PictureWeb/80/1030/14_1000555309.jpg',
    discount: '20% rabatt',
    subtitle: 'Risenta 120-200 g',
    url: '/kampanj/hse/458278',
    PageName: 'LSR 1030 BÃ¶npasta/lasagneplattor',
    OfferId: 1000555309,
    CampaignId: 1030
  }, {
    id: 458276,
    recipeId: 718382,
    title: 'Buljongkuber',
    image: 'https://www.ica.se/Handlers/Image.ashx?w=150&h=150&m=p&bgr=fff&u=http://extbild.ica.se//PictureWeb/80/1028/14_1000555307.jpg',
    discount: '25% rabatt',
    subtitle: 'Knorr 6-pack',
    url: '/kampanj/hse/458276',
    PageName: 'LSR 1028 Buljong',
    OfferId: 1000555307,
    CampaignId: 1028
  }]
}, {
  recipeId: 722803,
  title: 'Pasta med falafel och Ã¤rtpesto',
  stars: 3,
  cookTime: '45 MIN | MEDEL',
  image: 'https://www.ica.se/imagevaultfiles/id_168851/cf_259/pasta-med-falafel-artpesto-722803-700x654.jpg',
  url: 'https://www.ica.se/recept/pasta-med-falafel-och-artpesto-722803/',
  coupons: [{
    id: 458280,
    recipeId: 722803,
    title: 'Falafel',
    image: 'https://www.ica.se/Handlers/Image.ashx?w=150&h=150&m=p&bgr=fff&u=http://extbild.ica.se//PictureWeb/80/1031/14_1000555310.jpg',
    discount: '5 kr rabatt',
    subtitle: 'Findus 450 g',
    url: '/kampanj/hse/458280',
    PageName: 'LSR 1031 Falafel',
    OfferId: 1000555310,
    CampaignId: 1031
  }, {
    id: 458277,
    recipeId: 722803,
    title: 'iMat',
    image: 'https://www.ica.se/Handlers/Image.ashx?w=150&h=150&m=p&bgr=fff&u=http://extbild.ica.se//PictureWeb/80/1029/14_1000555308.jpg',
    discount: '15% rabatt',
    subtitle: 'Oatly 250 g',
    url: '/kampanj/hse/458277',
    PageName: 'LSR 1029 iMat',
    OfferId: 1000555308,
    CampaignId: 1029
  }]
}, {
  recipeId: 722867,
  title: 'Fryst cheesecake med saffran',
  stars: 4,
  cookTime: '1-4 TIM | MEDEL',
  image: 'https://www.ica.se/imagevaultfiles/id_170800/cf_259/fryst-cheesecake-med-saffran-722867-liten.jpg',
  url: 'https://www.ica.se/recept/fryst-cheesecake-med-saffran-722867/',
  coupons: [{
    id: 458282,
    recipeId: 722867,
    title: 'FÃ¤rskost',
    image: 'https://www.ica.se/Handlers/Image.ashx?w=150&h=150&m=p&bgr=fff&u=http://extbild.ica.se//PictureWeb/80/1033/14_1000555312.jpg',
    discount: '3 kr rabatt',
    subtitle: 'Philadelphia 175-300 g',
    url: '/kampanj/hse/458282',
    PageName: 'LSR 1033 FÃ¤rskost Philadelpia',
    OfferId: 1000555312,
    CampaignId: 1033
  }, {
    id: 458274,
    recipeId: 722867,
    title: 'Margarin',
    image: 'https://www.ica.se/Handlers/Image.ashx?w=150&h=150&m=p&bgr=fff&u=http://extbild.ica.se//PictureWeb/80/1026/14_1000555305.jpg',
    discount: '5 kr rabatt',
    subtitle: 'Milda 1 kg',
    url: '/kampanj/hse/458274',
    PageName: 'LSR 1026 Margarin',
    OfferId: 1000555305,
    CampaignId: 1026
  }]
}, {
  recipeId: 719374,
  title: 'Torsk i ugn med dill- och citronsÃ¥s',
  stars: 4,
  cookTime: '30 MIN | MEDEL',
  image: 'https://www.ica.se/imagevaultfiles/id_122727/cf_259/torsk-i-ugn-med-dill-och-citronsas-v38-2015-719374.jpg',
  url: 'https://www.ica.se/recept/torsk-i-ugn-med-dill-och-citronsas-719374/',
  coupons: [{
    id: 458288,
    recipeId: 719374,
    title: 'TorskfilÃ©',
    image: 'https://www.ica.se/Handlers/Image.ashx?w=150&h=150&m=p&bgr=fff&u=http://extbild.ica.se//PictureWeb/80/1038/14_1000555317.jpg',
    discount: '25% rabatt',
    subtitle: 'ICA 600 g',
    url: '/kampanj/hse/458288',
    PageName: 'LSR 1038 TorskfilÃ©',
    OfferId: 1000555317,
    CampaignId: 1038
  }, {
    id: 458274,
    recipeId: 719374,
    title: 'Margarin',
    image: 'https://www.ica.se/Handlers/Image.ashx?w=150&h=150&m=p&bgr=fff&u=http://extbild.ica.se//PictureWeb/80/1026/14_1000555305.jpg',
    discount: '5 kr rabatt',
    subtitle: 'Milda 1 kg',
    url: '/kampanj/hse/458274',
    PageName: 'LSR 1026 Margarin',
    OfferId: 1000555305,
    CampaignId: 1026
  }]
}, {
  recipeId: 721310,
  title: 'Glutenfri saffranskaka',
  stars: 4,
  cookTime: '1-4 TIM | MEDEL',
  image: 'https://www.ica.se/imagevaultfiles/id_150397/cf_259/glutenfri-saffranskaka-721310-liten.jpg',
  url: 'https://www.ica.se/recept/glutenfri-saffranskaka-721310/',
  coupons: [{
    id: 458298,
    recipeId: 721310,
    title: 'Mandelmassa',
    image: 'https://www.ica.se/Handlers/Image.ashx?w=150&h=150&m=p&bgr=fff&u=http://extbild.ica.se//PictureWeb/80/1044/14_1000555323.jpg',
    discount: '25 % rabatt',
    subtitle: 'ICA 200 g',
    url: '/kampanj/hse/458298',
    PageName: 'LSR 1044 Mandelmassa',
    OfferId: 1000555323,
    CampaignId: 1044
  }, {
    id: 458274,
    recipeId: 721310,
    title: 'Margarin',
    image: 'https://www.ica.se/Handlers/Image.ashx?w=150&h=150&m=p&bgr=fff&u=http://extbild.ica.se//PictureWeb/80/1026/14_1000555305.jpg',
    discount: '5 kr rabatt',
    subtitle: 'Milda 1 kg',
    url: '/kampanj/hse/458274',
    PageName: 'LSR 1026 Margarin',
    OfferId: 1000555305,
    CampaignId: 1026
  }]
}, {
  recipeId: 722922,
  title: 'Mozartkulor',
  stars: 5,
  cookTime: '30 MIN | MEDEL',
  image: 'https://www.ica.se/imagevaultfiles/id_172499/cf_259/mozartkulor-722922-580x580.jpg',
  url: 'https://www.ica.se/recept/mozartkulor-722922/',
  coupons: [{
    id: 458298,
    recipeId: 722922,
    title: 'Mandelmassa',
    image: 'https://www.ica.se/Handlers/Image.ashx?w=150&h=150&m=p&bgr=fff&u=http://extbild.ica.se//PictureWeb/80/1044/14_1000555323.jpg',
    discount: '25 % rabatt',
    subtitle: 'ICA 200 g',
    url: '/kampanj/hse/458298',
    PageName: 'LSR 1044 Mandelmassa',
    OfferId: 1000555323,
    CampaignId: 1044
  }, {
    id: 458297,
    recipeId: 722922,
    title: 'Baknougat',
    image: 'https://www.ica.se/Handlers/Image.ashx?w=150&h=150&m=p&bgr=fff&u=http://extbild.ica.se//PictureWeb/80/1043/14_1000555322.jpg',
    discount: '5 kr rabatt',
    subtitle: 'ICA 250 g',
    url: '/kampanj/hse/458297',
    PageName: 'LSR 1043 Baknougat',
    OfferId: 1000555322,
    CampaignId: 1043
  }]
}];

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(5);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {"hmr":true}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(7)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../node_modules/css-loader/index.js!./style.css", function() {
			var newContent = require("!!../../node_modules/css-loader/index.js!./style.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(6)(undefined);
// imports


// module
exports.push([module.i, "/*.cro header .image-slider {\r\n  position: absolute !important;\r\n}*/\r\n\r\n/*\r\nbackground-position: -338px -1885px; prev\r\n\r\n\r\nbackground-position: -438px -1885px;\r\n */\r\n\r\n.cro #header {\r\n  background-color: white;\r\n}\r\n\r\n.slick-slide, .slick-track:focus {\r\n  outline: none;\r\n}\r\n.start-page-icase #header {\r\n  height: 100%;\r\n}\r\n.coupon-banner {\r\n  text-align: center;\r\n  margin-bottom: 30px;\r\n  background-color: #F5E9F0;\r\n}\r\n.coupon-banner img {\r\n  margin: 10px 0 0;\r\n}\r\n.cro .search-recipe-container {\r\n  margin-bottom: 20px;\r\n}\r\n.cro .search-recipe-container img {\r\n  margin-bottom: 20px;\r\n}\r\n.cro .search-recipe-container h1, .coupon-banner h1 {\r\n  font-size: 2.8rem;\r\n}\r\n.cro .search-recipe-container__all-recipes {\r\n  font-size: 2.2rem;\r\n}\r\n.cro .pl .container-backdrop {\r\n  padding: 15px 10px 30px;\r\n}\r\n\r\n.slick-prev:before, .slick-next:before { content: '' }\r\n.slick-prev {\r\n  top: 170px;\r\n  left: -10px;\r\n  background-position: -338px -1885px;\r\n  width: 40px !important;\r\n  height: 40px !important;\r\n}\r\n.slick-next {\r\n  top: 170px;\r\n  right: 5px;\r\n  background-position: -438px -1885px;\r\n  width: 40px !important;\r\n  height: 40px !important;\r\n}\r\n\r\n.cro .slick-prev:hover,\r\n.cro .slick-prev:focus,\r\n.cro .slick-prev:active {\r\n  background-color: transparent;\r\n  background-position: -338px -1885px;\r\n}\r\n.cro .slick-next:hover,\r\n.cro .slick-next:focus,\r\n.cro .slick-next:active {\r\n  background-color: transparent;\r\n  background-position: -438px -1885px;\r\n}\r\n.cro .slick-arrow {\r\n  background-color: transparent;\r\n  background-image: url('/Templates/General/Views/Images/RWD/sprites/general_sprite1.png?1');\r\n  background-repeat: no-repeat;\r\n}\r\nbutton:focus, button:active {outline:0;}\r\n.slick-initialized .slick-slider {\r\n  outline: none;\r\n}\r\n.cro .banner-container {\r\n  width: 100%;\r\n  height: 100%;\r\n  background-color: white;\r\n  z-index: 20 !important;\r\n  display: inline-block;\r\n}\r\n\r\n.cro .banner-container__img {\r\n  width: inherit;\r\n  height: 320px;\r\n  position: absolute;\r\n  top: 0;\r\n  overflow: hidden;\r\n  background-color: black;\r\n}\r\n\r\n.cro .banner-container__img img { height: auto; width: 100%; opacity: .8; }\r\n\r\n.cro .banner-container__text-container {\r\n  max-width: 100%;\r\n  margin: 70px 35px 10px;\r\n  text-shadow: 0 0 5px rgba(0, 0, 0, 0.4);\r\n  position: relative;\r\n}\r\n\r\n.cro .text-container__title {\r\n  font-size: 36px;\r\n  color: white;\r\n  font-family: icarubrik;\r\n  font-weight: 600;\r\n  line-height: 3rem;\r\n  white-space: normal;\r\n}\r\n\r\n.cro .text-container__ratings svg .active {\r\n  fill: #EB1F07;\r\n}\r\n\r\n.cro .text-container__ratings svg {\r\n  /*display: inline-block;*/\r\n  display: block;\r\n  fill: #D5D7DA;\r\n  height: 18px;\r\n  vertical-align: middle;\r\n  width: 91px;\r\n  -webkit-filter: drop-shadow( 1px 1px 2px rgba(0,0,0,0.4) );\r\n  filter: drop-shadow( 1px 1px 2px rgba(0,0,0,0.4) );\r\n}\r\n\r\n.cro .text-container__difficulty {\r\n  text-transform: uppercase;\r\n  font: 16px icatext;\r\n  font-weight: 900;\r\n  margin-top: 6px;\r\n  color: white;\r\n}\r\n\r\n.cro .coupons-container {\r\n  width: 100%;\r\n  z-index: 999;\r\n  display: flex;\r\n  flex-direction: row;\r\n  padding: 5px;\r\n  /*margin-bottom: 20px;*/\r\n}\r\n\r\n.cro .coupons-container__item {\r\n  background-color: white;\r\n  width: 50%;\r\n  margin: 0 4px;\r\n  padding: 10px;\r\n  border: 8px solid rgba(217,20,99,0.1);\r\n  border-bottom-width: 17px;\r\n  border-radius: 6px;\r\n  display: flex;\r\n  flex-direction: column;\r\n  justify-content: space-between;\r\n  position: relative;\r\n}\r\n\r\n.cro .coupons-container__item:after {\r\n  background: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMjAgMTAiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDIwIDEwOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+PHN0eWxlIHR5cGU9InRleHQvY3NzIj4uc3Qwe2ZpbGw6I2ZmZjt9PC9zdHlsZT48cGF0aCBjbGFzcz0ic3QwIiBkPSJNMTAsMi41Yy00LjEsMC03LjUsMy40LTcuNSw3LjVoMTVDMTcuNSw1LjksMTQuMiwyLjUsMTAsMi41eiIvPjwvc3ZnPg==) space;\r\n  background-size: 26px 13px;\r\n  content: '';\r\n  display: block;\r\n  width: 140%;\r\n  height: 13px;\r\n  position: absolute;\r\n  bottom: -17px;\r\n  left: -30px;\r\n}\r\n\r\n.cro .coupons-container__item img {\r\n  width: 60% !important;\r\n  height: auto !important;\r\n  margin: 0 auto 10px !important;\r\n}\r\n\r\n.cro .coupons-container .coupons-container__item h3 {\r\n  font-size: 16px;\r\n  line-height: 1em;\r\n  margin-bottom: 6px;\r\n}\r\n\r\n.cro .coupons-container .coupons-container__item h1 {\r\n  font-size: 22px;\r\n  font-weight: 700;\r\n  color: #EB1F07;\r\n  line-height: 1.5rem;\r\n}\r\n\r\n.cro .coupons-container .coupons-container__item h4 {\r\n  color: #808283;\r\n  font-size: 1.3rem;\r\n  line-height: 1.4;\r\n  font-family: icatext;\r\n  font-weight: normal;\r\n}\r\n\r\n.cro .coupons-container .coupons-container__item a {\r\n  font-size: 14px;\r\n  line-height: 15px;\r\n  margin-bottom: 5px;\r\n}\r\n\r\n.cro .coupons-container .coupons-container__item .coupon-button {\r\n  font-size: 12px;\r\n  line-height: 2.2rem;\r\n  min-width: auto;\r\n  align-self: center;\r\n  width: 100%;\r\n  background: #F8EBF3;\r\n  color: #A02971;\r\n}\r\n\r\n.cro .coupons-container .coupons-container__item.offer-loaded .coupon-button {\r\n  background: #DDE9BF;\r\n  color: #8DB72C;\r\n  pointer-events: none;\r\n  transition: width .2s ease, color .2s 250ms ease, background .2s ease;\r\n}\r\n\r\n.cro .coupons-container .coupons-container__item .coupons-image {\r\n  width: 100%;\r\n  height: 60px;\r\n  background-repeat: no-repeat;\r\n  background-size: contain;\r\n  background-position: center;\r\n}\r\n\r\n.cro .banner-wrapper .banner-image img {\r\n  width: 100%;\r\n  position: relative;\r\n  margin-left: 0 !important;\r\n  height: auto !important;\r\n  margin-top: 0 !important;\r\n  min-width: 375px;\r\n}\r\n\r\n.cro .button-wrapper {\r\n  margin: 10px 0 30px 35px;\r\n}\r\n\r\n.cro .banner-button {\r\n  width: 60%;\r\n  display: block;\r\n  overflow: hidden;\r\n}\r\n.cro .banner-button .layer {\r\n  position: absolute;\r\n  top: -30px;\r\n  right: 20%;\r\n  transition: all 0.5s ease;\r\n}\r\n.cro .banner-button.saved {\r\n  background: #DDE9BF;\r\n  color: #8DB72C;\r\n  pointer-events: none;\r\n  transition: width .2s ease, color .2s 250ms ease, background .2s ease;\r\n  font-weight: 400;\r\n}\r\n\r\n.cro .banner-button.added .layer{\r\n  top: 0;\r\n}\r\n\r\n.cro .offers-button {\r\n  width: 90%;\r\n  margin-bottom: 20px;\r\n}\r\n\r\n.cro .rating-star-container {\r\n  position: absolute;\r\n  z-index: 50;\r\n  margin:10px;\r\n  top: 30px;\r\n  color: white;\r\n  text-shadow: 0 0 5px rgba(0, 0, 0, 0.4);\r\n}\r\n\r\n.cro .ica-card-container {\r\n  display: flex;\r\n  flex-direction: column;\r\n  min-height: 250px;\r\n}\r\n\r\n.cro .ica-card-container h1 {\r\n  color: #EB1F07;\r\n}\r\n\r\n.cro .ica-card-container a {\r\n  align-self: flex-start;\r\n  max-width: 250px;\r\n  margin-top:-160px;\r\n}\r\n\r\n.cro .ica-card-container img {\r\n  max-width: 385px;\r\n  width: 80%;\r\n  align-self: flex-end;\r\n  margin-top:-120px;\r\n}\r\n\r\n@media only screen and (max-width: 960px){\r\n  .cro .ica-card-container {\r\n    min-height: none;\r\n  }\r\n\r\n  .cro .ica-card-container h1 {\r\n    line-height: 3rem;\r\n    font-size: 3rem;\r\n    margin-bottom: 20px;\r\n  }\r\n\r\n  .cro .ica-card-container a {\r\n    align-self: center;\r\n    margin-top: 20px;\r\n    max-width: none;\r\n    width: 100%;\r\n  }\r\n\r\n  .cro .ica-card-container img {\r\n    align-self: center;\r\n    margin-top:auto;\r\n  }\r\n\r\n  .cro .offers-container {\r\n    width: 100%;\r\n    background-color: white;\r\n    -webkit-filter: drop-shadow( 1px 1px 2px rgba(0,0,0,0.4) );\r\n    filter: drop-shadow( 1px 1px 2px rgba(0,0,0,0.4) );\r\n  }\r\n\r\n  .start-page-icase > header.full-size-image .image-slider,\r\n  .start-page-icase > header.full-size-image .image-slider ul,\r\n  .start-page-icase > header.full-size-image .image-slider li {\r\n    max-height: 100%;\r\n    width: 100% !important;\r\n    height: 100% !important;\r\n  }\r\n}\r\n.cro .unslider-controls { pointer-events: none; }\r\n.cro .unslider-arrow { pointer-events: auto; }\r\n\r\n@media (max-width: 767px) { .cro .cro-iframe-container { padding-bottom: 135% !important; } }\r\n.cro > .cro-iframe-container { display: none; }\r\n.cro .modal-copntainer .cro-iframe-container { display: initial; }\r\n.cro .container { text-align: center; margin-top: 50px;}\r\n.cro .container h2 { font: 28px icahand; margin-bottom: 20px; }\r\n.cro .cro-iframe-container {\r\n  position: relative;\r\n  height: 0;\r\n  overflow: hidden;\r\n  padding-bottom: 85%;\r\n  background-color: #F3F0EB;\r\n}\r\n.cro .cro-iframe-container iframe {\r\n  opacity: 0;\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  width: 100%;\r\n  height: 100%;\r\n}\r\n\r\n.cro .usp-list { margin-bottom: 10px; }\r\n\r\n.cro .usp-list li {\r\n  font: 24px icarubrik;\r\n  font-weight: 600;\r\n  margin-bottom: 15px;\r\n}\r\n.cro .usp-list svg {\r\n  fill: #8DB72C;\r\n  margin-right: 5px;\r\n}\r\n", ""]);

// exports


/***/ }),
/* 6 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getElement = (function (fn) {
	var memo = {};

	return function(selector) {
		if (typeof memo[selector] === "undefined") {
			var styleTarget = fn.call(this, selector);
			// Special case to return head of iframe instead of iframe itself
			if (styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[selector] = styleTarget;
		}
		return memo[selector]
	};
})(function (target) {
	return document.querySelector(target)
});

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(8);

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton) options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
	if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertInto + " " + options.insertAt.before);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	options.attrs.type = "text/css";

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 8 */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = __webpack_require__(60);

var _assign2 = _interopRequireDefault(_assign);

var _defineProperty2 = __webpack_require__(112);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _regenerator = __webpack_require__(116);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _stringify = __webpack_require__(59);

var _stringify2 = _interopRequireDefault(_stringify);

var _asyncToGenerator2 = __webpack_require__(119);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _slicedToArray2 = __webpack_require__(62);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _main = __webpack_require__(1);

__webpack_require__(12);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var coupons = {
  printBanner: function printBanner(content, _ref) {
    var _this = this;

    var title = _ref.title,
        discount = _ref.discount,
        preamble = _ref.preamble,
        url = _ref.url,
        img = _ref.img,
        isUsed = _ref.isUsed,
        id = _ref.id,
        data = _ref.data;

    var isUsedClass = isUsed ? ' is-used' : '';

    var _$ELM$create = _main.$ELM.create('banner', 'banner-row', 'banner-column', 'banner-column grow-one', 'banner-column', 'banner-column__image', 'h1', 'span', 'p', 'img', 'a', 'button .button download ' + isUsedClass),
        _$ELM$create2 = (0, _slicedToArray3.default)(_$ELM$create, 12),
        bannerElement = _$ELM$create2[0],
        bannerRow = _$ELM$create2[1],
        bannerColumn1 = _$ELM$create2[2],
        bannerColumn2 = _$ELM$create2[3],
        bannerColumn3 = _$ELM$create2[4],
        imgElement = _$ELM$create2[5],
        titleElement = _$ELM$create2[6],
        discountElement = _$ELM$create2[7],
        preambleElement = _$ELM$create2[8],
        imgHolder = _$ELM$create2[9],
        readMore = _$ELM$create2[10],
        downLoad = _$ELM$create2[11];

    var buttonText = isUsed ? 'Kupong laddad' : 'Ladda kupong';

    imgHolder.image(img);
    imgElement.append(imgHolder);

    readMore.href('/kampanj/hse/' + id).text('LÃ¤s mer');
    downLoad.href(url).text(buttonText);

    titleElement.html(title);
    discountElement.html(discount);
    preambleElement.html(preamble);

    bannerColumn1.append(imgElement);
    bannerColumn2.appendAll(titleElement, discountElement, preambleElement, readMore);
    bannerColumn3.append(downLoad);

    bannerRow.appendAll(bannerColumn1, bannerColumn2, bannerColumn3);
    bannerElement.append(bannerRow);
    content.append(bannerElement);

    downLoad.click(function (event) {
      return _this.onClick(event, data);
    });
    _main.$ELM.save(id, bannerElement);

    icadatalayer.add('HSE', {
      HSE: {
        action: 'display',
        title: data.PageName,
        hseurl: '/kampanj/hse/' + data.CampaignId
      }
    });
  },
  loadCouponOnCard: function () {
    var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(data) {
      return _regenerator2.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.load('/api/jsonhse/Claimoffer', {
                credentials: 'same-origin',
                method: 'POST',
                headers: {
                  Accept: 'application/json',
                  'Content-Type': 'application/json'
                },
                body: (0, _stringify2.default)(data)
              });

            case 2:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function loadCouponOnCard(_x) {
      return _ref2.apply(this, arguments);
    }

    return loadCouponOnCard;
  }(),
  checkActionCookie: function checkActionCookie() {
    var coupon = this.storage.get('coupon');
    if (coupon && this.isLoggedIn()) {
      this.storage.remove('coupon');
      this.loadCouponOnCard(coupon);
    }
  },
  deactivateCoupon: function deactivateCoupon(id) {
    _main.$ELM.get(id).get('button').css('is-used');
  },
  onClick: function () {
    var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(event, data) {
      return _regenerator2.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              event.preventDefault();

              if (!this.isLoggedIn()) {
                _context2.next = 8;
                break;
              }

              this.deactivateCoupon(data.CampaignId);
              _context2.next = 5;
              return this.loadCouponOnCard(data);

            case 5:
              icadatalayer.add('HSE', {
                HSE: {
                  action: 'coupon-loaded',
                  name: data.PageName,
                  offer: data.ProductName,
                  hseurl: '/kampanj/hse/' + data.CampaignId
                }
              });
              _context2.next = 11;
              break;

            case 8:
              icadatalayer.add('HSE', {
                HSE: {
                  action: 'login-mousedown',
                  name: data.PageName,
                  hseurl: '/kampanj/hse/' + data.CampaignId
                }
              });
              this.storage.set('coupon', data);
              this.createModal();

            case 11:
            case 'end':
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function onClick(_x2, _x3) {
      return _ref3.apply(this, arguments);
    }

    return onClick;
  }(),
  loadBanners: function loadBanners(ids, content) {
    var _this2 = this;

    ids.forEach(function (id) {
      _this2.load('https://www.ica.se/api/jsonhse/' + id, { credentials: 'same-origin' }).then(function (response) {
        var _data;

        var PageName = response.PageName,
            Header = response.Header,
            Offer = response.Offer,
            CampaignId = response.CampaignId,
            StoreGroupId = response.StoreGroupId,
            StoreId = response.StoreId;
        var ProductName = Offer.ProductName,
            LoadedOnCard = Offer.LoadedOnCard,
            OfferCondition = Offer.OfferCondition,
            Brand = Offer.Brand,
            SizeOrQuantity = Offer.SizeOrQuantity,
            OfferId = Offer.OfferId;


        var data = (_data = {
          CampaignId: CampaignId,
          ProductName: ProductName
        }, (0, _defineProperty3.default)(_data, 'CampaignId', CampaignId), (0, _defineProperty3.default)(_data, 'PageName', PageName), (0, _defineProperty3.default)(_data, 'OfferId', OfferId), (0, _defineProperty3.default)(_data, 'StoreId', StoreId), (0, _defineProperty3.default)(_data, 'StoreGroupId', StoreGroupId), _data);
        _this2.printBanner(content, {
          data: data,
          id: CampaignId,
          isUsed: LoadedOnCard,
          title: Header,
          discount: OfferCondition.Conditions[0],
          preamble: Brand + ' ' + SizeOrQuantity.Text,
          url: '',
          img: Offer.Image.ImageUrl
        });
      });
    });
  },
  addIframe: function addIframe() {
    var returnUrl = encodeURIComponent(window.location.href);
    var iframe = _main.$ELM.create('cro-iframe-container');
    var iframeContainer = '<span class="loader"></span><iframe src="//www.ica.se/logga-in/?returnurl=' + returnUrl + '" frameborder="0"></iframe>';
    iframe.html(iframeContainer);
    _main.$ELM.get('body').append(iframe);
  },
  manipulateDom: function manipulateDom(ICACRO, createModal) {
    (0, _assign2.default)(this, ICACRO, { createModal: createModal });
    var content = _main.$ELM.get('#content');
    var regexp = /www.ica.se\/kampanj\/hse/g;
    var banners = this.getElementContentByTagAndAttr(regexp, 'a', 'href');
    var ids = banners.map(function (banner) {
      return banner.match(/\d+$/)[0];
    });
    this.addIframe();
    content.html(' ');
    this.loadBanners(ids, content);
    this.checkActionCookie();
  }
};

exports.default = coupons;

/***/ }),
/* 10 */,
/* 11 */,
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(13);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {"hmr":true}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(7)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../node_modules/css-loader/index.js!./coupons-style.css", function() {
			var newContent = require("!!../../node_modules/css-loader/index.js!./coupons-style.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(6)(undefined);
// imports


// module
exports.push([module.i, ".cro .grow-one { flex-grow: 1; }\r\n.cro .banner { display:flex; background-color: #F8EBF3; margin-bottom: 10px; }\r\n.cro .banner.is-used { background-color: rgba(247,247,247,1); }\r\n.cro .banner-row {\r\ndisplay:flex;\r\nwidth:100%;\r\nalign-items: center;\r\nbackground-color: white;\r\nmargin: 10px 15px;\r\nposition: relative;\r\n}\r\n.cro .banner-row::after {\r\nbackground:url(\"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIxLjAuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCAxMCAyMCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgMTAgMjA7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCS5zdDB7ZmlsbDojRjhFQkYzO30KPC9zdHlsZT4KPHBhdGggY2xhc3M9InN0MCIgZD0iTTIuNDk3MDIxLDkuOTg4ODA3YzAsNC4xNDIxNTEsMy4zNTc4NDksNy41MDAwMDEsNy41LDcuNTAwMDAxdi0xNQoJQzUuODU0ODcsMi40ODg4MDcsMi40OTcwMjEsNS44NDY2NTYsMi40OTcwMjEsOS45ODg4MDd6Ii8+Cjwvc3ZnPgo=\") space;\r\nbackground-size: 13px 26px;\r\nbottom: 0;\r\ncontent: '';\r\ndisplay: block;\r\nheight: 100%;\r\nposition: absolute;\r\nright: 0;\r\ntop: 0;\r\nwidth: 13px;\r\n}\r\n.cro .banner .banner-column:first-child { margin-left: 10px; }\r\n.cro .banner .banner-column:last-child {  margin-right: 10px; }\r\n.cro .banner .banner-column { padding: 10px; }\r\n.cro .banner .banner-column .download {\r\n  font-size: 12px;\r\n  align-items: center;\r\n  background: #F8EBF3;\r\n  font-weight: bold;\r\n  color: rgba(160,41,113,1);\r\n  cursor: pointer;\r\n  display: flex;\r\n  flex-direction: column;\r\n  justify-content: center;\r\n  margin: 10px 10px 10px 0;\r\n  border-radius: 6rem;\r\n  width: 100px;\r\n  line-height: 1.4rem;\r\n  padding-bottom: 10px;\r\n}\r\n.cro .banner .banner-column .download.is-used {\r\n  background: #DDE9BF;\r\n  color: #8DB72C;\r\n  pointer-events: none;\r\n  transition: width .2s ease, color .2s 250ms ease, background .2s ease\r\n}\r\n.cro .banner .banner-column h1 { font-size: 1.6rem; word-break: break-all;}\r\n.cro .banner .banner-column span {\r\n  color: #EB1F07;\r\n  font-family: icarubrik;\r\n  font-size: 2.2rem;\r\n  font-weight: bold;\r\n}\r\n.cro .banner .banner-column p {\r\n  color: #808283;\r\n  font-size: 1.3rem;\r\n  margin: 0;\r\n}\r\n/*rgba(141,183,44,1)*/\r\n.cro .banner .banner-column h1.is-used,\r\n.cro .banner .banner-column span.is-used,\r\n.cro .banner .banner-column p.is-used { color: #D5D7DA; }\r\n.cro .banner .banner-column .banner-column__more-info { font-size: 20px; }\r\n.cro .banner-column__image {\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  text-align: center;\r\n  width: 150px;\r\n  height: 150px;\r\n}\r\n.cro .banner-column__image img {\r\n  max-width: 100%;\r\n  max-height: 100%;\r\n  width: auto;\r\n  height: auto;\r\n}\r\n.cro .banner-column__image img.is-used {\r\n  opacity: .3;\r\n}\r\n@media only screen and (max-width: 780px){\r\n  .cro .banner-column__image {\r\n    width: 65px;\r\n    height: 65px;\r\n  }\r\n  #page {\r\n    padding: 0 5px 5px;\r\n  }\r\n  .cro .banner .banner-column:first-child { padding: 10px; margin-left: 0; }\r\n  .cro .banner .banner-column:last-child { padding: 10px 10px 10px 0; margin-right: 0; }\r\n  .cro .banner .banner-column { padding: 10px 0; }\r\n}\r\n", ""]);

// exports


/***/ }),
/* 14 */
/***/ (function(module, exports) {

var core = module.exports = { version: '2.5.1' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(48)('wks');
var uid = __webpack_require__(49);
var Symbol = __webpack_require__(16).Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),
/* 16 */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(16);
var core = __webpack_require__(14);
var ctx = __webpack_require__(24);
var hide = __webpack_require__(19);
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && key in exports) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(21);
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(20);
var createDesc = __webpack_require__(34);
module.exports = __webpack_require__(22) ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(18);
var IE8_DOM_DEFINE = __webpack_require__(66);
var toPrimitive = __webpack_require__(67);
var dP = Object.defineProperty;

exports.f = __webpack_require__(22) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),
/* 21 */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(27)(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 23 */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(26);
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at = __webpack_require__(65)(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(45)(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),
/* 26 */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),
/* 27 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),
/* 28 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),
/* 29 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(32);
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),
/* 31 */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),
/* 32 */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(21);
var document = __webpack_require__(16).document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),
/* 34 */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(72);
var enumBugKeys = __webpack_require__(50);

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(47);
var defined = __webpack_require__(32);
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(31);
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(48)('keys');
var uid = __webpack_require__(49);
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(20).f;
var has = __webpack_require__(28);
var TAG = __webpack_require__(15)('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(76);
var global = __webpack_require__(16);
var hide = __webpack_require__(19);
var Iterators = __webpack_require__(23);
var TO_STRING_TAG = __webpack_require__(15)('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(29);
var TAG = __webpack_require__(15)('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(41);
var ITERATOR = __webpack_require__(15)('iterator');
var Iterators = __webpack_require__(23);
module.exports = __webpack_require__(14).getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 25.4.1.5 NewPromiseCapability(C)
var aFunction = __webpack_require__(26);

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(63), __esModule: true };

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(46);
var $export = __webpack_require__(17);
var redefine = __webpack_require__(68);
var hide = __webpack_require__(19);
var has = __webpack_require__(28);
var Iterators = __webpack_require__(23);
var $iterCreate = __webpack_require__(69);
var setToStringTag = __webpack_require__(39);
var getPrototypeOf = __webpack_require__(75);
var ITERATOR = __webpack_require__(15)('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),
/* 46 */
/***/ (function(module, exports) {

module.exports = true;


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(29);
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(16);
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});
module.exports = function (key) {
  return store[key] || (store[key] = {});
};


/***/ }),
/* 49 */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),
/* 50 */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(16).document;
module.exports = document && document.documentElement;


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(18);
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(23);
var ITERATOR = __webpack_require__(15)('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__(18);
var aFunction = __webpack_require__(26);
var SPECIES = __webpack_require__(15)('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(24);
var invoke = __webpack_require__(82);
var html = __webpack_require__(51);
var cel = __webpack_require__(33);
var global = __webpack_require__(16);
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (__webpack_require__(29)(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};


/***/ }),
/* 56 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(18);
var isObject = __webpack_require__(21);
var newPromiseCapability = __webpack_require__(43);

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__(15)('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(88), __esModule: true };

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(89), __esModule: true };

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(102), __esModule: true };

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _isIterable2 = __webpack_require__(106);

var _isIterable3 = _interopRequireDefault(_isIterable2);

var _getIterator2 = __webpack_require__(109);

var _getIterator3 = _interopRequireDefault(_getIterator2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if ((0, _isIterable3.default)(Object(arr))) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(64);
__webpack_require__(25);
__webpack_require__(40);
__webpack_require__(79);
__webpack_require__(86);
__webpack_require__(87);
module.exports = __webpack_require__(14).Promise;


/***/ }),
/* 64 */
/***/ (function(module, exports) {



/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(31);
var defined = __webpack_require__(32);
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(22) && !__webpack_require__(27)(function () {
  return Object.defineProperty(__webpack_require__(33)('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(21);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(19);


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__(70);
var descriptor = __webpack_require__(34);
var setToStringTag = __webpack_require__(39);
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(19)(IteratorPrototype, __webpack_require__(15)('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(18);
var dPs = __webpack_require__(71);
var enumBugKeys = __webpack_require__(50);
var IE_PROTO = __webpack_require__(38)('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(33)('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(51).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(20);
var anObject = __webpack_require__(18);
var getKeys = __webpack_require__(35);

module.exports = __webpack_require__(22) ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(28);
var toIObject = __webpack_require__(36);
var arrayIndexOf = __webpack_require__(73)(false);
var IE_PROTO = __webpack_require__(38)('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(36);
var toLength = __webpack_require__(37);
var toAbsoluteIndex = __webpack_require__(74);
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(31);
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(28);
var toObject = __webpack_require__(30);
var IE_PROTO = __webpack_require__(38)('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(77);
var step = __webpack_require__(78);
var Iterators = __webpack_require__(23);
var toIObject = __webpack_require__(36);

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(45)(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),
/* 77 */
/***/ (function(module, exports) {

module.exports = function () { /* empty */ };


/***/ }),
/* 78 */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(46);
var global = __webpack_require__(16);
var ctx = __webpack_require__(24);
var classof = __webpack_require__(41);
var $export = __webpack_require__(17);
var isObject = __webpack_require__(21);
var aFunction = __webpack_require__(26);
var anInstance = __webpack_require__(80);
var forOf = __webpack_require__(81);
var speciesConstructor = __webpack_require__(54);
var task = __webpack_require__(55).set;
var microtask = __webpack_require__(83)();
var newPromiseCapabilityModule = __webpack_require__(43);
var perform = __webpack_require__(56);
var promiseResolve = __webpack_require__(57);
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[__webpack_require__(15)('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value);
            if (domain) domain.exit();
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  if (promise._h == 1) return false;
  var chain = promise._a || promise._c;
  var i = 0;
  var reaction;
  while (chain.length > i) {
    reaction = chain[i++];
    if (reaction.fail || !isUnhandled(reaction.promise)) return false;
  } return true;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = __webpack_require__(84)($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
__webpack_require__(39)($Promise, PROMISE);
__webpack_require__(85)(PROMISE);
Wrapper = __webpack_require__(14)[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(58)(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});


/***/ }),
/* 80 */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(24);
var call = __webpack_require__(52);
var isArrayIter = __webpack_require__(53);
var anObject = __webpack_require__(18);
var toLength = __webpack_require__(37);
var getIterFn = __webpack_require__(42);
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;


/***/ }),
/* 82 */
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(16);
var macrotask = __webpack_require__(55).set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__(29)(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver
  } else if (Observer) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    var promise = Promise.resolve();
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

var hide = __webpack_require__(19);
module.exports = function (target, src, safe) {
  for (var key in src) {
    if (safe && target[key]) target[key] = src[key];
    else hide(target, key, src[key]);
  } return target;
};


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(16);
var core = __webpack_require__(14);
var dP = __webpack_require__(20);
var DESCRIPTORS = __webpack_require__(22);
var SPECIES = __webpack_require__(15)('species');

module.exports = function (KEY) {
  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// https://github.com/tc39/proposal-promise-finally

var $export = __webpack_require__(17);
var core = __webpack_require__(14);
var global = __webpack_require__(16);
var speciesConstructor = __webpack_require__(54);
var promiseResolve = __webpack_require__(57);

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-promise-try
var $export = __webpack_require__(17);
var newPromiseCapability = __webpack_require__(43);
var perform = __webpack_require__(56);

$export($export.S, 'Promise', { 'try': function (callbackfn) {
  var promiseCapability = newPromiseCapability.f(this);
  var result = perform(callbackfn);
  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
  return promiseCapability.promise;
} });


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(14);
var $JSON = core.JSON || (core.JSON = { stringify: JSON.stringify });
module.exports = function stringify(it) { // eslint-disable-line no-unused-vars
  return $JSON.stringify.apply($JSON, arguments);
};


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(90);
module.exports = __webpack_require__(14).Object.assign;


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(17);

$export($export.S + $export.F, 'Object', { assign: __webpack_require__(91) });


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = __webpack_require__(35);
var gOPS = __webpack_require__(92);
var pIE = __webpack_require__(93);
var toObject = __webpack_require__(30);
var IObject = __webpack_require__(47);
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__(27)(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;


/***/ }),
/* 92 */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),
/* 93 */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(95), __esModule: true };

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(96);
module.exports = __webpack_require__(14).Number.isInteger;


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var $export = __webpack_require__(17);

$export($export.S, 'Number', { isInteger: __webpack_require__(97) });


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var isObject = __webpack_require__(21);
var floor = Math.floor;
module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(99), __esModule: true };

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(100);
module.exports = __webpack_require__(14).Object.keys;


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__(30);
var $keys = __webpack_require__(35);

__webpack_require__(101)('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(17);
var core = __webpack_require__(14);
var fails = __webpack_require__(27);
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(25);
__webpack_require__(103);
module.exports = __webpack_require__(14).Array.from;


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ctx = __webpack_require__(24);
var $export = __webpack_require__(17);
var toObject = __webpack_require__(30);
var call = __webpack_require__(52);
var isArrayIter = __webpack_require__(53);
var toLength = __webpack_require__(37);
var createProperty = __webpack_require__(104);
var getIterFn = __webpack_require__(42);

$export($export.S + $export.F * !__webpack_require__(58)(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $defineProperty = __webpack_require__(20);
var createDesc = __webpack_require__(34);

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _from = __webpack_require__(61);

var _from2 = _interopRequireDefault(_from);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  } else {
    return (0, _from2.default)(arr);
  }
};

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(107), __esModule: true };

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(40);
__webpack_require__(25);
module.exports = __webpack_require__(108);


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(41);
var ITERATOR = __webpack_require__(15)('iterator');
var Iterators = __webpack_require__(23);
module.exports = __webpack_require__(14).isIterable = function (it) {
  var O = Object(it);
  return O[ITERATOR] !== undefined
    || '@@iterator' in O
    // eslint-disable-next-line no-prototype-builtins
    || Iterators.hasOwnProperty(classof(O));
};


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(110), __esModule: true };

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(40);
__webpack_require__(25);
module.exports = __webpack_require__(111);


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(18);
var get = __webpack_require__(42);
module.exports = __webpack_require__(14).getIterator = function (it) {
  var iterFn = get(it);
  if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');
  return anObject(iterFn.call(it));
};


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(113);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (obj, key, value) {
  if (key in obj) {
    (0, _defineProperty2.default)(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(114), __esModule: true };

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(115);
var $Object = __webpack_require__(14).Object;
module.exports = function defineProperty(it, key, desc) {
  return $Object.defineProperty(it, key, desc);
};


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(17);
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__(22), 'Object', { defineProperty: __webpack_require__(20).f });


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(117);


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g = (function() { return this })() || Function("return this")();

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = __webpack_require__(118);

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}


/***/ }),
/* 118 */
/***/ (function(module, exports) {

/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  (function() { return this })() || Function("return this")()
);


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _promise = __webpack_require__(44);

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (fn) {
  return function () {
    var gen = fn.apply(this, arguments);
    return new _promise2.default(function (resolve, reject) {
      function step(key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }

        if (info.done) {
          resolve(value);
        } else {
          return _promise2.default.resolve(value).then(function (value) {
            step("next", value);
          }, function (err) {
            step("throw", err);
          });
        }
      }

      return step("next");
    });
  };
};

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stringify = __webpack_require__(59);

var _stringify2 = _interopRequireDefault(_stringify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var storage = function storage() {
  var fallBack = {
    storage: {},
    setItem: function setItem(key, value) {
      this.storage[key] = value;
    },
    getItem: function getItem(key) {
      return this.storage[key];
    }
  };
  var chooseStorage = function chooseStorage(typeOfStorage) {
    try {
      if (typeOfStorage in window && window[typeOfStorage] !== null) {
        return window[typeOfStorage];
      }
      return fallBack;
    } catch (e) {
      return false;
    }
  };

  return {
    setUp: function setUp() {
      var typeOfStorage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'sessionStorage';

      var storageType = chooseStorage(typeOfStorage);
      return {
        set: function set(key, value) {
          storageType.setItem(key, (0, _stringify2.default)(value));
        },
        get: function get(key) {
          return JSON.parse(storageType.getItem(key));
        },
        remove: function remove(key) {
          storageType.removeItem(key);
        }
      };
    }
  };
};

var db = storage();
exports.default = db.setUp();

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMzA2NWE1NDBjM2Y5ODgzMGZiNmUiLCJ3ZWJwYWNrOi8vLy4vc3JjL3N0YXJ0LXBhZ2UvdmFyaWFudC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbC9tYWluLmpzIiwid2VicGFjazovLy8uL3NyYy91dGlsL21vZHVsZXMvcmF0aW5ncy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc3RhcnQtcGFnZS9iYW5uZXJzLmpzIiwid2VicGFjazovLy8uL3NyYy9zdGFydC1wYWdlL3N0eWxlLmNzcz82NDkwIiwid2VicGFjazovLy8uL3NyYy9zdGFydC1wYWdlL3N0eWxlLmNzcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL3VybHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3N0YXJ0LXBhZ2UvY291cG9ucy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc3RhcnQtcGFnZS9jb3Vwb25zLXN0eWxlLmNzcz8yZDE5Iiwid2VicGFjazovLy8uL3NyYy9zdGFydC1wYWdlL2NvdXBvbnMtc3R5bGUuY3NzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29yZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2V4cG9ydC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXJhdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2N0eC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2EtZnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19mYWlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hhcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZWZpbmVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWlvYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1sZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jbGFzc29mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvcHJvbWlzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbGlicmFyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lvYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL191aWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faHRtbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY2FsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLWFycmF5LWl0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdGFzay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3BlcmZvcm0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wcm9taXNlLXJlc29sdmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWRldGVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL2pzb24vc3RyaW5naWZ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2Fzc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL2FycmF5L2Zyb20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vcHJvbWlzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3N0cmluZy1hdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcmVkZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHBzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWFic29sdXRlLWluZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdwby5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1zdGVwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYucHJvbWlzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLWluc3RhbmNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZm9yLW9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faW52b2tlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbWljcm90YXNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcmVkZWZpbmUtYWxsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXNwZWNpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5wcm9taXNlLmZpbmFsbHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5wcm9taXNlLnRyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL2pzb24vc3RyaW5naWZ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2Fzc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtYXNzaWduLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtcGllLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvbnVtYmVyL2lzLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9udW1iZXIvaXMtaW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm51bWJlci5pcy1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtaW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2tleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3Qua2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1zYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9hcnJheS9mcm9tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuZnJvbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NyZWF0ZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL3RvQ29uc3VtYWJsZUFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvaXMtaXRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9pcy1pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5pcy1pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL2dldC1pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL2dldC1pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLW1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbC9tb2R1bGVzL3N0b3JhZ2UuanMiXSwibmFtZXMiOlsiJCIsIkxPR0lOX0FDVElPTiIsIlNBVkVfUkVDSVBFIiwiTE9BRF9DT1VQT04iLCJBQ1RJT05fQ09PS0lFUyIsImxvYWRlZENvdXBvbnMiLCJ0ZXN0IiwiY3JlYXRlIiwiY2xhc3NOYW1lIiwicGFyZW50IiwidGV4dCIsInR5cGUiLCJ0IiwiZGl2IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50Iiwic3JjIiwiYXBwZW5kQ2hpbGQiLCJjcmVhdGVUZXh0Tm9kZSIsImFkZENvdXBvbiIsImNvdXBvbiIsImNvdXBvbkl0ZW0iLCJpbWciLCJ0aXRsZSIsImRpc2NvdW50Iiwic3VidGl0bGUiLCJtb3JlSW5mbyIsImJ1dHRvbiIsImltYWdlIiwiaHJlZiIsInVybCIsImNsaWNrIiwiaXNMb2dnZWRJbiIsImxvYWRDb3Vwb25PbkNhcmQiLCJ0aGVuIiwicmVzcG9uc2UiLCJjaGFuZ2VPZmZlclN0YXR1cyIsImljYWRhdGFsYXllciIsImFkZCIsIkhTRSIsImFjdGlvbiIsIm5hbWUiLCJQYWdlTmFtZSIsImhzZXVybCIsImNvb2tpZURhdGEiLCJyZWNpcGVJZCIsIk9mZmVySWQiLCJPZmZlciIsIkNhbXBhaWduSWQiLCJzZXRBY3Rpb25Db29raWUiLCJjcmVhdGVNb2RhbCIsImF0dHIiLCJsb2FkQ291cG9uRGF0YSIsImRhdGEiLCJMb2FkZWRPbkNhcmQiLCJjc3MiLCJhcHBlbmRBbGwiLCJhZGRCYW5uZXIiLCJiYW5uZXIiLCJiYW5uZXJDb250YWluZXIiLCJiYW5uZXJDb250YWluZXJJbWciLCJ0ZXh0Q29udGFpbmVyIiwibGluayIsInJhdGluZ3MiLCJkaWZmaWN1bHR5IiwiY291cG9uc1dyYXBwZXIiLCJzYXZlQnV0dG9uIiwiY3JlYXRlU2F2ZVJlY2lwZUNUQSIsImFwcGVuZCIsImh0bWwiLCJzdGFycyIsImNvb2tUaW1lIiwiY291cG9ucyIsImZvckVhY2giLCJhZGRTdHlsZSIsImVsZW1lbnQiLCJzdGwiLCJzdHlsZSIsImFkZEJhbm5lcnMiLCJoZWFkZXIiLCJnZXQiLCJ1bCIsInNsaWNrIiwiYWRhcHRpdmVIZWlnaHQiLCJhZGRJY2FDYXJkIiwic2VsZiIsImljYUltYWdlQ29udGFpbmVyIiwidXNwcyIsImlubmVySFRNTCIsInF1ZXJ5U2VsZWN0b3IiLCJkaW5uZXJUb25pZ2h0IiwiY29udGFpbmVyIiwicmVjaXBlVHJlbmRpbmdMaXN0Iiwic2VlQWxsIiwiY29weSIsInJlbW92ZUVsZW1lbnRzIiwiYXBwZW5kRmlyc3QiLCJtYW5pcHVsYXRlRG9tIiwiY3JlYXRlT2ZmZXJzIiwicmV0dXJuVXJsIiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwid2luZG93IiwibG9jYXRpb24iLCJpZnJhbWVDb250YWluZXIiLCJjdGEiLCJlIiwicHJldmVudERlZmF1bHQiLCJhZGRSZWNpcGVUb1Nob3BwaW5nTGlzdCIsInRvZ2dsZSIsInNldFRpbWVvdXQiLCJtYWluIiwib2ZmZXJCdXR0b24iLCJJQ0EiLCJhamF4IiwicG9zdCIsInJlY2lwZUlkcyIsIlNob3BwaW5nTGlzdElkIiwibnVtYmVyT2ZTZXJ2aW5ncyIsInJlY2lwZXMiLCJzaG9wcGluZ0xpc3ROYW1lIiwiY3JlYXRlU2hvcHBpbmdzTGlzdE5hbWUiLCJkIiwiRGF0ZSIsInllYXIiLCJnZXRGdWxsWWVhciIsIm1vbnRoIiwiZ2V0TW9udGgiLCJkYXkiLCJnZXREYXRlIiwibW9udGhzIiwiY29va2llTmFtZSIsInNldERhdGUiLCJsZWdhY3kiLCJzZXRDb29raWUiLCJnZXRBY3Rpb25Db29raWUiLCJhY3Rpb25Db29raWUiLCJnZXRDb29raWUiLCJraWxsQ29va2llIiwiSlNPTiIsInBhcnNlIiwiY2hlY2tBY3Rpb25Db29raWVzIiwib2siLCJsb2FkZXJJc0FjdGl2ZSIsImJ1dHRvbkhhbmRsZXJQb2xsVGltZW91dCIsInNob3dMb2FkZXIiLCJmaW5kIiwic2hvdyIsImhpZGVMb2FkZXIiLCJoaWRlIiwiYWRkQnV0dG9uSGFuZGxlclBvbGwiLCJpZnJhbWUiLCJjb250ZW50cyIsImxlbmd0aCIsImNsZWFyVGltZW91dCIsImJpbmQiLCJhZGRFdmVudExpc3RlbmVycyIsIm9mZiIsIm9uIiwib3JpZ2luIiwicHJvdG9jb2wiLCJob3N0Iiwib3JpZ2luYWxFdmVudCIsImdldElmcmFtZVN0eWxlcyIsIm1vZGFsIiwiY29yZUNvbXBvbmVudHMiLCJ0cGwiLCJzaXplIiwicmVnZXgiLCJSZWdFeHAiLCJjb250ZW50V2luZG93IiwicmVsb2FkIiwiaW5kZXhPZiIsImhpZGVIZWFkZXJCYXIiLCJoZWFkZXJCYXJUaW1lb3V0IiwiaGlkZUhlYWRlckJhckRlZmVycmVkIiwicmVzb2x2ZSIsImFwcGVuZEhlYWRlciIsIm1lc3NhZ2UiLCJzY3JlZW4iLCJ3aWR0aCIsImFwcGVuZEhlYWRlclRpbWVvdXQiLCJhcHBlbmRIZWFkZXJEZWZlcnJlZCIsImFkZFN0eWxlcyIsImFkZFN0eWxlc1RpbWVvdXQiLCJhZGRTdHlsZXNEZWZlcnJlZCIsImFkZElmcmFtZVRyYWNraW5nIiwiZXZlbnRBY3Rpb24iLCJnYSIsImFkZElmcmFtZVRyYWNraW5nVGltZW91dCIsImFkZElmcmFtZVRyYWNraW5nRGVmZXJyZWQiLCJEZWZlcnJlZCIsIndoZW4iLCJkb25lIiwiZWFjaCIsInJlcGxhY2UiLCJmZXRjaCIsImlkIiwiY3JlZGVudGlhbHMiLCJqc29uIiwib3B0cyIsIlN0b3JlSWQiLCJTdG9yZUdyb3VwSWQiLCJtZXRob2QiLCJoZWFkZXJzIiwiQWNjZXB0IiwiYm9keSIsIm9mZmVyIiwicmVzZXRQYXJhbGxheFNjcm9sbGluZyIsImljYUNhbGxiYWNrcyIsIiRwYXJhbGxheENvbnRhaW5lcnMiLCJyZWFkeSIsIklDIiwialF1ZXJ5IiwicmVzZXJ2ZWRFbGVtZW50cyIsIkdldEVsZW1lbnQiLCJzZWxlY3RvciIsIiRFTE1fRUxFTUVOVCIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJhcmciLCJhcmdzIiwic3BsaXQiLCJ2YWx1ZSIsInNldEF0dHJpYnV0ZSIsImdldEF0dHJpYnV0ZSIsIkVycm9yIiwiaGVpZ2h0IiwiY2FsbGJhY2siLCJhZGRFdmVudExpc3RlbmVyIiwic3RyIiwiaW5uZXJUZXh0IiwidGV4dENvbnRlbnQiLCJjaGlsZCIsImMiLCJub2RlVHlwZSIsImluc2VydEJlZm9yZSIsImNoaWxkTm9kZXMiLCJjaGlsZHMiLCJtYXAiLCJjbiIsImpvaW4iLCJjbGFzc0xpc3QiLCJ0cmltIiwiY2hpbGRyZW4iLCJsaXN0IiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJrZXkiLCJkYXRhc2V0IiwiQ3JlYXRlRWxlbWVudCIsIkhUTUxFbGVtZW50IiwiYXJyIiwicmVkdWNlIiwiYWNjIiwiY3VycmVudCIsImluY2x1ZGVzIiwiY2xhc3NOYW1lcyIsImZpbHRlciIsImRvbSIsIkNyZWF0ZUVsZW1lbnRCeU9iamVjdCIsIml0ZXJhYmxlIiwiaXRlbSIsImZ1bmMiLCIkRUxNIiwiZWxtcyIsImJ1aWxkIiwicGFyc2VJbnQiLCJzYXZlIiwiY2xvbmVOb2RlIiwiSUNBQ1JPIiwiZ2V0RWxlbWVudENvbnRlbnRCeVRhZ0FuZEF0dHIiLCJyZWdleHAiLCJ0YWciLCJxc2EiLCJxdWVyeVNlbGVjdG9yQWxsIiwidG9BcnJheSIsInB1c2giLCJlbG0iLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJBcnJheSIsInByb3RvdHlwZSIsInNsaWNlIiwiY2FsbCIsImxvYWQiLCJvcHRpb25zIiwib3BzIiwiY2F0Y2giLCJlcnIiLCJzdHlsZXMiLCJjb25zb2xlIiwibG9nIiwiZ2FQdXNoIiwiZXZlbnRDYXRlZ29yeSIsImV2ZW50TGFiZWwiLCJzdG9yYWdlIiwic2V0IiwicmVtb3ZlIiwic3RycyIsIngiLCJpbmRleCIsInByaW50QmFubmVyIiwiY29udGVudCIsInByZWFtYmxlIiwiaXNVc2VkIiwiaXNVc2VkQ2xhc3MiLCJiYW5uZXJFbGVtZW50IiwiYmFubmVyUm93IiwiYmFubmVyQ29sdW1uMSIsImJhbm5lckNvbHVtbjIiLCJiYW5uZXJDb2x1bW4zIiwiaW1nRWxlbWVudCIsInRpdGxlRWxlbWVudCIsImRpc2NvdW50RWxlbWVudCIsInByZWFtYmxlRWxlbWVudCIsImltZ0hvbGRlciIsInJlYWRNb3JlIiwiZG93bkxvYWQiLCJidXR0b25UZXh0Iiwib25DbGljayIsImV2ZW50IiwiY2hlY2tBY3Rpb25Db29raWUiLCJkZWFjdGl2YXRlQ291cG9uIiwiUHJvZHVjdE5hbWUiLCJsb2FkQmFubmVycyIsImlkcyIsIkhlYWRlciIsIk9mZmVyQ29uZGl0aW9uIiwiQnJhbmQiLCJTaXplT3JRdWFudGl0eSIsIkNvbmRpdGlvbnMiLCJUZXh0IiwiSW1hZ2UiLCJJbWFnZVVybCIsImFkZElmcmFtZSIsImJhbm5lcnMiLCJtYXRjaCIsImZhbGxCYWNrIiwic2V0SXRlbSIsImdldEl0ZW0iLCJjaG9vc2VTdG9yYWdlIiwidHlwZU9mU3RvcmFnZSIsInNldFVwIiwic3RvcmFnZVR5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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxLQUFLO0FBQ0wsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3Qjs7Ozs7Ozs7QUN6dEJBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyQ0EsSUFBTThOLFVBQVUsU0FBVkEsT0FBVSxHQUFNO0FBQ3BCLE1BQU0wQyxXQUFXO0FBQ2YxQyxhQUFTLEVBRE07QUFFZjJDLFdBRmUsbUJBRVAzRixHQUZPLEVBRUZ4QixLQUZFLEVBRUs7QUFDbEIsV0FBS3dFLE9BQUwsQ0FBYWhELEdBQWIsSUFBb0J4QixLQUFwQjtBQUNELEtBSmM7QUFLZm9ILFdBTGUsbUJBS1A1RixHQUxPLEVBS0Y7QUFDWCxhQUFPLEtBQUtnRCxPQUFMLENBQWFoRCxHQUFiLENBQVA7QUFDRDtBQVBjLEdBQWpCO0FBU0EsTUFBTTZGLGdCQUFnQixTQUFoQkEsYUFBZ0IsQ0FBQ0MsYUFBRCxFQUFtQjtBQUN2QyxRQUFJO0FBQ0YsVUFBSUEsaUJBQWlCL08sTUFBakIsSUFBMkJBLE9BQU8rTyxhQUFQLE1BQTBCLElBQXpELEVBQStEO0FBQzdELGVBQU8vTyxPQUFPK08sYUFBUCxDQUFQO0FBQ0Q7QUFDRCxhQUFPSixRQUFQO0FBQ0QsS0FMRCxDQUtFLE9BQU92TyxDQUFQLEVBQVU7QUFDVixhQUFPLEtBQVA7QUFDRDtBQUNGLEdBVEQ7O0FBV0EsU0FBTztBQUNMNE8sU0FESyxtQkFDbUM7QUFBQSxVQUFsQ0QsYUFBa0MsdUVBQWxCLGdCQUFrQjs7QUFDdEMsVUFBTUUsY0FBY0gsY0FBY0MsYUFBZCxDQUFwQjtBQUNBLGFBQU87QUFDTDdDLFdBREssZUFDRGpELEdBREMsRUFDSXhCLEtBREosRUFDVztBQUNkd0gsc0JBQVlMLE9BQVosQ0FBb0IzRixHQUFwQixFQUF5Qix5QkFBZXhCLEtBQWYsQ0FBekI7QUFDRCxTQUhJO0FBSUw5SSxXQUpLLGVBSURzSyxHQUpDLEVBSUk7QUFDUCxpQkFBTzVHLEtBQUtDLEtBQUwsQ0FBVzJNLFlBQVlKLE9BQVosQ0FBb0I1RixHQUFwQixDQUFYLENBQVA7QUFDRCxTQU5JO0FBT0xrRCxjQVBLLGtCQU9FbEQsR0FQRixFQU9PO0FBQ1ZnRyxzQkFBWUMsVUFBWixDQUF1QmpHLEdBQXZCO0FBQ0Q7QUFUSSxPQUFQO0FBV0Q7QUFkSSxHQUFQO0FBZ0JELENBckNEOztBQXVDQSxJQUFNa0csS0FBS2xELFNBQVg7a0JBQ2VrRCxHQUFHSCxLQUFILEUiLCJmaWxlIjoidmFyaWFudC5taW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAwKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCAzMDY1YTU0MGMzZjk4ODMwZmI2ZSIsIi8qIGVzbGludCBuby1pbm5lci1kZWNsYXJhdGlvbnM6IFwib2ZmXCIgKi9cclxuLyogZXNsaW50IG5vLXVzZS1iZWZvcmUtZGVmaW5lOiBcIm9mZlwiICovXHJcblxyXG4vLyA9PVVzZXJTY3JpcHQ9PVxyXG4vLyBAbmFtZSAgICAgICAgIFN0YXJ0LXBhZ2VcclxuLy8gQHBhdGggICAgICAgICAvLy4vc3JjL3N0YXJ0LXBhZ2UvdmFyaWFudC5qc1xyXG4vLyBAbmFtZXNwYWNlICAgIGh0dHA6Ly90YW1wZXJtb25rZXkubmV0L1xyXG4vLyBAdmVyc2lvbiAgICAgIDAuMVxyXG4vLyBAbWF0Y2ggICAgICAgIGh0dHBzOi8vd3d3LmljYS5zZS8qXHJcbi8vIEBncmFudCAgICAgICAgbm9uZVxyXG4vLyA9PS9Vc2VyU2NyaXB0PT1cclxuXHJcbmltcG9ydCB7IElDQUNSTywgJEVMTSB9IGZyb20gJy4uL3V0aWwvbWFpbic7XHJcbmltcG9ydCBSYXRpbmdzIGZyb20gJy4uL3V0aWwvbW9kdWxlcy9yYXRpbmdzJztcclxuaW1wb3J0IGJhbm5lcnMgZnJvbSAnLi9iYW5uZXJzJztcclxuaW1wb3J0IGNvdXBvbnMgZnJvbSAnLi9jb3Vwb25zJztcclxuXHJcbmltcG9ydCAnLi9zdHlsZS5jc3MnO1xyXG5cclxuKGZ1bmN0aW9uICgkKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICBjb25zdCBMT0dJTl9BQ1RJT04gPSB7XHJcbiAgICBTQVZFX1JFQ0lQRTogJ1NQQVJBJyxcclxuICAgIExPQURfQ09VUE9OOiAnTEFEREEnLFxyXG4gIH07XHJcbiAgY29uc3QgQUNUSU9OX0NPT0tJRVMgPSB7XHJcbiAgICBTQVZFX1JFQ0lQRTogJ2Nyb19zdGFydHBhZ2VfYWN0aW9uQ29va2llX3NhdmVSZWNpcGUnLFxyXG4gICAgTE9BRF9DT1VQT046ICdjcm9fc3RhcnRwYWdlX2FjdGlvbkNvb2tpZV9sb2FkQ291cG9uJyxcclxuICB9O1xyXG4gIGNvbnN0IGxvYWRlZENvdXBvbnMgPSBbXTtcclxuXHJcbiAgLy8gaWYgKGhqKSBoaigndHJpZ2dlcicsJ3ZhcmlhbnQ1Jyk7Ly8gZXNsaW50LWRpc2FibGUtbGluZVxyXG4gIGNvbnN0IHRlc3QgPSB7XHJcbiAgICBjcmVhdGUoY2xhc3NOYW1lLCBwYXJlbnQsIHRleHQsIHR5cGUpIHtcclxuICAgICAgY29uc3QgdCA9IHR5cGUgfHwgJ2Rpdic7XHJcbiAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodCk7XHJcbiAgICAgIGlmICh0ZXh0ICYmIHR5cGUgPT09ICdpbWcnKSB7XHJcbiAgICAgICAgZGl2LnNyYyA9IHRleHQ7XHJcbiAgICAgIH0gZWxzZSBpZiAodGV4dCkge1xyXG4gICAgICAgIGRpdi5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGNsYXNzTmFtZSkgZGl2LmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcclxuICAgICAgaWYgKHBhcmVudCkgcGFyZW50LmFwcGVuZENoaWxkKGRpdik7XHJcbiAgICAgIHJldHVybiBkaXY7XHJcbiAgICB9LFxyXG4gICAgYWRkQ291cG9uKGNvdXBvbikge1xyXG4gICAgICBjb25zdCBjb3Vwb25JdGVtID0gJEVMTS5jcmVhdGUoJ2NvdXBvbnMtY29udGFpbmVyX19pdGVtJyk7XHJcbiAgICAgIGNvbnN0IGltZyA9ICRFTE0uY3JlYXRlKCdpbWcnKTtcclxuICAgICAgY29uc3QgdGl0bGUgPSAkRUxNLmNyZWF0ZSgnaDMnKTtcclxuICAgICAgY29uc3QgZGlzY291bnQgPSAkRUxNLmNyZWF0ZSgnaDEnKTtcclxuICAgICAgY29uc3Qgc3VidGl0bGUgPSAkRUxNLmNyZWF0ZSgnaDQnKTtcclxuICAgICAgY29uc3QgbW9yZUluZm8gPSAkRUxNLmNyZWF0ZSgnYScpO1xyXG4gICAgICBjb25zdCBidXR0b24gPSAkRUxNLmNyZWF0ZSgnYnV0dG9uIC5idXR0b24gY291cG9uLWJ1dHRvbicpO1xyXG5cclxuICAgICAgdGl0bGUudGV4dChjb3Vwb24udGl0bGUpO1xyXG4gICAgICBkaXNjb3VudC50ZXh0KGNvdXBvbi5kaXNjb3VudCk7XHJcbiAgICAgIHN1YnRpdGxlLnRleHQoY291cG9uLnN1YnRpdGxlKTtcclxuICAgICAgbW9yZUluZm8udGV4dCgnTWVyIGluZm8nKTtcclxuICAgICAgYnV0dG9uLnRleHQoJ0xhZGRhIGt1cG9uZycpO1xyXG4gICAgICBpbWcuaW1hZ2UoY291cG9uLmltYWdlKTtcclxuICAgICAgbW9yZUluZm8uaHJlZihjb3Vwb24udXJsKTtcclxuXHJcbiAgICAgIGJ1dHRvbi5jbGljaygoKSA9PiB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNMb2dnZWRJbigpKSB7XHJcbiAgICAgICAgICB0aGlzLmxvYWRDb3Vwb25PbkNhcmQoY291cG9uKS50aGVuKChyZXNwb25zZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmNoYW5nZU9mZmVyU3RhdHVzKHJlc3BvbnNlLCBjb3Vwb24pO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGljYWRhdGFsYXllci5hZGQoJ0hTRScsIHtcclxuICAgICAgICAgICAgSFNFOiB7XHJcbiAgICAgICAgICAgICAgYWN0aW9uOiAnbG9naW4tbW91c2Vkb3duJyxcclxuICAgICAgICAgICAgICBuYW1lOiBjb3Vwb24uUGFnZU5hbWUsXHJcbiAgICAgICAgICAgICAgaHNldXJsOiBjb3Vwb24udXJsLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgY29uc3QgY29va2llRGF0YSA9IHtcclxuICAgICAgICAgICAgUGFnZU5hbWU6IGNvdXBvbi5QYWdlTmFtZSxcclxuICAgICAgICAgICAgcmVjaXBlSWQ6IGNvdXBvbi5yZWNpcGVJZCxcclxuICAgICAgICAgICAgdGl0bGU6IGNvdXBvbi5QYWdlTmFtZSxcclxuICAgICAgICAgICAgdXJsOiBjb3Vwb24uUGFnZU5hbWUsXHJcbiAgICAgICAgICAgIE9mZmVySWQ6IGNvdXBvbi5PZmZlcixcclxuICAgICAgICAgICAgQ2FtcGFpZ25JZDogY291cG9uLlBhZ2VOYW1lLFxyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICB0aGlzLnNldEFjdGlvbkNvb2tpZShBQ1RJT05fQ09PS0lFUy5MT0FEX0NPVVBPTiwgY29va2llRGF0YSk7XHJcbiAgICAgICAgICB0aGlzLmNyZWF0ZU1vZGFsKExPR0lOX0FDVElPTi5MT0FEX0NPVVBPTik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGljYWRhdGFsYXllci5hZGQoJ0hTRScsIHtcclxuICAgICAgICBIU0U6IHtcclxuICAgICAgICAgIGFjdGlvbjogJ2Rpc3BsYXknLFxyXG4gICAgICAgICAgdGl0bGU6IGNvdXBvbi5QYWdlTmFtZSxcclxuICAgICAgICAgIGhzZXVybDogY291cG9uLnVybCxcclxuICAgICAgICB9LFxyXG4gICAgICB9KTtcclxuICAgICAgY291cG9uSXRlbS5hdHRyKCdpZCcsIGBjb3Vwb24tJHtjb3Vwb24uT2ZmZXJJZH0tJHtjb3Vwb24ucmVjaXBlSWR9YCk7XHJcbiAgICAgIHRoaXMubG9hZENvdXBvbkRhdGEoY291cG9uKS50aGVuKChkYXRhKSA9PiB7XHJcbiAgICAgICAgaWYgKGRhdGEuT2ZmZXIuTG9hZGVkT25DYXJkKSB7XHJcbiAgICAgICAgICBjb3Vwb25JdGVtLmNzcygnb2ZmZXItbG9hZGVkJyk7XHJcbiAgICAgICAgICBidXR0b24udGV4dCgnS3Vwb25nIGxhZGRhZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIGNvdXBvbkl0ZW0uYXBwZW5kQWxsKGltZywgdGl0bGUsIGRpc2NvdW50LCBzdWJ0aXRsZSwgbW9yZUluZm8sIGJ1dHRvbik7XHJcbiAgICAgIHJldHVybiBjb3Vwb25JdGVtO1xyXG4gICAgfSxcclxuICAgIGFkZEJhbm5lcihiYW5uZXIpIHtcclxuICAgICAgY29uc3QgW1xyXG4gICAgICAgIGJhbm5lckNvbnRhaW5lcixcclxuICAgICAgICBiYW5uZXJDb250YWluZXJJbWcsXHJcbiAgICAgICAgaW1nLFxyXG4gICAgICAgIHRleHRDb250YWluZXIsXHJcbiAgICAgICAgbGluayxcclxuICAgICAgICB0aXRsZSxcclxuICAgICAgICByYXRpbmdzLFxyXG4gICAgICAgIGRpZmZpY3VsdHksXHJcbiAgICAgICAgY291cG9uc1dyYXBwZXIsXHJcbiAgICAgIF0gPSAkRUxNLmNyZWF0ZShcclxuICAgICAgICAnbGkgYmFubmVyLWNvbnRhaW5lcicsXHJcbiAgICAgICAgJ2Jhbm5lci1jb250YWluZXJfX2ltZycsXHJcbiAgICAgICAgJ2ltZycsXHJcbiAgICAgICAgJ2Jhbm5lci1jb250YWluZXJfX3RleHQtY29udGFpbmVyJyxcclxuICAgICAgICAnYSB0ZXh0LWNvbnRhaW5lcl9fbGluaycsXHJcbiAgICAgICAgJ2gxIHRleHQtY29udGFpbmVyX190aXRsZScsXHJcbiAgICAgICAgJ3RleHQtY29udGFpbmVyX19yYXRpbmdzJyxcclxuICAgICAgICAnaDQgdGV4dC1jb250YWluZXJfX2RpZmZpY3VsdHknLFxyXG4gICAgICAgICdjb3Vwb25zLWNvbnRhaW5lcicsXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBjb25zdCBzYXZlQnV0dG9uID0gdGhpcy5jcmVhdGVTYXZlUmVjaXBlQ1RBKGJhbm5lcik7XHJcblxyXG4gICAgICBpbWcuaW1hZ2UoYmFubmVyLmltYWdlKTtcclxuICAgICAgYmFubmVyQ29udGFpbmVySW1nLmFwcGVuZChpbWcpO1xyXG4gICAgICBiYW5uZXJDb250YWluZXJJbWcuaW1hZ2UoYmFubmVyLmltYWdlKTtcclxuXHJcbiAgICAgIHJhdGluZ3MuaHRtbChSYXRpbmdzKGJhbm5lci5zdGFycykpO1xyXG4gICAgICB0aXRsZS50ZXh0KGJhbm5lci50aXRsZSk7XHJcbiAgICAgIGRpZmZpY3VsdHkudGV4dChiYW5uZXIuY29va1RpbWUpO1xyXG5cclxuICAgICAgYmFubmVyLmNvdXBvbnMuZm9yRWFjaCgoY291cG9uKSA9PiB7XHJcbiAgICAgICAgY291cG9uc1dyYXBwZXIuYXBwZW5kKHRoaXMuYWRkQ291cG9uKGNvdXBvbikpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGxpbmsuaHJlZihiYW5uZXIudXJsKTtcclxuICAgICAgbGluay5hcHBlbmRBbGwodGl0bGUsIHJhdGluZ3MsIGRpZmZpY3VsdHkpO1xyXG4gICAgICB0ZXh0Q29udGFpbmVyLmFwcGVuZChsaW5rKTtcclxuICAgICAgYmFubmVyQ29udGFpbmVyLmFwcGVuZEFsbChiYW5uZXJDb250YWluZXJJbWcsIHRleHRDb250YWluZXIsIHNhdmVCdXR0b24sIGNvdXBvbnNXcmFwcGVyKTtcclxuICAgICAgcmV0dXJuIGJhbm5lckNvbnRhaW5lcjtcclxuICAgIH0sXHJcbiAgICBhZGRTdHlsZShlbGVtZW50LCBzdGwpIHtcclxuICAgICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LnN0eWxlLCBzdGwpO1xyXG4gICAgfSxcclxuICAgIGFkZEJhbm5lcnMoKSB7XHJcbiAgICAgIGNvbnN0IGhlYWRlciA9ICRFTE0uZ2V0KCcuaGVhZGVyJyk7XHJcbiAgICAgIGNvbnN0IHVsID0gJEVMTS5jcmVhdGUoJ3VsIGNyby1zbGlkZXInKTtcclxuICAgICAgaGVhZGVyLmh0bWwoJyAnKTtcclxuICAgICAgYmFubmVycy5mb3JFYWNoKChiYW5uZXIpID0+IHtcclxuICAgICAgICB1bC5hcHBlbmQodGhpcy5hZGRCYW5uZXIoYmFubmVyKSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBoZWFkZXIuYXBwZW5kKHVsKTtcclxuICAgICAgLy8gY29uc29sZS5sb2codWwuY2hpbGRyZW4oJ2xpJylbMF0uaGVpZ2h0KCkpO1xyXG4gICAgICAvLyB1bC5zdHlsZSh7XHJcbiAgICAgIC8vICAgd2lkdGg6IGAkezEwMCAqIGJhbm5lcnMubGVuZ3RofSVgLFxyXG4gICAgICAvLyAgIC8vIGhlaWdodDogYCR7dWwuY2hpbGRyZW4oJ2xpJylbMF0uaGVpZ2h0KCkudG9TdHJpbmcoKX1weGAsXHJcbiAgICAgIC8vIH0pO1xyXG4gICAgICAkKCcuY3JvLXNsaWRlcicpLnNsaWNrKHtcclxuICAgICAgICBhZGFwdGl2ZUhlaWdodDogdHJ1ZVxyXG4gICAgICB9KTtcclxuICAgIH0sXHJcbiAgICBhZGRJY2FDYXJkKCkge1xyXG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcclxuICAgICAgY29uc3QgaWNhSW1hZ2VDb250YWluZXIgPSBzZWxmLmNyZWF0ZSgnaWNhLWNhcmQtY29udGFpbmVyJyk7XHJcbiAgICAgIHNlbGYuY3JlYXRlKCcnLCBpY2FJbWFnZUNvbnRhaW5lciwgJ0bDpSByYWJhdHQgbWVkIElDQS1Lb3J0JywgJ2gxJyk7XHJcbiAgICAgIGNvbnN0IHVzcHMgPSBzZWxmLmNyZWF0ZSgndXNwLWxpc3QnLCBpY2FJbWFnZUNvbnRhaW5lciwgbnVsbCwgJ3VsJyk7XHJcbiAgICAgIHVzcHMuaW5uZXJIVE1MID0gYFxyXG4gICAgICA8bGk+PHN2ZyB2aWV3Qm94PVwiMCAwIDMyIDMyXCIgd2lkdGg9XCIxNXB4XCIgaGVpZ2h0PVwiMTVweFwiPjx1c2UgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgeGxpbms6aHJlZj1cIi9Bc3NldHMvaWNvbnMvc3ByaXRlLnN2ZyNjaGVja1wiPjwvdXNlPjwvc3ZnPiBJQ0Eta29ydCBtZWQgYm9udXM8L2xpPlxyXG4gICAgICA8bGk+PHN2ZyB2aWV3Qm94PVwiMCAwIDMyIDMyXCIgd2lkdGg9XCIxNXB4XCIgaGVpZ2h0PVwiMTVweFwiPjx1c2UgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgeGxpbms6aHJlZj1cIi9Bc3NldHMvaWNvbnMvc3ByaXRlLnN2ZyNjaGVja1wiPjwvdXNlPjwvc3ZnPiBQZXJzb25saWdhIGVyYmp1ZGFuZGVuPC9saT5cclxuICAgICAgPGxpPjxzdmcgdmlld0JveD1cIjAgMCAzMiAzMlwiIHdpZHRoPVwiMTVweFwiIGhlaWdodD1cIjE1cHhcIj48dXNlIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiIHhsaW5rOmhyZWY9XCIvQXNzZXRzL2ljb25zL3Nwcml0ZS5zdmcjY2hlY2tcIj48L3VzZT48L3N2Zz4gS29ydHByaXNlciB2YXJqZSB2ZWNrYTwvbGk+XHJcbiAgICAgIGA7XHJcbiAgICAgIHNlbGYuY3JlYXRlKCcnLCBpY2FJbWFnZUNvbnRhaW5lciwgJ2h0dHBzOi8vd3d3LmljYS5zZS9JbWFnZVZhdWx0RmlsZXMvaWRfNzg2NDkvY2ZfMy9JQ0FfS29ydF9vY2hfQmFuay5wbmcnLCAnaW1nJyk7XHJcbiAgICAgIHNlbGYuY3JlYXRlKCdidXR0b24nLCBpY2FJbWFnZUNvbnRhaW5lciwgJ1NrYXBhIGtvbnRvIG9jaCBibGkgbWVkbGVtJywgJ2EnKVxyXG4gICAgICAgIC5ocmVmID0gJy9hbnNva2FuLz9zdGVwPTYzNjk3NjY5NjM2NjZmNzI2ZCc7XHJcbiAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tYWluJykuYXBwZW5kQ2hpbGQoaWNhSW1hZ2VDb250YWluZXIpO1xyXG4gICAgfSxcclxuICAgIGRpbm5lclRvbmlnaHQoKSB7XHJcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9ICRFTE0uZ2V0KCcuc2VhcmNoLXJlY2lwZS1jb250YWluZXInKTtcclxuICAgICAgY29uc3QgcmVjaXBlVHJlbmRpbmdMaXN0ID0gJEVMTS5nZXQoJy5yZWNpcGUtdHJlbmRpbmctbGlzdCcpO1xyXG4gICAgICBjb25zdCBpbWcgPSAkRUxNLmNyZWF0ZSgnaW1nJykuaW1hZ2UoJy9pbWFnZXZhdWx0ZmlsZXMvaWRfMTI0MzAwL2NmXzI1OS9ueXR0aWdhX3JlY2VwdC5qcGcnKTtcclxuICAgICAgY29uc3Qgc2VlQWxsID0gJEVMTS5jb3B5KCcuc2VhcmNoLXJlY2lwZS1jb250YWluZXJfX2FsbC1yZWNpcGVzJyk7XHJcbiAgICAgIHRoaXMucmVtb3ZlRWxlbWVudHMoWycuc2VhcmNoLXJlY2lwZS1jb250YWluZXJfX2FsbC1yZWNpcGVzJ10pO1xyXG4gICAgICByZWNpcGVUcmVuZGluZ0xpc3QuYXBwZW5kKHNlZUFsbCk7XHJcbiAgICAgIGNvbnRhaW5lci5hcHBlbmRGaXJzdChpbWcpO1xyXG4gICAgICBjb250YWluZXIuZ2V0KCdoMScpLnRleHQoJ1ZhZCBibGlyIGRldCBmw7ZyIG1pZGRhZyBpa3bDpGxsPycpO1xyXG4gICAgfSxcclxuICAgIG1hbmlwdWxhdGVEb20oKSB7XHJcbiAgICAgIHRoaXMucmVtb3ZlRWxlbWVudHMoW1xyXG4gICAgICAgICcuaW1hZ2Utc2xpZGVyIGxpJyxcclxuICAgICAgICAnLmltYWdlLXNsaWRlciAubGF6eS1zcGlubmVyJyxcclxuICAgICAgICAnLmhlYWRlci1jb250ZW50JyxcclxuICAgICAgICAnLnB1c2gtaXRlbXMtbGlzdCcsXHJcbiAgICAgICAgJy5xdWlja2xpbmstbGlzdCcsXHJcbiAgICAgICAgJy5tYWluIC5saW5rLWxpc3QnLFxyXG4gICAgICAgICcucmVjaXBlLWNhdGVnb3J5LWxpc3RpbmcgLmJhbm5lci1pbWFnZScsXHJcbiAgICAgICAgJy5yZWNpcGUtY2F0ZWdvcnktbGlzdGluZyA+IC5jb2wtMTIgPiBoMicsXHJcbiAgICAgICAgJy5zZWFyY2gtcmVjaXBlLWNvbnRhaW5lcl9fcmVjaXBlLWNvdW50JyxcclxuICAgICAgICAnLnJlY2lwZS1jYXRlZ29yeS1saXN0aW5nIC5yZWNpcGUtbGlzdC1pdGVtcycsXHJcbiAgICAgIF0pO1xyXG4gICAgICB0aGlzLmFkZEJhbm5lcnMoKTtcclxuICAgICAgdGhpcy5jcmVhdGVPZmZlcnMoKTtcclxuICAgICAgdGhpcy5hZGRJY2FDYXJkKCk7XHJcbiAgICAgIHRoaXMuZGlubmVyVG9uaWdodCgpO1xyXG4gICAgICBjb25zdCByZXR1cm5VcmwgPSBlbmNvZGVVUklDb21wb25lbnQod2luZG93LmxvY2F0aW9uLmhyZWYpO1xyXG4gICAgICBjb25zdCBpZnJhbWVDb250YWluZXIgPSAkKGA8ZGl2IGNsYXNzPVwiY3JvLWlmcmFtZS1jb250YWluZXJcIj48c3BhbiBjbGFzcz1cImxvYWRlclwiPjwvc3Bhbj48aWZyYW1lIHNyYz1cIi8vd3d3LmljYS5zZS9sb2dnYS1pbi8/cmV0dXJudXJsPSR7cmV0dXJuVXJsfVwiIGZyYW1lYm9yZGVyPVwiMFwiPjwvaWZyYW1lPjwvZGl2PmApO1xyXG4gICAgICAkKCdib2R5JykuYXBwZW5kKGlmcmFtZUNvbnRhaW5lcik7XHJcbiAgICB9LFxyXG4gICAgY3JlYXRlU2F2ZVJlY2lwZUNUQShiYW5uZXIpIHtcclxuICAgICAgY29uc3QgY29udGFpbmVyID0gJEVMTS5jcmVhdGUoJ2J1dHRvbi13cmFwcGVyJyk7XHJcbiAgICAgIGNvbnN0IGN0YSA9ICRFTE0uY3JlYXRlKCdhIC5idXR0b24gYmFubmVyLWJ1dHRvbicpO1xyXG4gICAgICBjdGEuaHRtbCgnPGRpdiBjbGFzcz1cImxheWVyXCI+PHN2ZyB2aWV3Qm94PVwiMCAwIDMyIDMyXCIgd2lkdGg9XCIxNXB4XCIgaGVpZ2h0PVwiMTVweFwiPjx1c2UgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgeGxpbms6aHJlZj1cIi9Bc3NldHMvaWNvbnMvc3ByaXRlLnN2ZyNjaGVja1wiPjwvdXNlPjwvc3ZnPjwvZGl2PkzDpGdnIHJlY2VwdCBpIGlua8O2cHNsaXN0YW4nKTtcclxuICAgICAgY3RhLmhyZWYoYCNgKTtcclxuICAgICAgY3RhLmRhdGEoJ3JlY2lwZUlkJywgYmFubmVyLnJlY2lwZUlkKTtcclxuICAgICAgY3RhLmRhdGEoJ3RyYWNraW5nJywgYHsgXCJuYW1lXCI6IFwiJHtiYW5uZXIudGl0bGV9XCIsIFwiVVJMXCI6IFwiJHtiYW5uZXIudXJsfVwiIH1gKTtcclxuICAgICAgY3RhLmNzcyhganMtYWRkLXRvLW5ldy1zaG9wcGluZ2xpc3QgYmFubmVyLWJ1dHRvbi0ke2Jhbm5lci5yZWNpcGVJZH1gKTtcclxuXHJcbiAgICAgIGN0YS5jbGljaygoZSkgPT4ge1xyXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB0aGlzLmFkZFJlY2lwZVRvU2hvcHBpbmdMaXN0KGJhbm5lci5yZWNpcGVJZCk7XHJcbiAgICAgICAgY3RhLnRvZ2dsZSgnYWRkZWQnKTtcclxuICAgICAgICAkRUxNLmdldCgnI2pzLXRvZ2dsZS1hdmF0YXInKS5jc3MoJ2Nyby1zdGFydHBhZ2Utc2hvcHBpbmdsaXN0LWNvYWNobWFyaycpO1xyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gY3RhLnRvZ2dsZSgnYWRkZWQnKSwgMTUwMCk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBjb250YWluZXIuYXBwZW5kKGN0YSk7XHJcbiAgICAgIHJldHVybiBjb250YWluZXI7XHJcbiAgICB9LFxyXG4gICAgY3JlYXRlT2ZmZXJzKCkge1xyXG4gICAgICBjb25zdCBtYWluID0gJEVMTS5nZXQoJy5tYWluJyk7XHJcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9ICRFTE0uY3JlYXRlKCdkaXYgY291cG9uLWJhbm5lcicpO1xyXG4gICAgICBjb25zdCBvZmZlckJ1dHRvbiA9ICRFTE0uY3JlYXRlKCdhIC5idXR0b24gb2ZmZXJzLWJ1dHRvbicpLnRleHQoJ0fDpSB0aWxsIElDQXMga3Vwb25nZXInKS5ocmVmKCcvZXJianVkYW5kZW4vYnV0aWtzZXJianVkYW5kZW4vYWxsYS1kaWdpdGFsYS1rdXBvbmdlci8nKTtcclxuICAgICAgY29uc3QgaW1nID0gJEVMTS5jcmVhdGUoJ2ltZycpLmltYWdlKCdodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vQmFuemFjaS9pY2EvbWFzdGVyL3NyYy9zdGFydC1wYWdlL0NvdXBvbnNfaW1hZ2UucG5nJyk7XHJcbiAgICAgIGNvbnRhaW5lci5hcHBlbmRBbGwoaW1nLCBvZmZlckJ1dHRvbik7XHJcbiAgICAgIG1haW4uYXBwZW5kKGNvbnRhaW5lcik7XHJcbiAgICB9LFxyXG4gICAgYWRkUmVjaXBlVG9TaG9wcGluZ0xpc3QocmVjaXBlSWQpIHtcclxuICAgICAgLy8gdHJhY2tpbmcgc2tlciB2aWEga2xhc3NuYW1uXHJcblxyXG4gICAgICBJQ0EuYWpheC5wb3N0KCcvVGVtcGxhdGVzL1JlY2lwZXMvSGFuZGxlcnMvU2hvcHBpbmdMaXN0SGFuZGxlci5hc2h4Jywge1xyXG4gICAgICAgIHJlY2lwZUlkczogW3JlY2lwZUlkXSxcclxuICAgICAgICBTaG9wcGluZ0xpc3RJZDogMCxcclxuICAgICAgICBudW1iZXJPZlNlcnZpbmdzOiAwLFxyXG4gICAgICAgIHJlY2lwZXM6IFtdLFxyXG4gICAgICAgIHNob3BwaW5nTGlzdE5hbWU6IGNyZWF0ZVNob3BwaW5nc0xpc3ROYW1lKCksXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgZnVuY3Rpb24gY3JlYXRlU2hvcHBpbmdzTGlzdE5hbWUoKSB7XHJcbiAgICAgICAgY29uc3QgZCA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgY29uc3QgeWVhciA9IGQuZ2V0RnVsbFllYXIoKTtcclxuICAgICAgICBjb25zdCBtb250aCA9IGQuZ2V0TW9udGgoKTtcclxuICAgICAgICBjb25zdCBkYXkgPSBkLmdldERhdGUoKTtcclxuICAgICAgICBjb25zdCBtb250aHMgPSB7IDEwOiAnbm92JywgMTE6ICdkZWMnIH07IC8vIHRlc3RldCBrb21tZXIgZW5kYXN0IGxpZ2dhIHV0ZSBpIG5vdiwgc2VuYXN0IGRlY1xyXG5cclxuICAgICAgICByZXR1cm4gYEF0dCBoYW5kbGEsICR7ZGF5fSAke21vbnRoc1ttb250aF19ICR7eWVhcn1gO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgc2V0QWN0aW9uQ29va2llKGNvb2tpZU5hbWUsIGNvb2tpZURhdGEpIHtcclxuICAgICAgLy8gVE9ETzogRmx5dHRhIHRpbGwgbWFpbi5qc1xyXG4gICAgICBjb25zdCBkID0gbmV3IERhdGUoKTtcclxuICAgICAgZC5zZXREYXRlKG5ldyBEYXRlKCkuZ2V0RGF0ZSgpICsgMSk7IC8vIGV4cGlyZXMgdG9tb3Jyb3dcclxuXHJcbiAgICAgIElDQS5sZWdhY3kuc2V0Q29va2llKGNvb2tpZU5hbWUsIEpTT04uc3RyaW5naWZ5KGNvb2tpZURhdGEpLCBkKTtcclxuICAgIH0sXHJcbiAgICBnZXRBY3Rpb25Db29raWUoY29va2llTmFtZSkge1xyXG4gICAgICAvLyBUT0RPOiBGbHl0dGEgdGlsbCBtYWluLmpzXHJcbiAgICAgIGNvbnN0IGFjdGlvbkNvb2tpZSA9IElDQS5sZWdhY3kuZ2V0Q29va2llKGNvb2tpZU5hbWUpO1xyXG5cclxuICAgICAgaWYgKCFhY3Rpb25Db29raWUpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgSUNBLmxlZ2FjeS5raWxsQ29va2llKGNvb2tpZU5hbWUpO1xyXG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShhY3Rpb25Db29raWUpO1xyXG4gICAgfSxcclxuICAgIGNoZWNrQWN0aW9uQ29va2llcygpIHtcclxuICAgICAgaWYgKCF0aGlzLmlzTG9nZ2VkSW4pIHJldHVybjtcclxuXHJcbiAgICAgIGNvbnN0IGNvdXBvbiA9IHRoaXMuZ2V0QWN0aW9uQ29va2llKEFDVElPTl9DT09LSUVTLkxPQURfQ09VUE9OKTtcclxuICAgICAgaWYgKGNvdXBvbikge1xyXG4gICAgICAgIHRoaXMubG9hZENvdXBvbk9uQ2FyZChjb3Vwb24pLnRoZW4oKHJlc3BvbnNlKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLmNoYW5nZU9mZmVyU3RhdHVzKHJlc3BvbnNlLCBjb3Vwb24pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgY2hhbmdlT2ZmZXJTdGF0dXMocmVzcG9uc2UsIGNvdXBvbikge1xyXG4gICAgICBpZiAocmVzcG9uc2Uub2spIHtcclxuICAgICAgICAkRUxNLmdldChgI2NvdXBvbi0ke2NvdXBvbi5PZmZlcklkfS0ke2NvdXBvbi5yZWNpcGVJZH1gKS5jc3MoJ29mZmVyLWxvYWRlZCcpO1xyXG4gICAgICAgICRFTE0uZ2V0KGAjY291cG9uLSR7Y291cG9uLk9mZmVySWR9LSR7Y291cG9uLnJlY2lwZUlkfSAuY291cG9uLWJ1dHRvbmApLnRleHQoJ0t1cG9uZyBsYWRkYWQnKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIC8vIGhvdGphclRyaWdnZXJlZDogZmFsc2UsXHJcbiAgICBsb2FkZXJJc0FjdGl2ZTogZmFsc2UsXHJcbiAgICBidXR0b25IYW5kbGVyUG9sbFRpbWVvdXQ6IG51bGwsXHJcbiAgICBzaG93TG9hZGVyKCkge1xyXG4gICAgICBjb25zdCBjb250YWluZXIgPSAkKCcuY3JvLWlmcmFtZS1jb250YWluZXInKTtcclxuICAgICAgY29udGFpbmVyLmZpbmQoJy5sb2FkZXInKS5zaG93KCk7XHJcbiAgICAgIGNvbnRhaW5lci5maW5kKCdpZnJhbWUnKS5jc3MoJ29wYWNpdHknLCAnMCcpO1xyXG4gICAgICB0aGlzLmxvYWRlcklzQWN0aXZlID0gdHJ1ZTtcclxuICAgIH0sXHJcbiAgICBoaWRlTG9hZGVyKCkge1xyXG4gICAgICBjb25zdCBjb250YWluZXIgPSAkKCcuY3JvLWlmcmFtZS1jb250YWluZXInKTtcclxuICAgICAgY29udGFpbmVyLmZpbmQoJy5sb2FkZXInKS5oaWRlKCk7XHJcbiAgICAgIGNvbnRhaW5lci5maW5kKCdpZnJhbWUnKS5jc3MoJ29wYWNpdHknLCAnMScpO1xyXG4gICAgICB0aGlzLmxvYWRlcklzQWN0aXZlID0gZmFsc2U7XHJcbiAgICB9LFxyXG4gICAgYWRkQnV0dG9uSGFuZGxlclBvbGwoKSB7XHJcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG4gICAgICBjb25zdCBpZnJhbWUgPSAkKCcuY3JvLWlmcmFtZS1jb250YWluZXIgaWZyYW1lJyk7XHJcbiAgICAgIGNvbnN0IGUgPSBpZnJhbWUuY29udGVudHMoKS5maW5kKCcucmVtb2RhbC13cmFwcGVyICNncmV5LWNhcmQtYnRuLCAucmVtb2RhbC13cmFwcGVyIC5waW5rLWNhcmQtYnRuJyk7XHJcblxyXG4gICAgICBpZiAoZS5sZW5ndGgpIHtcclxuICAgICAgICBlLmNsaWNrKCgpID0+IHtcclxuICAgICAgICAgIHNlbGYuc2hvd0xvYWRlcigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoc2VsZi5idXR0b25IYW5kbGVyUG9sbFRpbWVvdXQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNlbGYuYnV0dG9uSGFuZGxlclBvbGxUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoXHJcbiAgICAgICAgICBzZWxmLmFkZEJ1dHRvbkhhbmRsZXJQb2xsLmJpbmQoc2VsZiksXHJcbiAgICAgICAgICAxMDAwLFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBhZGRFdmVudExpc3RlbmVycygpIHtcclxuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAkKCcuaGVhZGVyJykub2ZmKCdtb3VzZWRvd24nKTtcclxuXHJcbiAgICAgICQod2luZG93KS5vbignbWVzc2FnZSBvbm1lc3NhZ2UnLCAoZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IG9yaWdpbiA9IGAke3dpbmRvdy5sb2NhdGlvbi5wcm90b2NvbH0vLyR7d2luZG93LmxvY2F0aW9uLmhvc3R9YDtcclxuICAgICAgICBpZiAoZS5vcmlnaW5hbEV2ZW50Lm9yaWdpbiA9PT0gb3JpZ2luICYmIC9tb2JpbGViYW5raWQvaS50ZXN0KGUub3JpZ2luYWxFdmVudC5kYXRhKSkge1xyXG4gICAgICAgICAgc2VsZi5zaG93TG9hZGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH0sXHJcbiAgICBnZXRJZnJhbWVTdHlsZXMoKSB7XHJcbiAgICAgIHJldHVybiBgPHN0eWxlIHR5cGU9XCJ0ZXh0L2Nzc1wiPlxyXG4gICAgICAgIEBtZWRpYSAgKG1heC13aWR0aDogNzY3cHgpIHtcclxuICAgICAgICBoMy5ncmVldGluZywgaDMuY2FyZC1oZWFkaW5nIHsgZm9udC1zaXplOiAxOHB4OyB9XHJcbiAgICAgICAgaW1nLmNhcmQtaWNvbiB7IHdpZHRoOiA1MHB4OyB9XHJcbiAgICAgICAgLnNlbGVjdC1jYXJkLW1vZGFsIHsgYm9yZGVyOiAwOyBwYWRkaW5nOiAwOyBtYXJnaW46IDA7IH1cclxuICAgICAgICAucmVtb2RhbC13cmFwcGVyIHsgcGFkZGluZzogMDsgfVxyXG4gICAgICAgIH1cclxuICAgICAgICA8L3N0eWxlPmA7XHJcbiAgICB9LFxyXG4gICAgY3JlYXRlTW9kYWwoYWN0aW9uID0gTE9HSU5fQUNUSU9OLlNBVkVfUkVDSVBFKSB7XHJcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG4gICAgICBjb25zdCBtb2RhbCA9IG5ldyBjb3JlQ29tcG9uZW50cy5tb2RhbCh7XHJcbiAgICAgICAgdHBsOiAkKCcuY3JvLWlmcmFtZS1jb250YWluZXInKS5nZXQoMCksXHJcbiAgICAgICAgc2l6ZTogJ21kJyxcclxuICAgICAgICBjb250YWluZXI6ICQoJy5tb2RhbC1jb250YWluZXInKS5nZXQoMCksXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgc2VsZi5zaG93TG9hZGVyKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGlmcmFtZSA9ICQoJy5jcm8taWZyYW1lLWNvbnRhaW5lciBpZnJhbWUnKTtcclxuXHJcbiAgICAgICAgaWZyYW1lLm9uKCdsb2FkJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKGBeJHt3aW5kb3cubG9jYXRpb24uaHJlZn0kYCwgJ2dpJyk7XHJcbiAgICAgICAgICBpZiAocmVnZXgudGVzdCh0aGlzLmNvbnRlbnRXaW5kb3cubG9jYXRpb24pKSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQodHJ1ZSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKHRoaXMuY29udGVudFdpbmRvdy5sb2NhdGlvbi5ocmVmLmluZGV4T2YoJ2xvZ2dhLWluJykgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIGxldCBoZWFkZXJCYXJUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoaGlkZUhlYWRlckJhciwgMTApO1xyXG4gICAgICAgICAgICBsZXQgYXBwZW5kSGVhZGVyVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGFwcGVuZEhlYWRlciwgMTApO1xyXG4gICAgICAgICAgICBsZXQgYWRkU3R5bGVzVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGFkZFN0eWxlcywgMTApO1xyXG4gICAgICAgICAgICBsZXQgYWRkSWZyYW1lVHJhY2tpbmdUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoYWRkSWZyYW1lVHJhY2tpbmcsIDEwKTtcclxuICAgICAgICAgICAgY29uc3QgaGlkZUhlYWRlckJhckRlZmVycmVkID0gJC5EZWZlcnJlZCgpO1xyXG4gICAgICAgICAgICBjb25zdCBhcHBlbmRIZWFkZXJEZWZlcnJlZCA9ICQuRGVmZXJyZWQoKTtcclxuICAgICAgICAgICAgY29uc3QgYWRkU3R5bGVzRGVmZXJyZWQgPSAkLkRlZmVycmVkKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGFkZElmcmFtZVRyYWNraW5nRGVmZXJyZWQgPSAkLkRlZmVycmVkKCk7XHJcblxyXG4gICAgICAgICAgICAkLndoZW4oXHJcbiAgICAgICAgICAgICAgaGlkZUhlYWRlckJhckRlZmVycmVkLFxyXG4gICAgICAgICAgICAgIGFwcGVuZEhlYWRlckRlZmVycmVkLFxyXG4gICAgICAgICAgICAgIGFkZFN0eWxlc0RlZmVycmVkLFxyXG4gICAgICAgICAgICAgIGFkZElmcmFtZVRyYWNraW5nRGVmZXJyZWQsXHJcbiAgICAgICAgICAgICkuZG9uZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgc2VsZi5oaWRlTG9hZGVyKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gaGlkZUhlYWRlckJhcigpIHtcclxuICAgICAgICAgICAgICBjb25zdCBlID0gJCgnLmNyby1pZnJhbWUtY29udGFpbmVyIGlmcmFtZScpLmNvbnRlbnRzKCkuZmluZCgnLmhlYWRlci1iYXInKTtcclxuICAgICAgICAgICAgICBpZiAoZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGUuaGlkZSgpO1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChoZWFkZXJCYXJUaW1lb3V0KTtcclxuICAgICAgICAgICAgICAgIGhpZGVIZWFkZXJCYXJEZWZlcnJlZC5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGhlYWRlckJhclRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChoaWRlSGVhZGVyQmFyLCAwKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGFwcGVuZEhlYWRlcigpIHtcclxuICAgICAgICAgICAgICBjb25zdCBlID0gJCgnLmNyby1pZnJhbWUtY29udGFpbmVyIGlmcmFtZScpLmNvbnRlbnRzKCkuZmluZCgnaDEnKTtcclxuICAgICAgICAgICAgICBpZiAoZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAoYWN0aW9uID09PSBMT0dJTl9BQ1RJT04uU0FWRV9SRUNJUEUpXHJcbiAgICAgICAgICAgICAgICAgID8gJyBmw7ZyIGF0dCBsw6RnZ2EgdGlsbCBpIGlua8O2cHNsaXN0YW4gb2NoIHNwYXJhIHJlY2VwdCdcclxuICAgICAgICAgICAgICAgICAgOiAnIGbDtnIgYXR0IGxhZGRhIGt1cG9uZ2VuJztcclxuICAgICAgICAgICAgICAgIGUuYXBwZW5kKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgZS5jc3MoeyAnZm9udC1mYW1pbHknOiAnaWNhaGFuZCwgYXJpYWwsIHNhbnMtc2VyaWYnLCAnZm9udC1zaXplJzogJzNyZW0nIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuc2NyZWVuLndpZHRoIDwgNzY4KSB7XHJcbiAgICAgICAgICAgICAgICAgIGUuY3NzKCdmb250LXNpemUnLCAnMThweCcpO1xyXG4gICAgICAgICAgICAgICAgICBlLnBhcmVudCgpLmNzcygnbWFyZ2luJywgJzAnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoYXBwZW5kSGVhZGVyVGltZW91dCk7XHJcbiAgICAgICAgICAgICAgICBhcHBlbmRIZWFkZXJEZWZlcnJlZC5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGFwcGVuZEhlYWRlclRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChhcHBlbmRIZWFkZXIsIDApO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gYWRkU3R5bGVzKCkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IGUgPSAkKCcuY3JvLWlmcmFtZS1jb250YWluZXIgaWZyYW1lJykuY29udGVudHMoKS5maW5kKCdib2R5Jyk7XHJcbiAgICAgICAgICAgICAgaWYgKGUubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBlLmFwcGVuZChzZWxmLmdldElmcmFtZVN0eWxlcygpKTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoYWRkU3R5bGVzVGltZW91dCk7XHJcbiAgICAgICAgICAgICAgICBhZGRTdHlsZXNEZWZlcnJlZC5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGFkZFN0eWxlc1RpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChhZGRTdHlsZXMsIDApO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gYWRkSWZyYW1lVHJhY2tpbmcoKSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgZSA9ICQoJy5jcm8taWZyYW1lLWNvbnRhaW5lciBpZnJhbWUnKS5jb250ZW50cygpO1xyXG4gICAgICAgICAgICAgIGlmIChlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnRBY3Rpb24gPSAoYWN0aW9uID09PSBMT0dJTl9BQ1RJT04uU0FWRV9SRUNJUEUpXHJcbiAgICAgICAgICAgICAgICAgID8gJ1NwYXJhIHJlY2VwdCBmcsOlbiBzdGFydHNpZGFuJ1xyXG4gICAgICAgICAgICAgICAgICA6ICdMYWRkYSBrdXBvbmcgZnLDpW4gc3RhcnRzaWRhJztcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGb3J0c8OkdHQgKE1vYmlsdCBCYW5rSWQpXHJcbiAgICAgICAgICAgICAgICBlLmZpbmQoJyNzdWJtaXQtbG9naW4tbW9iaWxlLWJhbmstaWQnKS5vbignY2xpY2snLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgIGdhKCdzZW5kJywgJ2V2ZW50JywgJ0EvQicsIGV2ZW50QWN0aW9uLCAnTG9nZ2EgaW4gLSBNb2JpbHQgQmFua0lkJyk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBCZWjDtnZlciBkdSBoasOkbHAgKE1vYmlsdCBCYW5rSWQpXHJcbiAgICAgICAgICAgICAgICBlLmZpbmQoJy5sb2dpbi1zdXBwb3J0LWJhbmstaWQtbGluaycpLm9uKCdjbGljaycsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgZ2EoJ3NlbmQnLCAnZXZlbnQnLCAnQS9CJywgZXZlbnRBY3Rpb24sICdCZWjDtnZlciBkdSBoasOkbHAnKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNrYXBhIGtvbnRvIChNb2JpbHQgQmFua0lkKVxyXG4gICAgICAgICAgICAgICAgZS5maW5kKCcuZ2V0LW1vYmlsZS1iYW5rLWlkLWxpbmsnKS5vbignY2xpY2snLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgIGdhKCdzZW5kJywgJ2V2ZW50JywgJ0EvQicsIGV2ZW50QWN0aW9uLCAnU2thcGEga29udG8gLSBNb2JpbHQgQmFua0lkJyk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBMb2dnYSBpbiAoTMO2c2Vub3JkKVxyXG4gICAgICAgICAgICAgICAgZS5maW5kKCcjbG9nLWluLXN1Ym1pdCcpLm9uKCdjbGljaycsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgZ2EoJ3NlbmQnLCAnZXZlbnQnLCAnQS9CJywgZXZlbnRBY3Rpb24sICdMb2dnYSBpbiAtIEzDtnNlbm9yZCcpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gR2zDtm10IGzDtnNlbm9yZCAoTMO2c2Vub3JkKVxyXG4gICAgICAgICAgICAgICAgZS5maW5kKCcubG9naW4tc3VwcG9ydC1wYXNzd29yZC1saW5rJykub24oJ2NsaWNrJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICBnYSgnc2VuZCcsICdldmVudCcsICdBL0InLCBldmVudEFjdGlvbiwgJ0dsw7ZtdCBsw7ZzZW5vcmQnKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNrYXBhIGtvbnRvIChMw7ZzZW5vcmQpXHJcbiAgICAgICAgICAgICAgICBlLmZpbmQoJy5jcmVhdGUtYWNjb3VudC1saW5rJykub24oJ2NsaWNrJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICBnYSgnc2VuZCcsICdldmVudCcsICdBL0InLCBldmVudEFjdGlvbiwgJ1NrYXBhIGtvbnRvIC0gTMO2c2Vub3JkJyk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGFkZElmcmFtZVRyYWNraW5nVGltZW91dCk7XHJcbiAgICAgICAgICAgICAgICBhZGRJZnJhbWVUcmFja2luZ0RlZmVycmVkLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYWRkSWZyYW1lVHJhY2tpbmdUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoYWRkSWZyYW1lVHJhY2tpbmcsIDApO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICQoJy5jcm8taWZyYW1lLWNvbnRhaW5lciBpZnJhbWUnKS5jb250ZW50cygpLmZpbmQoJ2Zvcm0nKS5vbignc3VibWl0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoISQodGhpcykuZmluZCgnaW5wdXQuZXJyb3InKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICBzZWxmLnNob3dMb2FkZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgJCgnLmNyby1pZnJhbWUtY29udGFpbmVyIGlmcmFtZScpLmNvbnRlbnRzKCkuZmluZCgnI3N1Ym1pdC1sb2dpbi1tb2JpbGUtYmFuay1pZCcpLm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCEkKHRoaXMpLmZpbmQoJ2lucHV0LmVycm9yJykubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgc2VsZi5idXR0b25IYW5kbGVyUG9sbFRpbWVvdXQgPSBzZXRUaW1lb3V0KFxyXG4gICAgICAgICAgICAgICAgc2VsZi5hZGRCdXR0b25IYW5kbGVyUG9sbC5iaW5kKHNlbGYpLFxyXG4gICAgICAgICAgICAgICAgMTAwMCxcclxuICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAkKCcuY3JvLWlmcmFtZS1jb250YWluZXIgaWZyYW1lJykuY29udGVudHMoKS5maW5kKCdhW2hyZWYqPVwid3d3LmljYS5zZVwiXScpLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAkKHRoaXMpLmF0dHIoJ2hyZWYnLCAkKHRoaXMpLmF0dHIoJ2hyZWYnKS5yZXBsYWNlKCdodHRwOi8vJywgJ2h0dHBzOi8vJykpO1xyXG4gICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmNsaWNrKGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSAkKHRoaXMpLmF0dHIoJ2hyZWYnKTtcclxuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyB0cmlnZ2EgaG90amFyIGhlYXRtYXAgZsO2cnN0YSBnw6VuZ2VuIG1vZGFsZW4gw7ZwcG5hdHNcclxuICAgICAgICAvLyBpZiAodHlwZW9mIGhqID09PSAnZnVuY3Rpb24nICYmICFzZWxmLmhvdGphclRyaWdnZXJlZCkge1xyXG4gICAgICAgIC8vICAgICBoaigndHJpZ2dlcicsICd2YXJpYW50Jyk7XHJcbiAgICAgICAgLy8gICAgIHNlbGYuaG90amFyVHJpZ2dlcmVkID0gdHJ1ZTtcclxuICAgICAgICAvLyB9XHJcbiAgICAgIH0sIDUwKTtcclxuICAgIH0sXHJcbiAgICBsb2FkQ291cG9uRGF0YShjb3Vwb24pIHtcclxuICAgICAgcmV0dXJuIGxvYWRlZENvdXBvbnNbY291cG9uLk9mZmVySWRdXHJcbiAgICAgICAgPyBQcm9taXNlLnJlc29sdmUobG9hZGVkQ291cG9uc1tjb3Vwb24uT2ZmZXJJZF0pXHJcbiAgICAgICAgOiB3aW5kb3cuZmV0Y2goYC9hcGkvanNvbmhzZS8ke2NvdXBvbi5pZH1gLCB7IGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nIH0pXHJcbiAgICAgICAgICAudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5qc29uKCkpXHJcbiAgICAgICAgICAudGhlbigoanNvbikgPT4ge1xyXG4gICAgICAgICAgICBsb2FkZWRDb3Vwb25zW2NvdXBvbi5PZmZlcklkXSA9IGpzb247XHJcbiAgICAgICAgICAgIHJldHVybiBqc29uO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgbG9hZENvdXBvbk9uQ2FyZChjb3Vwb24pIHtcclxuICAgICAgY29uc3Qgb3B0cyA9IHtcclxuICAgICAgICBPZmZlcklkOiBjb3Vwb24uT2ZmZXJJZCxcclxuICAgICAgICBDYW1wYWlnbklkOiBjb3Vwb24uQ2FtcGFpZ25JZCxcclxuICAgICAgICBTdG9yZUlkOiAwLFxyXG4gICAgICAgIFN0b3JlR3JvdXBJZDogMCxcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHJldHVybiB3aW5kb3cuZmV0Y2goXHJcbiAgICAgICAgJy9hcGkvanNvbmhzZS9DbGFpbW9mZmVyJyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyxcclxuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShvcHRzKSxcclxuICAgICAgICB9LFxyXG4gICAgICApLnRoZW4oKHJlc3BvbnNlKSA9PiB7XHJcbiAgICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgICBpY2FkYXRhbGF5ZXIuYWRkKCdIU0UnLCB7XHJcbiAgICAgICAgICAgIEhTRToge1xyXG4gICAgICAgICAgICAgIGFjdGlvbjogJ2NvdXBvbi1sb2FkZWQnLFxyXG4gICAgICAgICAgICAgIG5hbWU6IGNvdXBvbi5QYWdlTmFtZSxcclxuICAgICAgICAgICAgICBvZmZlcjogY291cG9uLnRpdGxlLFxyXG4gICAgICAgICAgICAgIGhzZXVybDogY291cG9uLnVybCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIHJlc2V0UGFyYWxsYXhTY3JvbGxpbmcoKSB7XHJcbiAgICAgIElDQS5pY2FDYWxsYmFja3MuJHBhcmFsbGF4Q29udGFpbmVycyA9ICQoJy5wYXJhbGxheCcpO1xyXG4gICAgfSxcclxuICB9O1xyXG5cclxuICAkKGRvY3VtZW50KS5yZWFkeSgoKSA9PiB7XHJcbiAgICBjb25zdCBJQyA9IElDQUNSTygpO1xyXG4gICAgaWYgKC9eaHR0cHM6XFwvXFwvd3d3LmljYS5zZVxcLyQvLnRlc3Qod2luZG93LmxvY2F0aW9uKSkge1xyXG4gICAgICBPYmplY3QuYXNzaWduKHRlc3QsIElDKTtcclxuICAgICAgdGVzdC5jaGVja0FjdGlvbkNvb2tpZXMoKTtcclxuICAgICAgdGVzdC5tYW5pcHVsYXRlRG9tKCk7XHJcbiAgICAgIHRlc3QuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcclxuICAgICAgdGVzdC5yZXNldFBhcmFsbGF4U2Nyb2xsaW5nKCk7XHJcbiAgICB9XHJcbiAgICBpZiAoL15odHRwczpcXC9cXC93d3cuaWNhLnNlXFwvZXJianVkYW5kZW5cXC9idXRpa3NlcmJqdWRhbmRlblxcL2FsbGEtZGlnaXRhbGEta3Vwb25nZXJcXC8kLy50ZXN0KHdpbmRvdy5sb2NhdGlvbikpIHtcclxuICAgICAgY291cG9ucy5tYW5pcHVsYXRlRG9tKElDLCAoKSA9PiB7XHJcbiAgICAgICAgdGVzdC5jcmVhdGVNb2RhbChMT0dJTl9BQ1RJT04uTE9BRF9DT1VQT04pO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9KTtcclxufSkoalF1ZXJ5KTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3N0YXJ0LXBhZ2UvdmFyaWFudC5qcyIsIi8qXHJcbmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjogW1xyXG4gIFwiZXJyb3JcIiwgeyBcInByb3BzXCI6IHRydWUsIFwiaWdub3JlUHJvcGVydHlNb2RpZmljYXRpb25zRm9yXCI6IFtcImVsZW1lbnRcIl0gfVxyXG5dXHJcbiovXHJcbi8qIGVzbGludCBuby11c2UtYmVmb3JlLWRlZmluZTogW1wiZXJyb3JcIiwgeyBcImZ1bmN0aW9uc1wiOiBmYWxzZSB9XSAqL1xyXG4vKiBlc2xpbnQtZW52IGVzNiAqL1xyXG5pbXBvcnQgU3RvcmFnZSBmcm9tICcuL21vZHVsZXMvc3RvcmFnZSc7XHJcblxyXG5jb25zdCByZXNlcnZlZEVsZW1lbnRzID0gWydkaXYnLCAnYm9keScsICdoZWFkJywgJ2ltZycsICdzdHlsZScsICdzcGFuJywgJ3VsJywgJ2xpJywgJ2lucHV0JywgJ2J1dHRvbicsICdoMScsICdoMicsICdoMycsICdoNCcsICdhJywgJ3AnLCAnc3Ryb25nJywgJ3N2ZyddO1xyXG5jb25zdCBHZXRFbGVtZW50ID0gc2VsZWN0b3IgPT4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XHJcblxyXG5jb25zdCAkRUxNX0VMRU1FTlQgPSAoZWxlbWVudCkgPT4ge1xyXG4gIGNvbnN0IHJlY3QgPSBhcmcgPT4gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVthcmddO1xyXG4gIHJldHVybiB7XHJcbiAgICBhdHRyKC4uLmFyZ3MpIHtcclxuICAgICAgaWYgKGVsZW1lbnQpIHtcclxuICAgICAgICBjb25zdCBbYXR0ciwgdmFsdWVdID0gYXJncy5sZW5ndGggPT09IDIgPyBbLi4uYXJnc10gOiBhcmdzWzBdLnNwbGl0KCc6Jyk7XHJcbiAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShhdHRyLCB2YWx1ZSk7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHIpO1xyXG4gICAgICB9XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHthcmdzfSBFbGVtZW50IGRvZXMgbm90IGV4aXN0ISBGdW5jdGlvbiAnYXR0cidgKTtcclxuICAgIH0sXHJcbiAgICBoZWlnaHQoKSB7XHJcbiAgICAgIHJldHVybiByZWN0KCdoZWlnaHQnKTtcclxuICAgIH0sXHJcbiAgICBjbGljayhjYWxsYmFjaykge1xyXG4gICAgICBpZiAoZWxlbWVudCkge1xyXG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjYWxsYmFjayk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgIH1cclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NhbGxiYWNrfSBFbGVtZW50IGRvZXMgbm90IGV4aXN0ISBGdW5jdGlvbiAnY2xpY2snYCk7XHJcbiAgICB9LFxyXG4gICAgaHRtbChzdHIpIHtcclxuICAgICAgaWYgKGVsZW1lbnQpIHtcclxuICAgICAgICBpZiAoIXN0cikgcmV0dXJuIGVsZW1lbnQuaW5uZXJIVE1MO1xyXG4gICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gc3RyO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICB9XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtzdHJ9IEVsZW1lbnQgZG9lcyBub3QgZXhpc3QhIEZ1bmN0aW9uICdodG1sJ2ApO1xyXG4gICAgfSxcclxuICAgIHRleHQoc3RyKSB7XHJcbiAgICAgIGlmIChlbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKCFzdHIpIHJldHVybiBlbGVtZW50LmlubmVyVGV4dCB8fCBlbGVtZW50LnRleHRDb250ZW50O1xyXG4gICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJyc7XHJcbiAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzdHIpKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgfVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7c3RyfSBFbGVtZW50IGRvZXMgbm90IGV4aXN0ISBGdW5jdGlvbiAndGV4dCdgKTtcclxuICAgIH0sXHJcbiAgICBpbWFnZShzcmMpIHtcclxuICAgICAgaWYgKGVsZW1lbnQpIHtcclxuICAgICAgICBlbGVtZW50LnNyYyA9IHNyYztcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgfVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7c3JjfSBFbGVtZW50IGRvZXMgbm90IGV4aXN0ISBGdW5jdGlvbiAnaW1hZ2UnYCk7XHJcbiAgICB9LFxyXG4gICAgaHJlZih1cmwpIHtcclxuICAgICAgaWYgKGVsZW1lbnQpIHtcclxuICAgICAgICBlbGVtZW50LmhyZWYgPSB1cmw7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgIH1cclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3VybH0gRWxlbWVudCBkb2VzIG5vdCBleGlzdCEgRnVuY3Rpb24gJ2hyZWYnYCk7XHJcbiAgICB9LFxyXG4gICAgYXBwZW5kRmlyc3QoY2hpbGQpIHtcclxuICAgICAgY29uc3QgYyA9IGNoaWxkLm5vZGVUeXBlID8gY2hpbGQgOiBjaGlsZC5lbGVtZW50O1xyXG4gICAgICBpZiAoZWxlbWVudCkge1xyXG4gICAgICAgIGVsZW1lbnQuaW5zZXJ0QmVmb3JlKGMsIGVsZW1lbnQuY2hpbGROb2Rlc1swXSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgIH1cclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NoaWxkfSBFbGVtZW50IGRvZXMgbm90IGV4aXN0ISBGdW5jdGlvbiAnYXBwZW5kJ2ApO1xyXG4gICAgfSxcclxuICAgIGFwcGVuZChjaGlsZCkge1xyXG4gICAgICBjb25zdCBjID0gY2hpbGQubm9kZVR5cGUgPyBjaGlsZCA6IGNoaWxkLmVsZW1lbnQ7XHJcbiAgICAgIGlmIChlbGVtZW50KSB7XHJcbiAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChjKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgfVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Y2hpbGR9IEVsZW1lbnQgZG9lcyBub3QgZXhpc3QhIEZ1bmN0aW9uICdhcHBlbmQnYCk7XHJcbiAgICB9LFxyXG4gICAgYXBwZW5kQWxsKC4uLmNoaWxkcykge1xyXG4gICAgICByZXR1cm4gY2hpbGRzLm1hcCh0aGlzLmFwcGVuZCk7XHJcbiAgICB9LFxyXG4gICAgY3NzKGNuKSB7XHJcbiAgICAgIGlmIChjbikge1xyXG4gICAgICAgIGNuLnNwbGl0KCcgJylcclxuICAgICAgICAgIC5qb2luKCcsJylcclxuICAgICAgICAgIC5zcGxpdCgnLCcpXHJcbiAgICAgICAgICAuZm9yRWFjaChjID0+IGMgJiYgZWxlbWVudCAmJiBlbGVtZW50LmNsYXNzTGlzdC5hZGQoYy5yZXBsYWNlKC9cXC4vZywgJycpLnRyaW0oKSkpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuICAgIHRvZ2dsZShjbikge1xyXG4gICAgICBpZiAoY24pIHtcclxuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoY24pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuICAgIGdldCguLi5hcmdzKSB7XHJcbiAgICAgIGlmIChlbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSByZXR1cm4gJEVMTV9FTEVNRU5UKGVsZW1lbnQucXVlcnlTZWxlY3RvcihhcmdzWzBdKSk7XHJcbiAgICAgICAgcmV0dXJuIGFyZ3MubWFwKGFyZyA9PiAkRUxNX0VMRU1FTlQoZWxlbWVudC5xdWVyeVNlbGVjdG9yKGFyZykpKTtcclxuICAgICAgfVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7YXJnc30gRWxlbWVudCBkb2VzIG5vdCBleGlzdCEgRnVuY3Rpb24gJ2dldCdgKTtcclxuICAgIH0sXHJcbiAgICBjaGlsZHJlbihhcmcpIHtcclxuICAgICAgaWYgKGFyZykge1xyXG4gICAgICAgIGNvbnN0IGxpc3QgPSBBcnJheS5mcm9tKGVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoYXJnKSk7XHJcbiAgICAgICAgcmV0dXJuIGxpc3QubWFwKGNoaWxkID0+ICRFTE1fRUxFTUVOVChjaGlsZCkpO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGxpc3QgPSBBcnJheS5mcm9tKGVsZW1lbnQuY2hpbGROb2Rlcyk7XHJcbiAgICAgIHJldHVybiBsaXN0Lm1hcChjaGlsZCA9PiAkRUxNX0VMRU1FTlQoY2hpbGQpKTtcclxuICAgIH0sXHJcbiAgICBzdHlsZShzdGwpIHtcclxuICAgICAgaWYgKGVsZW1lbnQpIHtcclxuICAgICAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHN0bCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgIH1cclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3N0bH0gRWxlbWVudCBkb2VzIG5vdCBleGlzdCEgRnVuY3Rpb24gJ3N0eWxlJ2ApO1xyXG4gICAgfSxcclxuICAgIGRhdGEoa2V5LCB2YWx1ZSkge1xyXG4gICAgICBpZiAoZWxlbWVudCkge1xyXG4gICAgICAgIGVsZW1lbnQuZGF0YXNldFtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgIH1cclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2tleX0gJHt2YWx1ZX0gRWxlbWVudCBkb2VzIG5vdCBleGlzdCEgRnVuY3Rpb24gJ2RhdGEnYCk7XHJcbiAgICB9LFxyXG4gICAgZWxlbWVudCxcclxuICB9O1xyXG59O1xyXG5cclxuY29uc3QgQ3JlYXRlRWxlbWVudCA9IChhcmcpID0+IHtcclxuICBpZiAoYXJnIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHJldHVybiAkRUxNX0VMRU1FTlQoYXJnKTtcclxuICBjb25zdCBhcnIgPSBhcmcuc3BsaXQoJyAnKTtcclxuICBjb25zdCB0eXBlID0gYXJyLnJlZHVjZSgoYWNjLCBjdXJyZW50KSA9PiB7XHJcbiAgICBpZiAocmVzZXJ2ZWRFbGVtZW50cy5pbmNsdWRlcyhjdXJyZW50KSkge1xyXG4gICAgICByZXR1cm4gY3VycmVudDtcclxuICAgIH1cclxuICAgIHJldHVybiBhY2M7XHJcbiAgfSwgJ2RpdicpO1xyXG5cclxuICBjb25zdCBjbGFzc05hbWVzID0gYXJyLmZpbHRlcihjdXJyZW50ID0+ICFyZXNlcnZlZEVsZW1lbnRzLmluY2x1ZGVzKGN1cnJlbnQpKS5qb2luKCk7XHJcbiAgY29uc3QgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlKTtcclxuICByZXR1cm4gJEVMTV9FTEVNRU5UKGRvbSkuY3NzKGNsYXNzTmFtZXMpO1xyXG59O1xyXG5cclxuY29uc3QgQ3JlYXRlRWxlbWVudEJ5T2JqZWN0ID0gKHR5cGUsIGl0ZXJhYmxlKSA9PiB7XHJcbiAgY29uc3QgZWxlbWVudCA9IENyZWF0ZUVsZW1lbnQodHlwZSk7XHJcbiAgT2JqZWN0LmtleXMoaXRlcmFibGUpLmZvckVhY2goKGl0ZW0pID0+IHtcclxuICAgIGNvbnN0IGZ1bmMgPSBlbGVtZW50W2l0ZW1dO1xyXG4gICAgaWYgKGZ1bmMpIHtcclxuICAgICAgY29uc3QgdmFsdWUgPSBpdGVyYWJsZVtpdGVtXTtcclxuICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLmxlbmd0aCkge1xyXG4gICAgICAgIGZ1bmModmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgcmV0dXJuIGVsZW1lbnQ7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgJEVMTSA9IHtcclxuICBlbG1zOiB7fSxcclxuICBjcmVhdGUoLi4uYXJncykge1xyXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSByZXR1cm4gQ3JlYXRlRWxlbWVudChhcmdzWzBdKTtcclxuICAgIHJldHVybiBhcmdzLm1hcChhcmcgPT4gQ3JlYXRlRWxlbWVudChhcmcpKTtcclxuICB9LFxyXG4gIGJ1aWxkKHR5cGUsIGl0ZXJhYmxlKSB7XHJcbiAgICByZXR1cm4gQ3JlYXRlRWxlbWVudEJ5T2JqZWN0KHR5cGUsIGl0ZXJhYmxlKTtcclxuICB9LFxyXG4gIGdldCguLi5hcmdzKSB7XHJcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgY29uc3Qga2V5ID0gTnVtYmVyLmlzSW50ZWdlcihwYXJzZUludChhcmdzWzBdLCAxMCkpID8gcGFyc2VJbnQoYXJnc1swXSwgMTApIDogYXJnc1swXTtcclxuICAgICAgcmV0dXJuIHRoaXMuZWxtc1trZXldIHx8ICRFTE1fRUxFTUVOVChHZXRFbGVtZW50KGtleSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyZ3MubWFwKChhcmcpID0+IHtcclxuICAgICAgY29uc3Qga2V5ID0gTnVtYmVyLmlzSW50ZWdlcihwYXJzZUludChhcmcsIDEwKSkgPyBwYXJzZUludChhcmcsIDEwKSA6IGFyZztcclxuICAgICAgcmV0dXJuIHRoaXMuZWxtc1trZXldIHx8ICRFTE1fRUxFTUVOVChHZXRFbGVtZW50KGtleSkpO1xyXG4gICAgfSk7XHJcbiAgfSxcclxuICBzYXZlKGlkLCBlbGVtZW50KSB7XHJcbiAgICB0aGlzLmVsbXNbaWRdID0gdGhpcy5lbG1zW2lkXSB8fCB7fTtcclxuICAgIHRoaXMuZWxtc1tpZF0gPSBlbGVtZW50O1xyXG4gIH0sXHJcbiAgY29weShzZWxlY3Rvcikge1xyXG4gICAgY29uc3QgY2hpbGQgPSBHZXRFbGVtZW50KHNlbGVjdG9yKTtcclxuICAgIGlmIChjaGlsZCkge1xyXG4gICAgICByZXR1cm4gQ3JlYXRlRWxlbWVudChjaGlsZC5jbG9uZU5vZGUodHJ1ZSkpO1xyXG4gICAgfVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3NlbGVjdG9yfSBFbGVtZW50IGRvZXMgbm90IGV4aXN0ISBGdW5jdGlvbiAnY29weSdgKTtcclxuICB9LFxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IElDQUNSTyA9ICgpID0+IHtcclxuICAkRUxNLmdldCgnYm9keScpLmNzcygnY3JvJyk7XHJcbiAgcmV0dXJuIHtcclxuICAgIGdldEVsZW1lbnRDb250ZW50QnlUYWdBbmRBdHRyKHJlZ2V4cCwgdGFnLCBhdHRyKSB7XHJcbiAgICAgIGNvbnN0IHFzYSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodGFnKTtcclxuICAgICAgcmV0dXJuIHRoaXMudG9BcnJheShxc2EpLnJlZHVjZSgoYWNjLCBlbGVtZW50KSA9PiB7XHJcbiAgICAgICAgaWYgKG5ldyBSZWdFeHAocmVnZXhwKS50ZXN0KGVsZW1lbnRbYXR0cl0pKSB7XHJcbiAgICAgICAgICBhY2MucHVzaChlbGVtZW50W2F0dHJdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFjYztcclxuICAgICAgfSwgW10pO1xyXG4gICAgfSxcclxuICAgIHJlbW92ZUVsZW1lbnRzKGNsYXNzTmFtZXMpIHtcclxuICAgICAgY2xhc3NOYW1lcy5mb3JFYWNoKChjbGFzc05hbWUpID0+IHtcclxuICAgICAgICBjb25zdCBlbG0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGNsYXNzTmFtZSk7XHJcbiAgICAgICAgaWYgKGVsbSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSBlbG0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbG0pO1xyXG4gICAgICB9KTtcclxuICAgIH0sXHJcbiAgICB0b0FycmF5KGxpc3QpIHsgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGxpc3QpOyB9LFxyXG4gICAgbG9hZCguLi5hcmdzKSB7XHJcbiAgICAgIGNvbnN0IFt1cmwsIG9wdGlvbnNdID0gYXJncztcclxuICAgICAgY29uc3Qgb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgeyBtZXRob2Q6ICdnZXQnIH0sIG9wdGlvbnMpO1xyXG4gICAgICByZXR1cm4gZmV0Y2godXJsLCBvcHMpXHJcbiAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuanNvbigpKVxyXG4gICAgICAgIC5jYXRjaChlcnIgPT4gZXJyKTtcclxuICAgIH0sXHJcbiAgICBzdHlsZShzdHlsZXMpIHtcclxuICAgICAgY29uc29sZS5sb2coJ3N0eWxlIGlzIGRlcHJlY2F0ZWQuLi4gdXNlIGNzcyBhbmQgcmVxdWlyZS4nKTtcclxuICAgICAgY29uc3Qgc3R5bGUgPSAkRUxNLmNyZWF0ZSgnc3R5bGUnKTtcclxuICAgICAgc3R5bGUuYXR0cigndHlwZScsICd0ZXh0L2NzcycpO1xyXG4gICAgICBzdHlsZS5hcHBlbmQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoc3R5bGVzKSk7XHJcbiAgICAgICRFTE0uZ2V0KCdoZWFkJykuYXBwZW5kKHN0eWxlKTtcclxuICAgIH0sXHJcbiAgICBpc0xvZ2dlZEluKCkge1xyXG4gICAgICByZXR1cm4gJEVMTS5nZXQoJyNoZG5JY2FTdGF0ZScpLmF0dHIoJ3ZhbHVlJykubGVuZ3RoID4gMTtcclxuICAgIH0sXHJcbiAgICBnYVB1c2goeyBldmVudENhdGVnb3J5ID0gJ0EvQicsIGV2ZW50QWN0aW9uLCBldmVudExhYmVsIH0pIHtcclxuICAgICAgaWYgKGdhKSB7XHJcbiAgICAgICAgZ2EoJ3NlbmQnLCAnZXZlbnQnLCBldmVudENhdGVnb3J5LCBldmVudEFjdGlvbiwgZXZlbnRMYWJlbCk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBzdG9yYWdlOiB7XHJcbiAgICAgIHNldChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgU3RvcmFnZS5zZXQoa2V5LCB2YWx1ZSk7XHJcbiAgICAgIH0sXHJcbiAgICAgIGdldChrZXkpIHtcclxuICAgICAgICByZXR1cm4gU3RvcmFnZS5nZXQoa2V5KTtcclxuICAgICAgfSxcclxuICAgICAgcmVtb3ZlKGtleSkge1xyXG4gICAgICAgIFN0b3JhZ2UucmVtb3ZlKGtleSk7XHJcbiAgICAgIH0sXHJcbiAgICB9LFxyXG4gIH07XHJcbn07XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy91dGlsL21haW4uanMiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoc3RhcnMpIHtcclxuICBjb25zdCBhcnIgPSBbJzAnLCAnMjYnLCAnNTInLCAnNzgnLCAnMTA0J107XHJcbiAgY29uc3Qgc3RycyA9IGFyci5tYXAoKHgsIGluZGV4KSA9PiAoXHJcbiAgICBgPGcgdHJhbnNmb3JtPVwidHJhbnNsYXRlKCR7eH0gMClcIiBjbGFzcz1cIiR7aW5kZXggPCBzdGFycyA/ICdhY3RpdmUnIDogJyd9XCI+XHJcbiAgICAgIDxwYXRoIGQ9XCJNMjMuMiAxMC4zMDNxLjE5NC41MDktLjA3My45Ny0xLjE4OCAyLjE4Mi01LjA2NyA1LjQ3OSAxLjAxOCA0LjE5NCAxLjIxMiA2LjcxNS4wNDkuNjc5LS41MzMgMS4wNjctLjMxNS4xOTQtLjYzLjE5NC0uMjQyIDAtLjUzMy0uMTIxLS40MTItLjI0Mi0xLjMzMy0uNjc5LTMuMjczLTEuNjI0LTQuNjA2LTIuNDczLTEuMzMzLjg0OS00LjYwNiAyLjQ3My0uOTIxLjQzNi0xLjMzMy42NzktLjYwNi4zMTUtMS4xNjQtLjA3My0uNTgyLS4zODgtLjUzMy0xLjA2Ny4xOTQtMi41MjEgMS4yMTItNi43MTUtMy44NzktMy4yOTctNS4wNjctNS40NzktLjI2Ny0uNDYxLS4wNzMtLjk3LjE3LS41MDkuNjMtLjY3OSAxLjM1OC0uNjA2IDYuODYxLS44IDEuOTg4LTUuNzcgMy4yNDgtNy4wMy4zODgtLjMzOS44MjQtLjMzOS40NjEgMCAuOC4zMzkgMS4yODUgMS4yNjEgMy4yNzMgNy4wMyA1LjUwMy4xOTQgNi44NjEuOC40NjEuMTk0LjYzLjY3OXpcIj48L3BhdGg+XHJcbiAgICAgIDwvZz5gKSk7XHJcbiAgcmV0dXJuIGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiLTAuMTIwOTk2MjY2NjAzNDY5ODUgMS40NTUwMDAxNjIxMjQ2MzM4IDEyNy4zOTQwMDEyMTU2OTYzMyAyNS4zNDYwMDQ2OTQ3MDAyNFwiPlxyXG4gIDxsaW5lYXJHcmFkaWVudCBpZD1cImhhbGZcIiB4MT1cIjBcIiB4Mj1cIjEwMCVcIiB5MT1cIjBcIiB5Mj1cIjBcIj5cclxuICA8c3RvcCBvZmZzZXQ9XCI1MCVcIiBzdG9wLWNvbG9yPVwiY3VycmVudENvbG9yXCI+PC9zdG9wPlxyXG4gIDxzdG9wIG9mZnNldD1cIjUwJVwiIHN0b3AtY29sb3I9XCIjZDVkN2RhXCI+PC9zdG9wPlxyXG4gIDwvbGluZWFyR3JhZGllbnQ+XHJcbiAgJHtzdHJzLmpvaW4oJycpfVxyXG4gIDwvc3ZnPmA7XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3V0aWwvbW9kdWxlcy9yYXRpbmdzLmpzIiwiZXhwb3J0IGRlZmF1bHQgW1xyXG4gIHtcclxuICAgIHJlY2lwZUlkOiA3MTgzODIsXHJcbiAgICB0aXRsZTogJ0xhc2FnbmUgbWVkIGhhbGxvdW1pLCBzcGVuYXQgb2NoIHB1bXBha8Okcm5vcicsXHJcbiAgICBzdGFyczogNCxcclxuICAgIGNvb2tUaW1lOiAnNjAgTUlOIHwgTUVERUwnLFxyXG4gICAgaW1hZ2U6ICdodHRwczovL3d3dy5pY2Euc2UvaW1hZ2V2YXVsdGZpbGVzL2lkXzEwNjczNC9jZl8yNTkvbGFzYWduZS1tZWQtaGFsbG91bWktc3BlbmF0LW9jaC1wdW1wYWthcm5vci03MTgzODIucG5nJyxcclxuICAgIHVybDogJ2h0dHBzOi8vd3d3LmljYS5zZS9yZWNlcHQvbGFzYWduZS1tZWQtaGFsbG91bWktc3BlbmF0LW9jaC1wdW1wYWthcm5vci03MTgzODIvJyxcclxuICAgIGNvdXBvbnM6IFtcclxuICAgICAge1xyXG4gICAgICAgIGlkOiA0NTgyNzgsXHJcbiAgICAgICAgcmVjaXBlSWQ6IDcxODM4MixcclxuICAgICAgICB0aXRsZTogJ0LDtm5wYXN0YS8gbGFzYWduZXBsYXR0b3InLFxyXG4gICAgICAgIGltYWdlOiAnaHR0cHM6Ly93d3cuaWNhLnNlL0hhbmRsZXJzL0ltYWdlLmFzaHg/dz0xNTAmaD0xNTAmbT1wJmJncj1mZmYmdT1odHRwOi8vZXh0YmlsZC5pY2Euc2UvL1BpY3R1cmVXZWIvODAvMTAzMC8xNF8xMDAwNTU1MzA5LmpwZycsXHJcbiAgICAgICAgZGlzY291bnQ6ICcyMCUgcmFiYXR0JyxcclxuICAgICAgICBzdWJ0aXRsZTogJ1Jpc2VudGEgMTIwLTIwMCBnJyxcclxuICAgICAgICB1cmw6ICcva2FtcGFuai9oc2UvNDU4Mjc4JyxcclxuICAgICAgICBQYWdlTmFtZTogJ0xTUiAxMDMwIELDtm5wYXN0YS9sYXNhZ25lcGxhdHRvcicsXHJcbiAgICAgICAgT2ZmZXJJZDogMTAwMDU1NTMwOSxcclxuICAgICAgICBDYW1wYWlnbklkOiAxMDMwLFxyXG4gICAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAgaWQ6IDQ1ODI3NixcclxuICAgICAgICByZWNpcGVJZDogNzE4MzgyLFxyXG4gICAgICAgIHRpdGxlOiAnQnVsam9uZ2t1YmVyJyxcclxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vd3d3LmljYS5zZS9IYW5kbGVycy9JbWFnZS5hc2h4P3c9MTUwJmg9MTUwJm09cCZiZ3I9ZmZmJnU9aHR0cDovL2V4dGJpbGQuaWNhLnNlLy9QaWN0dXJlV2ViLzgwLzEwMjgvMTRfMTAwMDU1NTMwNy5qcGcnLFxyXG4gICAgICAgIGRpc2NvdW50OiAnMjUlIHJhYmF0dCcsXHJcbiAgICAgICAgc3VidGl0bGU6ICdLbm9yciA2LXBhY2snLFxyXG4gICAgICAgIHVybDogJy9rYW1wYW5qL2hzZS80NTgyNzYnLFxyXG4gICAgICAgIFBhZ2VOYW1lOiAnTFNSIDEwMjggQnVsam9uZycsXHJcbiAgICAgICAgT2ZmZXJJZDogMTAwMDU1NTMwNyxcclxuICAgICAgICBDYW1wYWlnbklkOiAxMDI4LFxyXG4gICAgICB9LFxyXG4gICAgXSxcclxuICB9LFxyXG4gIHtcclxuICAgIHJlY2lwZUlkOiA3MjI4MDMsXHJcbiAgICB0aXRsZTogJ1Bhc3RhIG1lZCBmYWxhZmVsIG9jaCDDpHJ0cGVzdG8nLFxyXG4gICAgc3RhcnM6IDMsXHJcbiAgICBjb29rVGltZTogJzQ1IE1JTiB8IE1FREVMJyxcclxuICAgIGltYWdlOiAnaHR0cHM6Ly93d3cuaWNhLnNlL2ltYWdldmF1bHRmaWxlcy9pZF8xNjg4NTEvY2ZfMjU5L3Bhc3RhLW1lZC1mYWxhZmVsLWFydHBlc3RvLTcyMjgwMy03MDB4NjU0LmpwZycsXHJcbiAgICB1cmw6ICdodHRwczovL3d3dy5pY2Euc2UvcmVjZXB0L3Bhc3RhLW1lZC1mYWxhZmVsLW9jaC1hcnRwZXN0by03MjI4MDMvJyxcclxuICAgIGNvdXBvbnM6IFtcclxuICAgICAge1xyXG4gICAgICAgIGlkOiA0NTgyODAsXHJcbiAgICAgICAgcmVjaXBlSWQ6IDcyMjgwMyxcclxuICAgICAgICB0aXRsZTogJ0ZhbGFmZWwnLFxyXG4gICAgICAgIGltYWdlOiAnaHR0cHM6Ly93d3cuaWNhLnNlL0hhbmRsZXJzL0ltYWdlLmFzaHg/dz0xNTAmaD0xNTAmbT1wJmJncj1mZmYmdT1odHRwOi8vZXh0YmlsZC5pY2Euc2UvL1BpY3R1cmVXZWIvODAvMTAzMS8xNF8xMDAwNTU1MzEwLmpwZycsXHJcbiAgICAgICAgZGlzY291bnQ6ICc1IGtyIHJhYmF0dCcsXHJcbiAgICAgICAgc3VidGl0bGU6ICdGaW5kdXMgNDUwIGcnLFxyXG4gICAgICAgIHVybDogJy9rYW1wYW5qL2hzZS80NTgyODAnLFxyXG4gICAgICAgIFBhZ2VOYW1lOiAnTFNSIDEwMzEgRmFsYWZlbCcsXHJcbiAgICAgICAgT2ZmZXJJZDogMTAwMDU1NTMxMCxcclxuICAgICAgICBDYW1wYWlnbklkOiAxMDMxLFxyXG4gICAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAgaWQ6IDQ1ODI3NyxcclxuICAgICAgICByZWNpcGVJZDogNzIyODAzLFxyXG4gICAgICAgIHRpdGxlOiAnaU1hdCcsXHJcbiAgICAgICAgaW1hZ2U6ICdodHRwczovL3d3dy5pY2Euc2UvSGFuZGxlcnMvSW1hZ2UuYXNoeD93PTE1MCZoPTE1MCZtPXAmYmdyPWZmZiZ1PWh0dHA6Ly9leHRiaWxkLmljYS5zZS8vUGljdHVyZVdlYi84MC8xMDI5LzE0XzEwMDA1NTUzMDguanBnJyxcclxuICAgICAgICBkaXNjb3VudDogJzE1JSByYWJhdHQnLFxyXG4gICAgICAgIHN1YnRpdGxlOiAnT2F0bHkgMjUwIGcnLFxyXG4gICAgICAgIHVybDogJy9rYW1wYW5qL2hzZS80NTgyNzcnLFxyXG4gICAgICAgIFBhZ2VOYW1lOiAnTFNSIDEwMjkgaU1hdCcsXHJcbiAgICAgICAgT2ZmZXJJZDogMTAwMDU1NTMwOCxcclxuICAgICAgICBDYW1wYWlnbklkOiAxMDI5LFxyXG4gICAgICB9LFxyXG4gICAgXSxcclxuICB9LFxyXG4gIHtcclxuICAgIHJlY2lwZUlkOiA3MjI4NjcsXHJcbiAgICB0aXRsZTogJ0ZyeXN0IGNoZWVzZWNha2UgbWVkIHNhZmZyYW4nLFxyXG4gICAgc3RhcnM6IDQsXHJcbiAgICBjb29rVGltZTogJzEtNCBUSU0gfCBNRURFTCcsXHJcbiAgICBpbWFnZTogJ2h0dHBzOi8vd3d3LmljYS5zZS9pbWFnZXZhdWx0ZmlsZXMvaWRfMTcwODAwL2NmXzI1OS9mcnlzdC1jaGVlc2VjYWtlLW1lZC1zYWZmcmFuLTcyMjg2Ny1saXRlbi5qcGcnLFxyXG4gICAgdXJsOiAnaHR0cHM6Ly93d3cuaWNhLnNlL3JlY2VwdC9mcnlzdC1jaGVlc2VjYWtlLW1lZC1zYWZmcmFuLTcyMjg2Ny8nLFxyXG4gICAgY291cG9uczogW1xyXG4gICAgICB7XHJcbiAgICAgICAgaWQ6IDQ1ODI4MixcclxuICAgICAgICByZWNpcGVJZDogNzIyODY3LFxyXG4gICAgICAgIHRpdGxlOiAnRsOkcnNrb3N0JyxcclxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vd3d3LmljYS5zZS9IYW5kbGVycy9JbWFnZS5hc2h4P3c9MTUwJmg9MTUwJm09cCZiZ3I9ZmZmJnU9aHR0cDovL2V4dGJpbGQuaWNhLnNlLy9QaWN0dXJlV2ViLzgwLzEwMzMvMTRfMTAwMDU1NTMxMi5qcGcnLFxyXG4gICAgICAgIGRpc2NvdW50OiAnMyBrciByYWJhdHQnLFxyXG4gICAgICAgIHN1YnRpdGxlOiAnUGhpbGFkZWxwaGlhIDE3NS0zMDAgZycsXHJcbiAgICAgICAgdXJsOiAnL2thbXBhbmovaHNlLzQ1ODI4MicsXHJcbiAgICAgICAgUGFnZU5hbWU6ICdMU1IgMTAzMyBGw6Ryc2tvc3QgUGhpbGFkZWxwaWEnLFxyXG4gICAgICAgIE9mZmVySWQ6IDEwMDA1NTUzMTIsXHJcbiAgICAgICAgQ2FtcGFpZ25JZDogMTAzMyxcclxuICAgICAgfSxcclxuICAgICAge1xyXG4gICAgICAgIGlkOiA0NTgyNzQsXHJcbiAgICAgICAgcmVjaXBlSWQ6IDcyMjg2NyxcclxuICAgICAgICB0aXRsZTogJ01hcmdhcmluJyxcclxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vd3d3LmljYS5zZS9IYW5kbGVycy9JbWFnZS5hc2h4P3c9MTUwJmg9MTUwJm09cCZiZ3I9ZmZmJnU9aHR0cDovL2V4dGJpbGQuaWNhLnNlLy9QaWN0dXJlV2ViLzgwLzEwMjYvMTRfMTAwMDU1NTMwNS5qcGcnLFxyXG4gICAgICAgIGRpc2NvdW50OiAnNSBrciByYWJhdHQnLFxyXG4gICAgICAgIHN1YnRpdGxlOiAnTWlsZGEgMSBrZycsXHJcbiAgICAgICAgdXJsOiAnL2thbXBhbmovaHNlLzQ1ODI3NCcsXHJcbiAgICAgICAgUGFnZU5hbWU6ICdMU1IgMTAyNiBNYXJnYXJpbicsXHJcbiAgICAgICAgT2ZmZXJJZDogMTAwMDU1NTMwNSxcclxuICAgICAgICBDYW1wYWlnbklkOiAxMDI2LFxyXG4gICAgICB9LFxyXG4gICAgXSxcclxuICB9LFxyXG4gIHtcclxuICAgIHJlY2lwZUlkOiA3MTkzNzQsXHJcbiAgICB0aXRsZTogJ1RvcnNrIGkgdWduIG1lZCBkaWxsLSBvY2ggY2l0cm9uc8OlcycsXHJcbiAgICBzdGFyczogNCxcclxuICAgIGNvb2tUaW1lOiAnMzAgTUlOIHwgTUVERUwnLFxyXG4gICAgaW1hZ2U6ICdodHRwczovL3d3dy5pY2Euc2UvaW1hZ2V2YXVsdGZpbGVzL2lkXzEyMjcyNy9jZl8yNTkvdG9yc2staS11Z24tbWVkLWRpbGwtb2NoLWNpdHJvbnNhcy12MzgtMjAxNS03MTkzNzQuanBnJyxcclxuICAgIHVybDogJ2h0dHBzOi8vd3d3LmljYS5zZS9yZWNlcHQvdG9yc2staS11Z24tbWVkLWRpbGwtb2NoLWNpdHJvbnNhcy03MTkzNzQvJyxcclxuICAgIGNvdXBvbnM6IFtcclxuICAgICAge1xyXG4gICAgICAgIGlkOiA0NTgyODgsXHJcbiAgICAgICAgcmVjaXBlSWQ6IDcxOTM3NCxcclxuICAgICAgICB0aXRsZTogJ1RvcnNrZmlsw6knLFxyXG4gICAgICAgIGltYWdlOiAnaHR0cHM6Ly93d3cuaWNhLnNlL0hhbmRsZXJzL0ltYWdlLmFzaHg/dz0xNTAmaD0xNTAmbT1wJmJncj1mZmYmdT1odHRwOi8vZXh0YmlsZC5pY2Euc2UvL1BpY3R1cmVXZWIvODAvMTAzOC8xNF8xMDAwNTU1MzE3LmpwZycsXHJcbiAgICAgICAgZGlzY291bnQ6ICcyNSUgcmFiYXR0JyxcclxuICAgICAgICBzdWJ0aXRsZTogJ0lDQSA2MDAgZycsXHJcbiAgICAgICAgdXJsOiAnL2thbXBhbmovaHNlLzQ1ODI4OCcsXHJcbiAgICAgICAgUGFnZU5hbWU6ICdMU1IgMTAzOCBUb3Jza2ZpbMOpJyxcclxuICAgICAgICBPZmZlcklkOiAxMDAwNTU1MzE3LFxyXG4gICAgICAgIENhbXBhaWduSWQ6IDEwMzgsXHJcbiAgICAgIH0sXHJcbiAgICAgIHtcclxuICAgICAgICBpZDogNDU4Mjc0LFxyXG4gICAgICAgIHJlY2lwZUlkOiA3MTkzNzQsXHJcbiAgICAgICAgdGl0bGU6ICdNYXJnYXJpbicsXHJcbiAgICAgICAgaW1hZ2U6ICdodHRwczovL3d3dy5pY2Euc2UvSGFuZGxlcnMvSW1hZ2UuYXNoeD93PTE1MCZoPTE1MCZtPXAmYmdyPWZmZiZ1PWh0dHA6Ly9leHRiaWxkLmljYS5zZS8vUGljdHVyZVdlYi84MC8xMDI2LzE0XzEwMDA1NTUzMDUuanBnJyxcclxuICAgICAgICBkaXNjb3VudDogJzUga3IgcmFiYXR0JyxcclxuICAgICAgICBzdWJ0aXRsZTogJ01pbGRhIDEga2cnLFxyXG4gICAgICAgIHVybDogJy9rYW1wYW5qL2hzZS80NTgyNzQnLFxyXG4gICAgICAgIFBhZ2VOYW1lOiAnTFNSIDEwMjYgTWFyZ2FyaW4nLFxyXG4gICAgICAgIE9mZmVySWQ6IDEwMDA1NTUzMDUsXHJcbiAgICAgICAgQ2FtcGFpZ25JZDogMTAyNixcclxuICAgICAgfSxcclxuICAgIF0sXHJcbiAgfSxcclxuICB7XHJcbiAgICByZWNpcGVJZDogNzIxMzEwLFxyXG4gICAgdGl0bGU6ICdHbHV0ZW5mcmkgc2FmZnJhbnNrYWthJyxcclxuICAgIHN0YXJzOiA0LFxyXG4gICAgY29va1RpbWU6ICcxLTQgVElNIHwgTUVERUwnLFxyXG4gICAgaW1hZ2U6ICdodHRwczovL3d3dy5pY2Euc2UvaW1hZ2V2YXVsdGZpbGVzL2lkXzE1MDM5Ny9jZl8yNTkvZ2x1dGVuZnJpLXNhZmZyYW5za2FrYS03MjEzMTAtbGl0ZW4uanBnJyxcclxuICAgIHVybDogJ2h0dHBzOi8vd3d3LmljYS5zZS9yZWNlcHQvZ2x1dGVuZnJpLXNhZmZyYW5za2FrYS03MjEzMTAvJyxcclxuICAgIGNvdXBvbnM6IFtcclxuICAgICAge1xyXG4gICAgICAgIGlkOiA0NTgyOTgsXHJcbiAgICAgICAgcmVjaXBlSWQ6IDcyMTMxMCxcclxuICAgICAgICB0aXRsZTogJ01hbmRlbG1hc3NhJyxcclxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vd3d3LmljYS5zZS9IYW5kbGVycy9JbWFnZS5hc2h4P3c9MTUwJmg9MTUwJm09cCZiZ3I9ZmZmJnU9aHR0cDovL2V4dGJpbGQuaWNhLnNlLy9QaWN0dXJlV2ViLzgwLzEwNDQvMTRfMTAwMDU1NTMyMy5qcGcnLFxyXG4gICAgICAgIGRpc2NvdW50OiAnMjUgJSByYWJhdHQnLFxyXG4gICAgICAgIHN1YnRpdGxlOiAnSUNBIDIwMCBnJyxcclxuICAgICAgICB1cmw6ICcva2FtcGFuai9oc2UvNDU4Mjk4JyxcclxuICAgICAgICBQYWdlTmFtZTogJ0xTUiAxMDQ0IE1hbmRlbG1hc3NhJyxcclxuICAgICAgICBPZmZlcklkOiAxMDAwNTU1MzIzLFxyXG4gICAgICAgIENhbXBhaWduSWQ6IDEwNDQsXHJcbiAgICAgIH0sXHJcbiAgICAgIHtcclxuICAgICAgICBpZDogNDU4Mjc0LFxyXG4gICAgICAgIHJlY2lwZUlkOiA3MjEzMTAsXHJcbiAgICAgICAgdGl0bGU6ICdNYXJnYXJpbicsXHJcbiAgICAgICAgaW1hZ2U6ICdodHRwczovL3d3dy5pY2Euc2UvSGFuZGxlcnMvSW1hZ2UuYXNoeD93PTE1MCZoPTE1MCZtPXAmYmdyPWZmZiZ1PWh0dHA6Ly9leHRiaWxkLmljYS5zZS8vUGljdHVyZVdlYi84MC8xMDI2LzE0XzEwMDA1NTUzMDUuanBnJyxcclxuICAgICAgICBkaXNjb3VudDogJzUga3IgcmFiYXR0JyxcclxuICAgICAgICBzdWJ0aXRsZTogJ01pbGRhIDEga2cnLFxyXG4gICAgICAgIHVybDogJy9rYW1wYW5qL2hzZS80NTgyNzQnLFxyXG4gICAgICAgIFBhZ2VOYW1lOiAnTFNSIDEwMjYgTWFyZ2FyaW4nLFxyXG4gICAgICAgIE9mZmVySWQ6IDEwMDA1NTUzMDUsXHJcbiAgICAgICAgQ2FtcGFpZ25JZDogMTAyNixcclxuICAgICAgfSxcclxuICAgIF0sXHJcbiAgfSxcclxuICB7XHJcbiAgICByZWNpcGVJZDogNzIyOTIyLFxyXG4gICAgdGl0bGU6ICdNb3phcnRrdWxvcicsXHJcbiAgICBzdGFyczogNSxcclxuICAgIGNvb2tUaW1lOiAnMzAgTUlOIHwgTUVERUwnLFxyXG4gICAgaW1hZ2U6ICdodHRwczovL3d3dy5pY2Euc2UvaW1hZ2V2YXVsdGZpbGVzL2lkXzE3MjQ5OS9jZl8yNTkvbW96YXJ0a3Vsb3ItNzIyOTIyLTU4MHg1ODAuanBnJyxcclxuICAgIHVybDogJ2h0dHBzOi8vd3d3LmljYS5zZS9yZWNlcHQvbW96YXJ0a3Vsb3ItNzIyOTIyLycsXHJcbiAgICBjb3Vwb25zOiBbXHJcbiAgICAgIHtcclxuICAgICAgICBpZDogNDU4Mjk4LFxyXG4gICAgICAgIHJlY2lwZUlkOiA3MjI5MjIsXHJcbiAgICAgICAgdGl0bGU6ICdNYW5kZWxtYXNzYScsXHJcbiAgICAgICAgaW1hZ2U6ICdodHRwczovL3d3dy5pY2Euc2UvSGFuZGxlcnMvSW1hZ2UuYXNoeD93PTE1MCZoPTE1MCZtPXAmYmdyPWZmZiZ1PWh0dHA6Ly9leHRiaWxkLmljYS5zZS8vUGljdHVyZVdlYi84MC8xMDQ0LzE0XzEwMDA1NTUzMjMuanBnJyxcclxuICAgICAgICBkaXNjb3VudDogJzI1ICUgcmFiYXR0JyxcclxuICAgICAgICBzdWJ0aXRsZTogJ0lDQSAyMDAgZycsXHJcbiAgICAgICAgdXJsOiAnL2thbXBhbmovaHNlLzQ1ODI5OCcsXHJcbiAgICAgICAgUGFnZU5hbWU6ICdMU1IgMTA0NCBNYW5kZWxtYXNzYScsXHJcbiAgICAgICAgT2ZmZXJJZDogMTAwMDU1NTMyMyxcclxuICAgICAgICBDYW1wYWlnbklkOiAxMDQ0LFxyXG4gICAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAgaWQ6IDQ1ODI5NyxcclxuICAgICAgICByZWNpcGVJZDogNzIyOTIyLFxyXG4gICAgICAgIHRpdGxlOiAnQmFrbm91Z2F0JyxcclxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vd3d3LmljYS5zZS9IYW5kbGVycy9JbWFnZS5hc2h4P3c9MTUwJmg9MTUwJm09cCZiZ3I9ZmZmJnU9aHR0cDovL2V4dGJpbGQuaWNhLnNlLy9QaWN0dXJlV2ViLzgwLzEwNDMvMTRfMTAwMDU1NTMyMi5qcGcnLFxyXG4gICAgICAgIGRpc2NvdW50OiAnNSBrciByYWJhdHQnLFxyXG4gICAgICAgIHN1YnRpdGxlOiAnSUNBIDI1MCBnJyxcclxuICAgICAgICB1cmw6ICcva2FtcGFuai9oc2UvNDU4Mjk3JyxcclxuICAgICAgICBQYWdlTmFtZTogJ0xTUiAxMDQzIEJha25vdWdhdCcsXHJcbiAgICAgICAgT2ZmZXJJZDogMTAwMDU1NTMyMixcclxuICAgICAgICBDYW1wYWlnbklkOiAxMDQzLFxyXG4gICAgICB9LFxyXG4gICAgXSxcclxuICB9LFxyXG5dO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc3RhcnQtcGFnZS9iYW5uZXJzLmpzIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vc3R5bGUuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL3N0eWxlLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9zdHlsZS5jc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3N0YXJ0LXBhZ2Uvc3R5bGUuY3NzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodW5kZWZpbmVkKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi8qLmNybyBoZWFkZXIgLmltYWdlLXNsaWRlciB7XFxyXFxuICBwb3NpdGlvbjogYWJzb2x1dGUgIWltcG9ydGFudDtcXHJcXG59Ki9cXHJcXG5cXHJcXG4vKlxcclxcbmJhY2tncm91bmQtcG9zaXRpb246IC0zMzhweCAtMTg4NXB4OyBwcmV2XFxyXFxuXFxyXFxuXFxyXFxuYmFja2dyb3VuZC1wb3NpdGlvbjogLTQzOHB4IC0xODg1cHg7XFxyXFxuICovXFxyXFxuXFxyXFxuLmNybyAjaGVhZGVyIHtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcclxcbn1cXHJcXG5cXHJcXG4uc2xpY2stc2xpZGUsIC5zbGljay10cmFjazpmb2N1cyB7XFxyXFxuICBvdXRsaW5lOiBub25lO1xcclxcbn1cXHJcXG4uc3RhcnQtcGFnZS1pY2FzZSAjaGVhZGVyIHtcXHJcXG4gIGhlaWdodDogMTAwJTtcXHJcXG59XFxyXFxuLmNvdXBvbi1iYW5uZXIge1xcclxcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcclxcbiAgbWFyZ2luLWJvdHRvbTogMzBweDtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6ICNGNUU5RjA7XFxyXFxufVxcclxcbi5jb3Vwb24tYmFubmVyIGltZyB7XFxyXFxuICBtYXJnaW46IDEwcHggMCAwO1xcclxcbn1cXHJcXG4uY3JvIC5zZWFyY2gtcmVjaXBlLWNvbnRhaW5lciB7XFxyXFxuICBtYXJnaW4tYm90dG9tOiAyMHB4O1xcclxcbn1cXHJcXG4uY3JvIC5zZWFyY2gtcmVjaXBlLWNvbnRhaW5lciBpbWcge1xcclxcbiAgbWFyZ2luLWJvdHRvbTogMjBweDtcXHJcXG59XFxyXFxuLmNybyAuc2VhcmNoLXJlY2lwZS1jb250YWluZXIgaDEsIC5jb3Vwb24tYmFubmVyIGgxIHtcXHJcXG4gIGZvbnQtc2l6ZTogMi44cmVtO1xcclxcbn1cXHJcXG4uY3JvIC5zZWFyY2gtcmVjaXBlLWNvbnRhaW5lcl9fYWxsLXJlY2lwZXMge1xcclxcbiAgZm9udC1zaXplOiAyLjJyZW07XFxyXFxufVxcclxcbi5jcm8gLnBsIC5jb250YWluZXItYmFja2Ryb3Age1xcclxcbiAgcGFkZGluZzogMTVweCAxMHB4IDMwcHg7XFxyXFxufVxcclxcblxcclxcbi5zbGljay1wcmV2OmJlZm9yZSwgLnNsaWNrLW5leHQ6YmVmb3JlIHsgY29udGVudDogJycgfVxcclxcbi5zbGljay1wcmV2IHtcXHJcXG4gIHRvcDogMTcwcHg7XFxyXFxuICBsZWZ0OiAtMTBweDtcXHJcXG4gIGJhY2tncm91bmQtcG9zaXRpb246IC0zMzhweCAtMTg4NXB4O1xcclxcbiAgd2lkdGg6IDQwcHggIWltcG9ydGFudDtcXHJcXG4gIGhlaWdodDogNDBweCAhaW1wb3J0YW50O1xcclxcbn1cXHJcXG4uc2xpY2stbmV4dCB7XFxyXFxuICB0b3A6IDE3MHB4O1xcclxcbiAgcmlnaHQ6IDVweDtcXHJcXG4gIGJhY2tncm91bmQtcG9zaXRpb246IC00MzhweCAtMTg4NXB4O1xcclxcbiAgd2lkdGg6IDQwcHggIWltcG9ydGFudDtcXHJcXG4gIGhlaWdodDogNDBweCAhaW1wb3J0YW50O1xcclxcbn1cXHJcXG5cXHJcXG4uY3JvIC5zbGljay1wcmV2OmhvdmVyLFxcclxcbi5jcm8gLnNsaWNrLXByZXY6Zm9jdXMsXFxyXFxuLmNybyAuc2xpY2stcHJldjphY3RpdmUge1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxyXFxuICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtMzM4cHggLTE4ODVweDtcXHJcXG59XFxyXFxuLmNybyAuc2xpY2stbmV4dDpob3ZlcixcXHJcXG4uY3JvIC5zbGljay1uZXh0OmZvY3VzLFxcclxcbi5jcm8gLnNsaWNrLW5leHQ6YWN0aXZlIHtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcclxcbiAgYmFja2dyb3VuZC1wb3NpdGlvbjogLTQzOHB4IC0xODg1cHg7XFxyXFxufVxcclxcbi5jcm8gLnNsaWNrLWFycm93IHtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcclxcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCcvVGVtcGxhdGVzL0dlbmVyYWwvVmlld3MvSW1hZ2VzL1JXRC9zcHJpdGVzL2dlbmVyYWxfc3ByaXRlMS5wbmc/MScpO1xcclxcbiAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXHJcXG59XFxyXFxuYnV0dG9uOmZvY3VzLCBidXR0b246YWN0aXZlIHtvdXRsaW5lOjA7fVxcclxcbi5zbGljay1pbml0aWFsaXplZCAuc2xpY2stc2xpZGVyIHtcXHJcXG4gIG91dGxpbmU6IG5vbmU7XFxyXFxufVxcclxcbi5jcm8gLmJhbm5lci1jb250YWluZXIge1xcclxcbiAgd2lkdGg6IDEwMCU7XFxyXFxuICBoZWlnaHQ6IDEwMCU7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcXHJcXG4gIHotaW5kZXg6IDIwICFpbXBvcnRhbnQ7XFxyXFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxyXFxufVxcclxcblxcclxcbi5jcm8gLmJhbm5lci1jb250YWluZXJfX2ltZyB7XFxyXFxuICB3aWR0aDogaW5oZXJpdDtcXHJcXG4gIGhlaWdodDogMzIwcHg7XFxyXFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICB0b3A6IDA7XFxyXFxuICBvdmVyZmxvdzogaGlkZGVuO1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogYmxhY2s7XFxyXFxufVxcclxcblxcclxcbi5jcm8gLmJhbm5lci1jb250YWluZXJfX2ltZyBpbWcgeyBoZWlnaHQ6IGF1dG87IHdpZHRoOiAxMDAlOyBvcGFjaXR5OiAuODsgfVxcclxcblxcclxcbi5jcm8gLmJhbm5lci1jb250YWluZXJfX3RleHQtY29udGFpbmVyIHtcXHJcXG4gIG1heC13aWR0aDogMTAwJTtcXHJcXG4gIG1hcmdpbjogNzBweCAzNXB4IDEwcHg7XFxyXFxuICB0ZXh0LXNoYWRvdzogMCAwIDVweCByZ2JhKDAsIDAsIDAsIDAuNCk7XFxyXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxufVxcclxcblxcclxcbi5jcm8gLnRleHQtY29udGFpbmVyX190aXRsZSB7XFxyXFxuICBmb250LXNpemU6IDM2cHg7XFxyXFxuICBjb2xvcjogd2hpdGU7XFxyXFxuICBmb250LWZhbWlseTogaWNhcnVicmlrO1xcclxcbiAgZm9udC13ZWlnaHQ6IDYwMDtcXHJcXG4gIGxpbmUtaGVpZ2h0OiAzcmVtO1xcclxcbiAgd2hpdGUtc3BhY2U6IG5vcm1hbDtcXHJcXG59XFxyXFxuXFxyXFxuLmNybyAudGV4dC1jb250YWluZXJfX3JhdGluZ3Mgc3ZnIC5hY3RpdmUge1xcclxcbiAgZmlsbDogI0VCMUYwNztcXHJcXG59XFxyXFxuXFxyXFxuLmNybyAudGV4dC1jb250YWluZXJfX3JhdGluZ3Mgc3ZnIHtcXHJcXG4gIC8qZGlzcGxheTogaW5saW5lLWJsb2NrOyovXFxyXFxuICBkaXNwbGF5OiBibG9jaztcXHJcXG4gIGZpbGw6ICNENUQ3REE7XFxyXFxuICBoZWlnaHQ6IDE4cHg7XFxyXFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcclxcbiAgd2lkdGg6IDkxcHg7XFxyXFxuICAtd2Via2l0LWZpbHRlcjogZHJvcC1zaGFkb3coIDFweCAxcHggMnB4IHJnYmEoMCwwLDAsMC40KSApO1xcclxcbiAgZmlsdGVyOiBkcm9wLXNoYWRvdyggMXB4IDFweCAycHggcmdiYSgwLDAsMCwwLjQpICk7XFxyXFxufVxcclxcblxcclxcbi5jcm8gLnRleHQtY29udGFpbmVyX19kaWZmaWN1bHR5IHtcXHJcXG4gIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XFxyXFxuICBmb250OiAxNnB4IGljYXRleHQ7XFxyXFxuICBmb250LXdlaWdodDogOTAwO1xcclxcbiAgbWFyZ2luLXRvcDogNnB4O1xcclxcbiAgY29sb3I6IHdoaXRlO1xcclxcbn1cXHJcXG5cXHJcXG4uY3JvIC5jb3Vwb25zLWNvbnRhaW5lciB7XFxyXFxuICB3aWR0aDogMTAwJTtcXHJcXG4gIHotaW5kZXg6IDk5OTtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBmbGV4LWRpcmVjdGlvbjogcm93O1xcclxcbiAgcGFkZGluZzogNXB4O1xcclxcbiAgLyptYXJnaW4tYm90dG9tOiAyMHB4OyovXFxyXFxufVxcclxcblxcclxcbi5jcm8gLmNvdXBvbnMtY29udGFpbmVyX19pdGVtIHtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcclxcbiAgd2lkdGg6IDUwJTtcXHJcXG4gIG1hcmdpbjogMCA0cHg7XFxyXFxuICBwYWRkaW5nOiAxMHB4O1xcclxcbiAgYm9yZGVyOiA4cHggc29saWQgcmdiYSgyMTcsMjAsOTksMC4xKTtcXHJcXG4gIGJvcmRlci1ib3R0b20td2lkdGg6IDE3cHg7XFxyXFxuICBib3JkZXItcmFkaXVzOiA2cHg7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXHJcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG59XFxyXFxuXFxyXFxuLmNybyAuY291cG9ucy1jb250YWluZXJfX2l0ZW06YWZ0ZXIge1xcclxcbiAgYmFja2dyb3VuZDogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEQ5NGJXd2dkbVZ5YzJsdmJqMGlNUzR3SWlCbGJtTnZaR2x1WnowaWRYUm1MVGdpUHo0OGMzWm5JSFpsY25OcGIyNDlJakV1TVNJZ2FXUTlJa3hoZVdWeVh6RWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SWdlRzFzYm5NNmVHeHBibXM5SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpFNU9Ua3ZlR3hwYm1zaUlIZzlJakJ3ZUNJZ2VUMGlNSEI0SWlCMmFXVjNRbTk0UFNJd0lEQWdNakFnTVRBaUlITjBlV3hsUFNKbGJtRmliR1V0WW1GamEyZHliM1Z1WkRwdVpYY2dNQ0F3SURJd0lERXdPeUlnZUcxc09uTndZV05sUFNKd2NtVnpaWEoyWlNJK1BITjBlV3hsSUhSNWNHVTlJblJsZUhRdlkzTnpJajR1YzNRd2UyWnBiR3c2STJabVpqdDlQQzl6ZEhsc1pUNDhjR0YwYUNCamJHRnpjejBpYzNRd0lpQmtQU0pOTVRBc01pNDFZeTAwTGpFc01DMDNMalVzTXk0MExUY3VOU3czTGpWb01UVkRNVGN1TlN3MUxqa3NNVFF1TWl3eUxqVXNNVEFzTWk0MWVpSXZQand2YzNablBnPT0pIHNwYWNlO1xcclxcbiAgYmFja2dyb3VuZC1zaXplOiAyNnB4IDEzcHg7XFxyXFxuICBjb250ZW50OiAnJztcXHJcXG4gIGRpc3BsYXk6IGJsb2NrO1xcclxcbiAgd2lkdGg6IDE0MCU7XFxyXFxuICBoZWlnaHQ6IDEzcHg7XFxyXFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICBib3R0b206IC0xN3B4O1xcclxcbiAgbGVmdDogLTMwcHg7XFxyXFxufVxcclxcblxcclxcbi5jcm8gLmNvdXBvbnMtY29udGFpbmVyX19pdGVtIGltZyB7XFxyXFxuICB3aWR0aDogNjAlICFpbXBvcnRhbnQ7XFxyXFxuICBoZWlnaHQ6IGF1dG8gIWltcG9ydGFudDtcXHJcXG4gIG1hcmdpbjogMCBhdXRvIDEwcHggIWltcG9ydGFudDtcXHJcXG59XFxyXFxuXFxyXFxuLmNybyAuY291cG9ucy1jb250YWluZXIgLmNvdXBvbnMtY29udGFpbmVyX19pdGVtIGgzIHtcXHJcXG4gIGZvbnQtc2l6ZTogMTZweDtcXHJcXG4gIGxpbmUtaGVpZ2h0OiAxZW07XFxyXFxuICBtYXJnaW4tYm90dG9tOiA2cHg7XFxyXFxufVxcclxcblxcclxcbi5jcm8gLmNvdXBvbnMtY29udGFpbmVyIC5jb3Vwb25zLWNvbnRhaW5lcl9faXRlbSBoMSB7XFxyXFxuICBmb250LXNpemU6IDIycHg7XFxyXFxuICBmb250LXdlaWdodDogNzAwO1xcclxcbiAgY29sb3I6ICNFQjFGMDc7XFxyXFxuICBsaW5lLWhlaWdodDogMS41cmVtO1xcclxcbn1cXHJcXG5cXHJcXG4uY3JvIC5jb3Vwb25zLWNvbnRhaW5lciAuY291cG9ucy1jb250YWluZXJfX2l0ZW0gaDQge1xcclxcbiAgY29sb3I6ICM4MDgyODM7XFxyXFxuICBmb250LXNpemU6IDEuM3JlbTtcXHJcXG4gIGxpbmUtaGVpZ2h0OiAxLjQ7XFxyXFxuICBmb250LWZhbWlseTogaWNhdGV4dDtcXHJcXG4gIGZvbnQtd2VpZ2h0OiBub3JtYWw7XFxyXFxufVxcclxcblxcclxcbi5jcm8gLmNvdXBvbnMtY29udGFpbmVyIC5jb3Vwb25zLWNvbnRhaW5lcl9faXRlbSBhIHtcXHJcXG4gIGZvbnQtc2l6ZTogMTRweDtcXHJcXG4gIGxpbmUtaGVpZ2h0OiAxNXB4O1xcclxcbiAgbWFyZ2luLWJvdHRvbTogNXB4O1xcclxcbn1cXHJcXG5cXHJcXG4uY3JvIC5jb3Vwb25zLWNvbnRhaW5lciAuY291cG9ucy1jb250YWluZXJfX2l0ZW0gLmNvdXBvbi1idXR0b24ge1xcclxcbiAgZm9udC1zaXplOiAxMnB4O1xcclxcbiAgbGluZS1oZWlnaHQ6IDIuMnJlbTtcXHJcXG4gIG1pbi13aWR0aDogYXV0bztcXHJcXG4gIGFsaWduLXNlbGY6IGNlbnRlcjtcXHJcXG4gIHdpZHRoOiAxMDAlO1xcclxcbiAgYmFja2dyb3VuZDogI0Y4RUJGMztcXHJcXG4gIGNvbG9yOiAjQTAyOTcxO1xcclxcbn1cXHJcXG5cXHJcXG4uY3JvIC5jb3Vwb25zLWNvbnRhaW5lciAuY291cG9ucy1jb250YWluZXJfX2l0ZW0ub2ZmZXItbG9hZGVkIC5jb3Vwb24tYnV0dG9uIHtcXHJcXG4gIGJhY2tncm91bmQ6ICNEREU5QkY7XFxyXFxuICBjb2xvcjogIzhEQjcyQztcXHJcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcbiAgdHJhbnNpdGlvbjogd2lkdGggLjJzIGVhc2UsIGNvbG9yIC4ycyAyNTBtcyBlYXNlLCBiYWNrZ3JvdW5kIC4ycyBlYXNlO1xcclxcbn1cXHJcXG5cXHJcXG4uY3JvIC5jb3Vwb25zLWNvbnRhaW5lciAuY291cG9ucy1jb250YWluZXJfX2l0ZW0gLmNvdXBvbnMtaW1hZ2Uge1xcclxcbiAgd2lkdGg6IDEwMCU7XFxyXFxuICBoZWlnaHQ6IDYwcHg7XFxyXFxuICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcclxcbiAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xcclxcbiAgYmFja2dyb3VuZC1wb3NpdGlvbjogY2VudGVyO1xcclxcbn1cXHJcXG5cXHJcXG4uY3JvIC5iYW5uZXItd3JhcHBlciAuYmFubmVyLWltYWdlIGltZyB7XFxyXFxuICB3aWR0aDogMTAwJTtcXHJcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG4gIG1hcmdpbi1sZWZ0OiAwICFpbXBvcnRhbnQ7XFxyXFxuICBoZWlnaHQ6IGF1dG8gIWltcG9ydGFudDtcXHJcXG4gIG1hcmdpbi10b3A6IDAgIWltcG9ydGFudDtcXHJcXG4gIG1pbi13aWR0aDogMzc1cHg7XFxyXFxufVxcclxcblxcclxcbi5jcm8gLmJ1dHRvbi13cmFwcGVyIHtcXHJcXG4gIG1hcmdpbjogMTBweCAwIDMwcHggMzVweDtcXHJcXG59XFxyXFxuXFxyXFxuLmNybyAuYmFubmVyLWJ1dHRvbiB7XFxyXFxuICB3aWR0aDogNjAlO1xcclxcbiAgZGlzcGxheTogYmxvY2s7XFxyXFxuICBvdmVyZmxvdzogaGlkZGVuO1xcclxcbn1cXHJcXG4uY3JvIC5iYW5uZXItYnV0dG9uIC5sYXllciB7XFxyXFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICB0b3A6IC0zMHB4O1xcclxcbiAgcmlnaHQ6IDIwJTtcXHJcXG4gIHRyYW5zaXRpb246IGFsbCAwLjVzIGVhc2U7XFxyXFxufVxcclxcbi5jcm8gLmJhbm5lci1idXR0b24uc2F2ZWQge1xcclxcbiAgYmFja2dyb3VuZDogI0RERTlCRjtcXHJcXG4gIGNvbG9yOiAjOERCNzJDO1xcclxcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxyXFxuICB0cmFuc2l0aW9uOiB3aWR0aCAuMnMgZWFzZSwgY29sb3IgLjJzIDI1MG1zIGVhc2UsIGJhY2tncm91bmQgLjJzIGVhc2U7XFxyXFxuICBmb250LXdlaWdodDogNDAwO1xcclxcbn1cXHJcXG5cXHJcXG4uY3JvIC5iYW5uZXItYnV0dG9uLmFkZGVkIC5sYXllcntcXHJcXG4gIHRvcDogMDtcXHJcXG59XFxyXFxuXFxyXFxuLmNybyAub2ZmZXJzLWJ1dHRvbiB7XFxyXFxuICB3aWR0aDogOTAlO1xcclxcbiAgbWFyZ2luLWJvdHRvbTogMjBweDtcXHJcXG59XFxyXFxuXFxyXFxuLmNybyAucmF0aW5nLXN0YXItY29udGFpbmVyIHtcXHJcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gIHotaW5kZXg6IDUwO1xcclxcbiAgbWFyZ2luOjEwcHg7XFxyXFxuICB0b3A6IDMwcHg7XFxyXFxuICBjb2xvcjogd2hpdGU7XFxyXFxuICB0ZXh0LXNoYWRvdzogMCAwIDVweCByZ2JhKDAsIDAsIDAsIDAuNCk7XFxyXFxufVxcclxcblxcclxcbi5jcm8gLmljYS1jYXJkLWNvbnRhaW5lciB7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG4gIG1pbi1oZWlnaHQ6IDI1MHB4O1xcclxcbn1cXHJcXG5cXHJcXG4uY3JvIC5pY2EtY2FyZC1jb250YWluZXIgaDEge1xcclxcbiAgY29sb3I6ICNFQjFGMDc7XFxyXFxufVxcclxcblxcclxcbi5jcm8gLmljYS1jYXJkLWNvbnRhaW5lciBhIHtcXHJcXG4gIGFsaWduLXNlbGY6IGZsZXgtc3RhcnQ7XFxyXFxuICBtYXgtd2lkdGg6IDI1MHB4O1xcclxcbiAgbWFyZ2luLXRvcDotMTYwcHg7XFxyXFxufVxcclxcblxcclxcbi5jcm8gLmljYS1jYXJkLWNvbnRhaW5lciBpbWcge1xcclxcbiAgbWF4LXdpZHRoOiAzODVweDtcXHJcXG4gIHdpZHRoOiA4MCU7XFxyXFxuICBhbGlnbi1zZWxmOiBmbGV4LWVuZDtcXHJcXG4gIG1hcmdpbi10b3A6LTEyMHB4O1xcclxcbn1cXHJcXG5cXHJcXG5AbWVkaWEgb25seSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDk2MHB4KXtcXHJcXG4gIC5jcm8gLmljYS1jYXJkLWNvbnRhaW5lciB7XFxyXFxuICAgIG1pbi1oZWlnaHQ6IG5vbmU7XFxyXFxuICB9XFxyXFxuXFxyXFxuICAuY3JvIC5pY2EtY2FyZC1jb250YWluZXIgaDEge1xcclxcbiAgICBsaW5lLWhlaWdodDogM3JlbTtcXHJcXG4gICAgZm9udC1zaXplOiAzcmVtO1xcclxcbiAgICBtYXJnaW4tYm90dG9tOiAyMHB4O1xcclxcbiAgfVxcclxcblxcclxcbiAgLmNybyAuaWNhLWNhcmQtY29udGFpbmVyIGEge1xcclxcbiAgICBhbGlnbi1zZWxmOiBjZW50ZXI7XFxyXFxuICAgIG1hcmdpbi10b3A6IDIwcHg7XFxyXFxuICAgIG1heC13aWR0aDogbm9uZTtcXHJcXG4gICAgd2lkdGg6IDEwMCU7XFxyXFxuICB9XFxyXFxuXFxyXFxuICAuY3JvIC5pY2EtY2FyZC1jb250YWluZXIgaW1nIHtcXHJcXG4gICAgYWxpZ24tc2VsZjogY2VudGVyO1xcclxcbiAgICBtYXJnaW4tdG9wOmF1dG87XFxyXFxuICB9XFxyXFxuXFxyXFxuICAuY3JvIC5vZmZlcnMtY29udGFpbmVyIHtcXHJcXG4gICAgd2lkdGg6IDEwMCU7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcclxcbiAgICAtd2Via2l0LWZpbHRlcjogZHJvcC1zaGFkb3coIDFweCAxcHggMnB4IHJnYmEoMCwwLDAsMC40KSApO1xcclxcbiAgICBmaWx0ZXI6IGRyb3Atc2hhZG93KCAxcHggMXB4IDJweCByZ2JhKDAsMCwwLDAuNCkgKTtcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIC5zdGFydC1wYWdlLWljYXNlID4gaGVhZGVyLmZ1bGwtc2l6ZS1pbWFnZSAuaW1hZ2Utc2xpZGVyLFxcclxcbiAgLnN0YXJ0LXBhZ2UtaWNhc2UgPiBoZWFkZXIuZnVsbC1zaXplLWltYWdlIC5pbWFnZS1zbGlkZXIgdWwsXFxyXFxuICAuc3RhcnQtcGFnZS1pY2FzZSA+IGhlYWRlci5mdWxsLXNpemUtaW1hZ2UgLmltYWdlLXNsaWRlciBsaSB7XFxyXFxuICAgIG1heC1oZWlnaHQ6IDEwMCU7XFxyXFxuICAgIHdpZHRoOiAxMDAlICFpbXBvcnRhbnQ7XFxyXFxuICAgIGhlaWdodDogMTAwJSAhaW1wb3J0YW50O1xcclxcbiAgfVxcclxcbn1cXHJcXG4uY3JvIC51bnNsaWRlci1jb250cm9scyB7IHBvaW50ZXItZXZlbnRzOiBub25lOyB9XFxyXFxuLmNybyAudW5zbGlkZXItYXJyb3cgeyBwb2ludGVyLWV2ZW50czogYXV0bzsgfVxcclxcblxcclxcbkBtZWRpYSAobWF4LXdpZHRoOiA3NjdweCkgeyAuY3JvIC5jcm8taWZyYW1lLWNvbnRhaW5lciB7IHBhZGRpbmctYm90dG9tOiAxMzUlICFpbXBvcnRhbnQ7IH0gfVxcclxcbi5jcm8gPiAuY3JvLWlmcmFtZS1jb250YWluZXIgeyBkaXNwbGF5OiBub25lOyB9XFxyXFxuLmNybyAubW9kYWwtY29wbnRhaW5lciAuY3JvLWlmcmFtZS1jb250YWluZXIgeyBkaXNwbGF5OiBpbml0aWFsOyB9XFxyXFxuLmNybyAuY29udGFpbmVyIHsgdGV4dC1hbGlnbjogY2VudGVyOyBtYXJnaW4tdG9wOiA1MHB4O31cXHJcXG4uY3JvIC5jb250YWluZXIgaDIgeyBmb250OiAyOHB4IGljYWhhbmQ7IG1hcmdpbi1ib3R0b206IDIwcHg7IH1cXHJcXG4uY3JvIC5jcm8taWZyYW1lLWNvbnRhaW5lciB7XFxyXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxuICBoZWlnaHQ6IDA7XFxyXFxuICBvdmVyZmxvdzogaGlkZGVuO1xcclxcbiAgcGFkZGluZy1ib3R0b206IDg1JTtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6ICNGM0YwRUI7XFxyXFxufVxcclxcbi5jcm8gLmNyby1pZnJhbWUtY29udGFpbmVyIGlmcmFtZSB7XFxyXFxuICBvcGFjaXR5OiAwO1xcclxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgdG9wOiAwO1xcclxcbiAgbGVmdDogMDtcXHJcXG4gIHdpZHRoOiAxMDAlO1xcclxcbiAgaGVpZ2h0OiAxMDAlO1xcclxcbn1cXHJcXG5cXHJcXG4uY3JvIC51c3AtbGlzdCB7IG1hcmdpbi1ib3R0b206IDEwcHg7IH1cXHJcXG5cXHJcXG4uY3JvIC51c3AtbGlzdCBsaSB7XFxyXFxuICBmb250OiAyNHB4IGljYXJ1YnJpaztcXHJcXG4gIGZvbnQtd2VpZ2h0OiA2MDA7XFxyXFxuICBtYXJnaW4tYm90dG9tOiAxNXB4O1xcclxcbn1cXHJcXG4uY3JvIC51c3AtbGlzdCBzdmcge1xcclxcbiAgZmlsbDogIzhEQjcyQztcXHJcXG4gIG1hcmdpbi1yaWdodDogNXB4O1xcclxcbn1cXHJcXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyIS4vc3JjL3N0YXJ0LXBhZ2Uvc3R5bGUuY3NzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1c2VTb3VyY2VNYXApIHtcblx0dmFyIGxpc3QgPSBbXTtcblxuXHQvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApO1xuXHRcdFx0aWYoaXRlbVsyXSkge1xuXHRcdFx0XHRyZXR1cm4gXCJAbWVkaWEgXCIgKyBpdGVtWzJdICsgXCJ7XCIgKyBjb250ZW50ICsgXCJ9XCI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gY29udGVudDtcblx0XHRcdH1cblx0XHR9KS5qb2luKFwiXCIpO1xuXHR9O1xuXG5cdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG5cdGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcblx0XHRpZih0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIilcblx0XHRcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcblx0XHR2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaWQgPSB0aGlzW2ldWzBdO1xuXHRcdFx0aWYodHlwZW9mIGlkID09PSBcIm51bWJlclwiKVxuXHRcdFx0XHRhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG5cdFx0fVxuXHRcdGZvcihpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gbW9kdWxlc1tpXTtcblx0XHRcdC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcblx0XHRcdC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXG5cdFx0XHQvLyAgd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxuXHRcdFx0Ly8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcblx0XHRcdGlmKHR5cGVvZiBpdGVtWzBdICE9PSBcIm51bWJlclwiIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG5cdFx0XHRcdGlmKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcblx0XHRcdFx0fSBlbHNlIGlmKG1lZGlhUXVlcnkpIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gXCIoXCIgKyBpdGVtWzJdICsgXCIpIGFuZCAoXCIgKyBtZWRpYVF1ZXJ5ICsgXCIpXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGlzdC5wdXNoKGl0ZW0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0cmV0dXJuIGxpc3Q7XG59O1xuXG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgJyc7XG5cdHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblx0aWYgKCFjc3NNYXBwaW5nKSB7XG5cdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdH1cblxuXHRpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG5cdFx0dmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcblx0XHRcdHJldHVybiAnLyojIHNvdXJjZVVSTD0nICsgY3NzTWFwcGluZy5zb3VyY2VSb290ICsgc291cmNlICsgJyAqLydcblx0XHR9KTtcblxuXHRcdHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuXHR9XG5cblx0cmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn1cblxuLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcblx0dmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSk7XG5cdHZhciBkYXRhID0gJ3NvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LCcgKyBiYXNlNjQ7XG5cblx0cmV0dXJuICcvKiMgJyArIGRhdGEgKyAnICovJztcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHt9O1xuXG52YXJcdG1lbW9pemUgPSBmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW87XG5cblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiBtZW1vO1xuXHR9O1xufTtcblxudmFyIGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcblx0Ly8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3Ncblx0Ly8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuXHQvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG5cdC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuXHQvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcblx0cmV0dXJuIHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iO1xufSk7XG5cbnZhciBnZXRFbGVtZW50ID0gKGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbyA9IHt9O1xuXG5cdHJldHVybiBmdW5jdGlvbihzZWxlY3Rvcikge1xuXHRcdGlmICh0eXBlb2YgbWVtb1tzZWxlY3Rvcl0gPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdHZhciBzdHlsZVRhcmdldCA9IGZuLmNhbGwodGhpcywgc2VsZWN0b3IpO1xuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblx0XHRcdGlmIChzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG5cdFx0XHRcdFx0Ly8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcblx0XHRcdFx0XHRzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuXHRcdFx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdFx0XHRzdHlsZVRhcmdldCA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG1lbW9bc2VsZWN0b3JdID0gc3R5bGVUYXJnZXQ7XG5cdFx0fVxuXHRcdHJldHVybiBtZW1vW3NlbGVjdG9yXVxuXHR9O1xufSkoZnVuY3Rpb24gKHRhcmdldCkge1xuXHRyZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpXG59KTtcblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXJcdHNpbmdsZXRvbkNvdW50ZXIgPSAwO1xudmFyXHRzdHlsZXNJbnNlcnRlZEF0VG9wID0gW107XG5cbnZhclx0Zml4VXJscyA9IHJlcXVpcmUoXCIuL3VybHNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xuXHRpZiAodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XG5cdFx0aWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuXHR9XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0b3B0aW9ucy5hdHRycyA9IHR5cGVvZiBvcHRpb25zLmF0dHJzID09PSBcIm9iamVjdFwiID8gb3B0aW9ucy5hdHRycyA6IHt9O1xuXG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cdGlmICghb3B0aW9ucy5zaW5nbGV0b24pIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIDxoZWFkPiBlbGVtZW50XG5cdGlmICghb3B0aW9ucy5pbnNlcnRJbnRvKSBvcHRpb25zLmluc2VydEludG8gPSBcImhlYWRcIjtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgdGhlIHRhcmdldFxuXHRpZiAoIW9wdGlvbnMuaW5zZXJ0QXQpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xuXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucyk7XG5cblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcblx0XHR9XG5cblx0XHRpZihuZXdMaXN0KSB7XG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QsIG9wdGlvbnMpO1xuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xuXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIGRvbVN0eWxlLnBhcnRzW2pdKCk7XG5cblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59O1xuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbSAoc3R5bGVzLCBvcHRpb25zKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRpZihkb21TdHlsZSkge1xuXHRcdFx0ZG9tU3R5bGUucmVmcysrO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMgKGxpc3QsIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlcyA9IFtdO1xuXHR2YXIgbmV3U3R5bGVzID0ge307XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBsaXN0W2ldO1xuXHRcdHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xuXG5cdFx0aWYoIW5ld1N0eWxlc1tpZF0pIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XG5cdFx0ZWxzZSBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG5cdH1cblxuXHRyZXR1cm4gc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQgKG9wdGlvbnMsIHN0eWxlKSB7XG5cdHZhciB0YXJnZXQgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50bylcblxuXHRpZiAoIXRhcmdldCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0SW50bycgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuXHR9XG5cblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcFtzdHlsZXNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xuXG5cdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcInRvcFwiKSB7XG5cdFx0aWYgKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgdGFyZ2V0LmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSBpZiAobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0XHR9XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlKTtcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XG5cdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0fSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zLmluc2VydEF0LmJlZm9yZSkge1xuXHRcdHZhciBuZXh0U2libGluZyA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvICsgXCIgXCIgKyBvcHRpb25zLmluc2VydEF0LmJlZm9yZSk7XG5cdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbmV4dFNpYmxpbmcpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIltTdHlsZSBMb2FkZXJdXFxuXFxuIEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnICgnb3B0aW9ucy5pbnNlcnRBdCcpIGZvdW5kLlxcbiBNdXN0IGJlICd0b3AnLCAnYm90dG9tJywgb3IgT2JqZWN0LlxcbiAoaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIjaW5zZXJ0YXQpXFxuXCIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudCAoc3R5bGUpIHtcblx0aWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblx0c3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG5cblx0dmFyIGlkeCA9IHN0eWxlc0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZSk7XG5cdGlmKGlkeCA+PSAwKSB7XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXG5cdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblxuXHRhZGRBdHRycyhzdHlsZSwgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZSk7XG5cblx0cmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMaW5rRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuXG5cdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0b3B0aW9ucy5hdHRycy5yZWwgPSBcInN0eWxlc2hlZXRcIjtcblxuXHRhZGRBdHRycyhsaW5rLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIGxpbmspO1xuXG5cdHJldHVybiBsaW5rO1xufVxuXG5mdW5jdGlvbiBhZGRBdHRycyAoZWwsIGF0dHJzKSB7XG5cdE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRlbC5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyc1trZXldKTtcblx0fSk7XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlIChvYmosIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlLCB1cGRhdGUsIHJlbW92ZSwgcmVzdWx0O1xuXG5cdC8vIElmIGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHdhcyBkZWZpbmVkLCBydW4gaXQgb24gdGhlIGNzc1xuXHRpZiAob3B0aW9ucy50cmFuc2Zvcm0gJiYgb2JqLmNzcykge1xuXHQgICAgcmVzdWx0ID0gb3B0aW9ucy50cmFuc2Zvcm0ob2JqLmNzcyk7XG5cblx0ICAgIGlmIChyZXN1bHQpIHtcblx0ICAgIFx0Ly8gSWYgdHJhbnNmb3JtIHJldHVybnMgYSB2YWx1ZSwgdXNlIHRoYXQgaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgY3NzLlxuXHQgICAgXHQvLyBUaGlzIGFsbG93cyBydW5uaW5nIHJ1bnRpbWUgdHJhbnNmb3JtYXRpb25zIG9uIHRoZSBjc3MuXG5cdCAgICBcdG9iai5jc3MgPSByZXN1bHQ7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgXHQvLyBJZiB0aGUgdHJhbnNmb3JtIGZ1bmN0aW9uIHJldHVybnMgYSBmYWxzeSB2YWx1ZSwgZG9uJ3QgYWRkIHRoaXMgY3NzLlxuXHQgICAgXHQvLyBUaGlzIGFsbG93cyBjb25kaXRpb25hbCBsb2FkaW5nIG9mIGNzc1xuXHQgICAgXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICBcdFx0Ly8gbm9vcFxuXHQgICAgXHR9O1xuXHQgICAgfVxuXHR9XG5cblx0aWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG5cdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG5cblx0XHRzdHlsZSA9IHNpbmdsZXRvbiB8fCAoc2luZ2xldG9uID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcblxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgZmFsc2UpO1xuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgdHJ1ZSk7XG5cblx0fSBlbHNlIGlmIChcblx0XHRvYmouc291cmNlTWFwICYmXG5cdFx0dHlwZW9mIFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5jcmVhdGVPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgQmxvYiA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIlxuXHQpIHtcblx0XHRzdHlsZSA9IGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IHVwZGF0ZUxpbmsuYmluZChudWxsLCBzdHlsZSwgb3B0aW9ucyk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcblxuXHRcdFx0aWYoc3R5bGUuaHJlZikgVVJMLnJldm9rZU9iamVjdFVSTChzdHlsZS5ocmVmKTtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdHN0eWxlID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZSk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcblx0XHR9O1xuXHR9XG5cblx0dXBkYXRlKG9iaik7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChuZXdPYmopIHtcblx0XHRpZiAobmV3T2JqKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdG5ld09iai5jc3MgPT09IG9iai5jc3MgJiZcblx0XHRcdFx0bmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiZcblx0XHRcdFx0bmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcFxuXHRcdFx0KSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dXBkYXRlKG9iaiA9IG5ld09iaik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlbW92ZSgpO1xuXHRcdH1cblx0fTtcbn1cblxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcblx0dmFyIHRleHRTdG9yZSA9IFtdO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG5cdFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuXG5cdFx0cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG5cdH07XG59KSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnIChzdHlsZSwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG5cdHZhciBjc3MgPSByZW1vdmUgPyBcIlwiIDogb2JqLmNzcztcblxuXHRpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuXHRcdHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuXHR9IGVsc2Uge1xuXHRcdHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcblx0XHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG5cblx0XHRpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcblxuXHRcdGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuXHRcdFx0c3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3R5bGUuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcgKHN0eWxlLCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcblxuXHRpZihtZWRpYSkge1xuXHRcdHN0eWxlLnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIG1lZGlhKVxuXHR9XG5cblx0aWYoc3R5bGUuc3R5bGVTaGVldCkge1xuXHRcdHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcblx0fSBlbHNlIHtcblx0XHR3aGlsZShzdHlsZS5maXJzdENoaWxkKSB7XG5cdFx0XHRzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcblx0XHR9XG5cblx0XHRzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcblx0fVxufVxuXG5mdW5jdGlvbiB1cGRhdGVMaW5rIChsaW5rLCBvcHRpb25zLCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuXG5cdC8qXG5cdFx0SWYgY29udmVydFRvQWJzb2x1dGVVcmxzIGlzbid0IGRlZmluZWQsIGJ1dCBzb3VyY2VtYXBzIGFyZSBlbmFibGVkXG5cdFx0YW5kIHRoZXJlIGlzIG5vIHB1YmxpY1BhdGggZGVmaW5lZCB0aGVuIGxldHMgdHVybiBjb252ZXJ0VG9BYnNvbHV0ZVVybHNcblx0XHRvbiBieSBkZWZhdWx0LiAgT3RoZXJ3aXNlIGRlZmF1bHQgdG8gdGhlIGNvbnZlcnRUb0Fic29sdXRlVXJscyBvcHRpb25cblx0XHRkaXJlY3RseVxuXHQqL1xuXHR2YXIgYXV0b0ZpeFVybHMgPSBvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyA9PT0gdW5kZWZpbmVkICYmIHNvdXJjZU1hcDtcblxuXHRpZiAob3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgfHwgYXV0b0ZpeFVybHMpIHtcblx0XHRjc3MgPSBmaXhVcmxzKGNzcyk7XG5cdH1cblxuXHRpZiAoc291cmNlTWFwKSB7XG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcblx0XHRjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArIFwiICovXCI7XG5cdH1cblxuXHR2YXIgYmxvYiA9IG5ldyBCbG9iKFtjc3NdLCB7IHR5cGU6IFwidGV4dC9jc3NcIiB9KTtcblxuXHR2YXIgb2xkU3JjID0gbGluay5ocmVmO1xuXG5cdGxpbmsuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG5cblx0aWYob2xkU3JjKSBVUkwucmV2b2tlT2JqZWN0VVJMKG9sZFNyYyk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbi8qKlxuICogV2hlbiBzb3VyY2UgbWFwcyBhcmUgZW5hYmxlZCwgYHN0eWxlLWxvYWRlcmAgdXNlcyBhIGxpbmsgZWxlbWVudCB3aXRoIGEgZGF0YS11cmkgdG9cbiAqIGVtYmVkIHRoZSBjc3Mgb24gdGhlIHBhZ2UuIFRoaXMgYnJlYWtzIGFsbCByZWxhdGl2ZSB1cmxzIGJlY2F1c2Ugbm93IHRoZXkgYXJlIHJlbGF0aXZlIHRvIGFcbiAqIGJ1bmRsZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IHBhZ2UuXG4gKlxuICogT25lIHNvbHV0aW9uIGlzIHRvIG9ubHkgdXNlIGZ1bGwgdXJscywgYnV0IHRoYXQgbWF5IGJlIGltcG9zc2libGUuXG4gKlxuICogSW5zdGVhZCwgdGhpcyBmdW5jdGlvbiBcImZpeGVzXCIgdGhlIHJlbGF0aXZlIHVybHMgdG8gYmUgYWJzb2x1dGUgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhZ2UgbG9jYXRpb24uXG4gKlxuICogQSBydWRpbWVudGFyeSB0ZXN0IHN1aXRlIGlzIGxvY2F0ZWQgYXQgYHRlc3QvZml4VXJscy5qc2AgYW5kIGNhbiBiZSBydW4gdmlhIHRoZSBgbnBtIHRlc3RgIGNvbW1hbmQuXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzcykge1xuICAvLyBnZXQgY3VycmVudCBsb2NhdGlvblxuICB2YXIgbG9jYXRpb24gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhdGlvbjtcblxuICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZml4VXJscyByZXF1aXJlcyB3aW5kb3cubG9jYXRpb25cIik7XG4gIH1cblxuXHQvLyBibGFuayBvciBudWxsP1xuXHRpZiAoIWNzcyB8fCB0eXBlb2YgY3NzICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHZhciBiYXNlVXJsID0gbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyBsb2NhdGlvbi5ob3N0O1xuICB2YXIgY3VycmVudERpciA9IGJhc2VVcmwgKyBsb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sIFwiL1wiKTtcblxuXHQvLyBjb252ZXJ0IGVhY2ggdXJsKC4uLilcblx0Lypcblx0VGhpcyByZWd1bGFyIGV4cHJlc3Npb24gaXMganVzdCBhIHdheSB0byByZWN1cnNpdmVseSBtYXRjaCBicmFja2V0cyB3aXRoaW5cblx0YSBzdHJpbmcuXG5cblx0IC91cmxcXHMqXFwoICA9IE1hdGNoIG9uIHRoZSB3b3JkIFwidXJsXCIgd2l0aCBhbnkgd2hpdGVzcGFjZSBhZnRlciBpdCBhbmQgdGhlbiBhIHBhcmVuc1xuXHQgICAoICA9IFN0YXJ0IGEgY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgKD86ICA9IFN0YXJ0IGEgbm9uLWNhcHR1cmluZyBncm91cFxuXHQgICAgICAgICBbXikoXSAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKD86ICA9IFN0YXJ0IGFub3RoZXIgbm9uLWNhcHR1cmluZyBncm91cHNcblx0ICAgICAgICAgICAgICAgICBbXikoXSsgID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgICAgIFteKShdKiAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICBcXCkgID0gTWF0Y2ggYSBlbmQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICkgID0gRW5kIEdyb3VwXG4gICAgICAgICAgICAgICpcXCkgPSBNYXRjaCBhbnl0aGluZyBhbmQgdGhlbiBhIGNsb3NlIHBhcmVuc1xuICAgICAgICAgICkgID0gQ2xvc2Ugbm9uLWNhcHR1cmluZyBncm91cFxuICAgICAgICAgICogID0gTWF0Y2ggYW55dGhpbmdcbiAgICAgICApICA9IENsb3NlIGNhcHR1cmluZyBncm91cFxuXHQgXFwpICA9IE1hdGNoIGEgY2xvc2UgcGFyZW5zXG5cblx0IC9naSAgPSBHZXQgYWxsIG1hdGNoZXMsIG5vdCB0aGUgZmlyc3QuICBCZSBjYXNlIGluc2Vuc2l0aXZlLlxuXHQgKi9cblx0dmFyIGZpeGVkQ3NzID0gY3NzLnJlcGxhY2UoL3VybFxccypcXCgoKD86W14pKF18XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSopXFwpL2dpLCBmdW5jdGlvbihmdWxsTWF0Y2gsIG9yaWdVcmwpIHtcblx0XHQvLyBzdHJpcCBxdW90ZXMgKGlmIHRoZXkgZXhpc3QpXG5cdFx0dmFyIHVucXVvdGVkT3JpZ1VybCA9IG9yaWdVcmxcblx0XHRcdC50cmltKClcblx0XHRcdC5yZXBsYWNlKC9eXCIoLiopXCIkLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pXG5cdFx0XHQucmVwbGFjZSgvXicoLiopJyQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSk7XG5cblx0XHQvLyBhbHJlYWR5IGEgZnVsbCB1cmw/IG5vIGNoYW5nZVxuXHRcdGlmICgvXigjfGRhdGE6fGh0dHA6XFwvXFwvfGh0dHBzOlxcL1xcL3xmaWxlOlxcL1xcL1xcLykvaS50ZXN0KHVucXVvdGVkT3JpZ1VybCkpIHtcblx0XHQgIHJldHVybiBmdWxsTWF0Y2g7XG5cdFx0fVxuXG5cdFx0Ly8gY29udmVydCB0aGUgdXJsIHRvIGEgZnVsbCB1cmxcblx0XHR2YXIgbmV3VXJsO1xuXG5cdFx0aWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiLy9cIikgPT09IDApIHtcblx0XHQgIFx0Ly9UT0RPOiBzaG91bGQgd2UgYWRkIHByb3RvY29sP1xuXHRcdFx0bmV3VXJsID0gdW5xdW90ZWRPcmlnVXJsO1xuXHRcdH0gZWxzZSBpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvXCIpID09PSAwKSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYmFzZSB1cmxcblx0XHRcdG5ld1VybCA9IGJhc2VVcmwgKyB1bnF1b3RlZE9yaWdVcmw7IC8vIGFscmVhZHkgc3RhcnRzIHdpdGggJy8nXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIGN1cnJlbnQgZGlyZWN0b3J5XG5cdFx0XHRuZXdVcmwgPSBjdXJyZW50RGlyICsgdW5xdW90ZWRPcmlnVXJsLnJlcGxhY2UoL15cXC5cXC8vLCBcIlwiKTsgLy8gU3RyaXAgbGVhZGluZyAnLi8nXG5cdFx0fVxuXG5cdFx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCB1cmwoLi4uKVxuXHRcdHJldHVybiBcInVybChcIiArIEpTT04uc3RyaW5naWZ5KG5ld1VybCkgKyBcIilcIjtcblx0fSk7XG5cblx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCBjc3Ncblx0cmV0dXJuIGZpeGVkQ3NzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvdXJscy5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyAkRUxNIH0gZnJvbSAnLi4vdXRpbC9tYWluJztcclxuaW1wb3J0ICcuL2NvdXBvbnMtc3R5bGUuY3NzJztcclxuXHJcbmNvbnN0IGNvdXBvbnMgPSB7XHJcbiAgcHJpbnRCYW5uZXIoY29udGVudCwge1xyXG4gICAgdGl0bGUsXHJcbiAgICBkaXNjb3VudCxcclxuICAgIHByZWFtYmxlLFxyXG4gICAgdXJsLFxyXG4gICAgaW1nLFxyXG4gICAgaXNVc2VkLFxyXG4gICAgaWQsXHJcbiAgICBkYXRhLFxyXG4gIH0pIHtcclxuICAgIGNvbnN0IGlzVXNlZENsYXNzID0gaXNVc2VkID8gJyBpcy11c2VkJyA6ICcnO1xyXG4gICAgY29uc3QgW1xyXG4gICAgICBiYW5uZXJFbGVtZW50LFxyXG4gICAgICBiYW5uZXJSb3csXHJcbiAgICAgIGJhbm5lckNvbHVtbjEsXHJcbiAgICAgIGJhbm5lckNvbHVtbjIsXHJcbiAgICAgIGJhbm5lckNvbHVtbjMsXHJcbiAgICAgIGltZ0VsZW1lbnQsXHJcbiAgICAgIHRpdGxlRWxlbWVudCxcclxuICAgICAgZGlzY291bnRFbGVtZW50LFxyXG4gICAgICBwcmVhbWJsZUVsZW1lbnQsXHJcbiAgICAgIGltZ0hvbGRlcixcclxuICAgICAgcmVhZE1vcmUsXHJcbiAgICAgIGRvd25Mb2FkLFxyXG4gICAgXSA9ICRFTE0uY3JlYXRlKFxyXG4gICAgICBgYmFubmVyYCxcclxuICAgICAgJ2Jhbm5lci1yb3cnLFxyXG4gICAgICAnYmFubmVyLWNvbHVtbicsXHJcbiAgICAgICdiYW5uZXItY29sdW1uIGdyb3ctb25lJyxcclxuICAgICAgJ2Jhbm5lci1jb2x1bW4nLFxyXG4gICAgICAnYmFubmVyLWNvbHVtbl9faW1hZ2UnLFxyXG4gICAgICBgaDFgLFxyXG4gICAgICBgc3BhbmAsXHJcbiAgICAgIGBwYCxcclxuICAgICAgYGltZ2AsXHJcbiAgICAgICdhJyxcclxuICAgICAgYGJ1dHRvbiAuYnV0dG9uIGRvd25sb2FkICR7aXNVc2VkQ2xhc3N9YCxcclxuICAgICk7XHJcbiAgICBjb25zdCBidXR0b25UZXh0ID0gaXNVc2VkID8gJ0t1cG9uZyBsYWRkYWQnIDogJ0xhZGRhIGt1cG9uZyc7XHJcblxyXG4gICAgaW1nSG9sZGVyLmltYWdlKGltZyk7XHJcbiAgICBpbWdFbGVtZW50LmFwcGVuZChpbWdIb2xkZXIpO1xyXG5cclxuICAgIHJlYWRNb3JlLmhyZWYoYC9rYW1wYW5qL2hzZS8ke2lkfWApLnRleHQoJ0zDpHMgbWVyJyk7XHJcbiAgICBkb3duTG9hZC5ocmVmKHVybCkudGV4dChidXR0b25UZXh0KTtcclxuXHJcbiAgICB0aXRsZUVsZW1lbnQuaHRtbCh0aXRsZSk7XHJcbiAgICBkaXNjb3VudEVsZW1lbnQuaHRtbChkaXNjb3VudCk7XHJcbiAgICBwcmVhbWJsZUVsZW1lbnQuaHRtbChwcmVhbWJsZSk7XHJcblxyXG4gICAgYmFubmVyQ29sdW1uMS5hcHBlbmQoaW1nRWxlbWVudCk7XHJcbiAgICBiYW5uZXJDb2x1bW4yLmFwcGVuZEFsbCh0aXRsZUVsZW1lbnQsIGRpc2NvdW50RWxlbWVudCwgcHJlYW1ibGVFbGVtZW50LCByZWFkTW9yZSk7XHJcbiAgICBiYW5uZXJDb2x1bW4zLmFwcGVuZChkb3duTG9hZCk7XHJcblxyXG4gICAgYmFubmVyUm93LmFwcGVuZEFsbChiYW5uZXJDb2x1bW4xLCBiYW5uZXJDb2x1bW4yLCBiYW5uZXJDb2x1bW4zKTtcclxuICAgIGJhbm5lckVsZW1lbnQuYXBwZW5kKGJhbm5lclJvdyk7XHJcbiAgICBjb250ZW50LmFwcGVuZChiYW5uZXJFbGVtZW50KTtcclxuXHJcbiAgICBkb3duTG9hZC5jbGljayhldmVudCA9PiB0aGlzLm9uQ2xpY2soZXZlbnQsIGRhdGEpKTtcclxuICAgICRFTE0uc2F2ZShpZCwgYmFubmVyRWxlbWVudCk7XHJcblxyXG4gICAgaWNhZGF0YWxheWVyLmFkZCgnSFNFJywge1xyXG4gICAgICBIU0U6IHtcclxuICAgICAgICBhY3Rpb246ICdkaXNwbGF5JyxcclxuICAgICAgICB0aXRsZTogZGF0YS5QYWdlTmFtZSxcclxuICAgICAgICBoc2V1cmw6IGAva2FtcGFuai9oc2UvJHtkYXRhLkNhbXBhaWduSWR9YCxcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG4gIH0sXHJcbiAgYXN5bmMgbG9hZENvdXBvbk9uQ2FyZChkYXRhKSB7XHJcbiAgICBhd2FpdCB0aGlzLmxvYWQoYC9hcGkvanNvbmhzZS9DbGFpbW9mZmVyYCwge1xyXG4gICAgICBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyxcclxuICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICB9LFxyXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcclxuICAgIH0pO1xyXG4gIH0sXHJcbiAgY2hlY2tBY3Rpb25Db29raWUoKSB7XHJcbiAgICBjb25zdCBjb3Vwb24gPSB0aGlzLnN0b3JhZ2UuZ2V0KCdjb3Vwb24nKTtcclxuICAgIGlmIChjb3Vwb24gJiYgdGhpcy5pc0xvZ2dlZEluKCkpIHtcclxuICAgICAgdGhpcy5zdG9yYWdlLnJlbW92ZSgnY291cG9uJyk7XHJcbiAgICAgIHRoaXMubG9hZENvdXBvbk9uQ2FyZChjb3Vwb24pO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgZGVhY3RpdmF0ZUNvdXBvbihpZCkge1xyXG4gICAgJEVMTS5nZXQoaWQpLmdldCgnYnV0dG9uJykuY3NzKCdpcy11c2VkJyk7XHJcbiAgfSxcclxuICBhc3luYyBvbkNsaWNrKGV2ZW50LCBkYXRhKSB7XHJcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgaWYgKHRoaXMuaXNMb2dnZWRJbigpKSB7XHJcbiAgICAgIHRoaXMuZGVhY3RpdmF0ZUNvdXBvbihkYXRhLkNhbXBhaWduSWQpO1xyXG4gICAgICBhd2FpdCB0aGlzLmxvYWRDb3Vwb25PbkNhcmQoZGF0YSk7XHJcbiAgICAgIGljYWRhdGFsYXllci5hZGQoJ0hTRScsIHtcclxuICAgICAgICBIU0U6IHtcclxuICAgICAgICAgIGFjdGlvbjogJ2NvdXBvbi1sb2FkZWQnLFxyXG4gICAgICAgICAgbmFtZTogZGF0YS5QYWdlTmFtZSxcclxuICAgICAgICAgIG9mZmVyOiBkYXRhLlByb2R1Y3ROYW1lLFxyXG4gICAgICAgICAgaHNldXJsOiBgL2thbXBhbmovaHNlLyR7ZGF0YS5DYW1wYWlnbklkfWAsXHJcbiAgICAgICAgfSxcclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpY2FkYXRhbGF5ZXIuYWRkKCdIU0UnLCB7XHJcbiAgICAgICAgSFNFOiB7XHJcbiAgICAgICAgICBhY3Rpb246ICdsb2dpbi1tb3VzZWRvd24nLFxyXG4gICAgICAgICAgbmFtZTogZGF0YS5QYWdlTmFtZSxcclxuICAgICAgICAgIGhzZXVybDogYC9rYW1wYW5qL2hzZS8ke2RhdGEuQ2FtcGFpZ25JZH1gLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0pO1xyXG4gICAgICB0aGlzLnN0b3JhZ2Uuc2V0KCdjb3Vwb24nLCBkYXRhKTtcclxuICAgICAgdGhpcy5jcmVhdGVNb2RhbCgpO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgbG9hZEJhbm5lcnMoaWRzLCBjb250ZW50KSB7XHJcbiAgICBpZHMuZm9yRWFjaCgoaWQpID0+IHtcclxuICAgICAgdGhpcy5sb2FkKGBodHRwczovL3d3dy5pY2Euc2UvYXBpL2pzb25oc2UvJHtpZH1gLCB7IGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nIH0pXHJcbiAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICAgIFBhZ2VOYW1lLFxyXG4gICAgICAgICAgICBIZWFkZXIsXHJcbiAgICAgICAgICAgIE9mZmVyLFxyXG4gICAgICAgICAgICBDYW1wYWlnbklkLFxyXG4gICAgICAgICAgICBTdG9yZUdyb3VwSWQsXHJcbiAgICAgICAgICAgIFN0b3JlSWQsXHJcbiAgICAgICAgICB9ID0gcmVzcG9uc2U7XHJcbiAgICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICAgIFByb2R1Y3ROYW1lLFxyXG4gICAgICAgICAgICBMb2FkZWRPbkNhcmQsXHJcbiAgICAgICAgICAgIE9mZmVyQ29uZGl0aW9uLFxyXG4gICAgICAgICAgICBCcmFuZCxcclxuICAgICAgICAgICAgU2l6ZU9yUXVhbnRpdHksXHJcbiAgICAgICAgICAgIE9mZmVySWQsXHJcbiAgICAgICAgICB9ID0gT2ZmZXI7XHJcblxyXG4gICAgICAgICAgY29uc3QgZGF0YSA9IHtcclxuICAgICAgICAgICAgQ2FtcGFpZ25JZCxcclxuICAgICAgICAgICAgUHJvZHVjdE5hbWUsXHJcbiAgICAgICAgICAgIENhbXBhaWduSWQsXHJcbiAgICAgICAgICAgIFBhZ2VOYW1lLFxyXG4gICAgICAgICAgICBPZmZlcklkLFxyXG4gICAgICAgICAgICBTdG9yZUlkLFxyXG4gICAgICAgICAgICBTdG9yZUdyb3VwSWQsXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgdGhpcy5wcmludEJhbm5lcihjb250ZW50LCB7XHJcbiAgICAgICAgICAgIGRhdGEsXHJcbiAgICAgICAgICAgIGlkOiBDYW1wYWlnbklkLFxyXG4gICAgICAgICAgICBpc1VzZWQ6IExvYWRlZE9uQ2FyZCxcclxuICAgICAgICAgICAgdGl0bGU6IEhlYWRlcixcclxuICAgICAgICAgICAgZGlzY291bnQ6IE9mZmVyQ29uZGl0aW9uLkNvbmRpdGlvbnNbMF0sXHJcbiAgICAgICAgICAgIHByZWFtYmxlOiBgJHtCcmFuZH0gJHtTaXplT3JRdWFudGl0eS5UZXh0fWAsXHJcbiAgICAgICAgICAgIHVybDogJycsXHJcbiAgICAgICAgICAgIGltZzogT2ZmZXIuSW1hZ2UuSW1hZ2VVcmwsXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH0sXHJcbiAgYWRkSWZyYW1lKCkge1xyXG4gICAgY29uc3QgcmV0dXJuVXJsID0gZW5jb2RlVVJJQ29tcG9uZW50KHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcclxuICAgIGNvbnN0IGlmcmFtZSA9ICRFTE0uY3JlYXRlKCdjcm8taWZyYW1lLWNvbnRhaW5lcicpO1xyXG4gICAgY29uc3QgaWZyYW1lQ29udGFpbmVyID0gYDxzcGFuIGNsYXNzPVwibG9hZGVyXCI+PC9zcGFuPjxpZnJhbWUgc3JjPVwiLy93d3cuaWNhLnNlL2xvZ2dhLWluLz9yZXR1cm51cmw9JHtyZXR1cm5Vcmx9XCIgZnJhbWVib3JkZXI9XCIwXCI+PC9pZnJhbWU+YDtcclxuICAgIGlmcmFtZS5odG1sKGlmcmFtZUNvbnRhaW5lcik7XHJcbiAgICAkRUxNLmdldCgnYm9keScpLmFwcGVuZChpZnJhbWUpO1xyXG4gIH0sXHJcbiAgbWFuaXB1bGF0ZURvbShJQ0FDUk8sIGNyZWF0ZU1vZGFsKSB7XHJcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIElDQUNSTywgeyBjcmVhdGVNb2RhbCB9KTtcclxuICAgIGNvbnN0IGNvbnRlbnQgPSAkRUxNLmdldCgnI2NvbnRlbnQnKTtcclxuICAgIGNvbnN0IHJlZ2V4cCA9IC93d3cuaWNhLnNlXFwva2FtcGFualxcL2hzZS9nO1xyXG4gICAgY29uc3QgYmFubmVycyA9IHRoaXMuZ2V0RWxlbWVudENvbnRlbnRCeVRhZ0FuZEF0dHIocmVnZXhwLCAnYScsICdocmVmJyk7XHJcbiAgICBjb25zdCBpZHMgPSBiYW5uZXJzLm1hcChiYW5uZXIgPT4gYmFubmVyLm1hdGNoKC9cXGQrJC8pWzBdKTtcclxuICAgIHRoaXMuYWRkSWZyYW1lKCk7XHJcbiAgICBjb250ZW50Lmh0bWwoJyAnKTtcclxuICAgIHRoaXMubG9hZEJhbm5lcnMoaWRzLCBjb250ZW50KTtcclxuICAgIHRoaXMuY2hlY2tBY3Rpb25Db29raWUoKTtcclxuICB9LFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY291cG9ucztcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3N0YXJ0LXBhZ2UvY291cG9ucy5qcyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2NvdXBvbnMtc3R5bGUuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2NvdXBvbnMtc3R5bGUuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2NvdXBvbnMtc3R5bGUuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9zdGFydC1wYWdlL2NvdXBvbnMtc3R5bGUuY3NzXG4vLyBtb2R1bGUgaWQgPSAxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHVuZGVmaW5lZCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuY3JvIC5ncm93LW9uZSB7IGZsZXgtZ3JvdzogMTsgfVxcclxcbi5jcm8gLmJhbm5lciB7IGRpc3BsYXk6ZmxleDsgYmFja2dyb3VuZC1jb2xvcjogI0Y4RUJGMzsgbWFyZ2luLWJvdHRvbTogMTBweDsgfVxcclxcbi5jcm8gLmJhbm5lci5pcy11c2VkIHsgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNDcsMjQ3LDI0NywxKTsgfVxcclxcbi5jcm8gLmJhbm5lci1yb3cge1xcclxcbmRpc3BsYXk6ZmxleDtcXHJcXG53aWR0aDoxMDAlO1xcclxcbmFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxuYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XFxyXFxubWFyZ2luOiAxMHB4IDE1cHg7XFxyXFxucG9zaXRpb246IHJlbGF0aXZlO1xcclxcbn1cXHJcXG4uY3JvIC5iYW5uZXItcm93OjphZnRlciB7XFxyXFxuYmFja2dyb3VuZDp1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEQ5NGJXd2dkbVZ5YzJsdmJqMGlNUzR3SWlCbGJtTnZaR2x1WnowaWRYUm1MVGdpUHo0S1BDRXRMU0JIWlc1bGNtRjBiM0k2SUVGa2IySmxJRWxzYkhWemRISmhkRzl5SURJeExqQXVNU3dnVTFaSElFVjRjRzl5ZENCUWJIVm5MVWx1SUM0Z1UxWkhJRlpsY25OcGIyNDZJRFl1TURBZ1FuVnBiR1FnTUNrZ0lDMHRQZ284YzNabklIWmxjbk5wYjI0OUlqRXVNU0lnYVdROUlreGhlV1Z5WHpFaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJZ2VHMXNibk02ZUd4cGJtczlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5MekU1T1RrdmVHeHBibXNpSUhnOUlqQndlQ0lnZVQwaU1IQjRJZ29KSUhacFpYZENiM2c5SWpBZ01DQXhNQ0F5TUNJZ2MzUjViR1U5SW1WdVlXSnNaUzFpWVdOclozSnZkVzVrT201bGR5QXdJREFnTVRBZ01qQTdJaUI0Yld3NmMzQmhZMlU5SW5CeVpYTmxjblpsSWo0S1BITjBlV3hsSUhSNWNHVTlJblJsZUhRdlkzTnpJajRLQ1M1emREQjdabWxzYkRvalJqaEZRa1l6TzMwS1BDOXpkSGxzWlQ0S1BIQmhkR2dnWTJ4aGMzTTlJbk4wTUNJZ1pEMGlUVEl1TkRrM01ESXhMRGt1T1RnNE9EQTNZekFzTkM0eE5ESXhOVEVzTXk0ek5UYzRORGtzTnk0MU1EQXdNREVzTnk0MUxEY3VOVEF3TURBeGRpMHhOUW9KUXpVdU9EVTBPRGNzTWk0ME9EZzRNRGNzTWk0ME9UY3dNakVzTlM0NE5EWTJOVFlzTWk0ME9UY3dNakVzT1M0NU9EZzRNRGQ2SWk4K0Nqd3ZjM1puUGdvPVxcXCIpIHNwYWNlO1xcclxcbmJhY2tncm91bmQtc2l6ZTogMTNweCAyNnB4O1xcclxcbmJvdHRvbTogMDtcXHJcXG5jb250ZW50OiAnJztcXHJcXG5kaXNwbGF5OiBibG9jaztcXHJcXG5oZWlnaHQ6IDEwMCU7XFxyXFxucG9zaXRpb246IGFic29sdXRlO1xcclxcbnJpZ2h0OiAwO1xcclxcbnRvcDogMDtcXHJcXG53aWR0aDogMTNweDtcXHJcXG59XFxyXFxuLmNybyAuYmFubmVyIC5iYW5uZXItY29sdW1uOmZpcnN0LWNoaWxkIHsgbWFyZ2luLWxlZnQ6IDEwcHg7IH1cXHJcXG4uY3JvIC5iYW5uZXIgLmJhbm5lci1jb2x1bW46bGFzdC1jaGlsZCB7ICBtYXJnaW4tcmlnaHQ6IDEwcHg7IH1cXHJcXG4uY3JvIC5iYW5uZXIgLmJhbm5lci1jb2x1bW4geyBwYWRkaW5nOiAxMHB4OyB9XFxyXFxuLmNybyAuYmFubmVyIC5iYW5uZXItY29sdW1uIC5kb3dubG9hZCB7XFxyXFxuICBmb250LXNpemU6IDEycHg7XFxyXFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcbiAgYmFja2dyb3VuZDogI0Y4RUJGMztcXHJcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcclxcbiAgY29sb3I6IHJnYmEoMTYwLDQxLDExMywxKTtcXHJcXG4gIGN1cnNvcjogcG9pbnRlcjtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcclxcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxyXFxuICBtYXJnaW46IDEwcHggMTBweCAxMHB4IDA7XFxyXFxuICBib3JkZXItcmFkaXVzOiA2cmVtO1xcclxcbiAgd2lkdGg6IDEwMHB4O1xcclxcbiAgbGluZS1oZWlnaHQ6IDEuNHJlbTtcXHJcXG4gIHBhZGRpbmctYm90dG9tOiAxMHB4O1xcclxcbn1cXHJcXG4uY3JvIC5iYW5uZXIgLmJhbm5lci1jb2x1bW4gLmRvd25sb2FkLmlzLXVzZWQge1xcclxcbiAgYmFja2dyb3VuZDogI0RERTlCRjtcXHJcXG4gIGNvbG9yOiAjOERCNzJDO1xcclxcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxyXFxuICB0cmFuc2l0aW9uOiB3aWR0aCAuMnMgZWFzZSwgY29sb3IgLjJzIDI1MG1zIGVhc2UsIGJhY2tncm91bmQgLjJzIGVhc2VcXHJcXG59XFxyXFxuLmNybyAuYmFubmVyIC5iYW5uZXItY29sdW1uIGgxIHsgZm9udC1zaXplOiAxLjZyZW07IHdvcmQtYnJlYWs6IGJyZWFrLWFsbDt9XFxyXFxuLmNybyAuYmFubmVyIC5iYW5uZXItY29sdW1uIHNwYW4ge1xcclxcbiAgY29sb3I6ICNFQjFGMDc7XFxyXFxuICBmb250LWZhbWlseTogaWNhcnVicmlrO1xcclxcbiAgZm9udC1zaXplOiAyLjJyZW07XFxyXFxuICBmb250LXdlaWdodDogYm9sZDtcXHJcXG59XFxyXFxuLmNybyAuYmFubmVyIC5iYW5uZXItY29sdW1uIHAge1xcclxcbiAgY29sb3I6ICM4MDgyODM7XFxyXFxuICBmb250LXNpemU6IDEuM3JlbTtcXHJcXG4gIG1hcmdpbjogMDtcXHJcXG59XFxyXFxuLypyZ2JhKDE0MSwxODMsNDQsMSkqL1xcclxcbi5jcm8gLmJhbm5lciAuYmFubmVyLWNvbHVtbiBoMS5pcy11c2VkLFxcclxcbi5jcm8gLmJhbm5lciAuYmFubmVyLWNvbHVtbiBzcGFuLmlzLXVzZWQsXFxyXFxuLmNybyAuYmFubmVyIC5iYW5uZXItY29sdW1uIHAuaXMtdXNlZCB7IGNvbG9yOiAjRDVEN0RBOyB9XFxyXFxuLmNybyAuYmFubmVyIC5iYW5uZXItY29sdW1uIC5iYW5uZXItY29sdW1uX19tb3JlLWluZm8geyBmb250LXNpemU6IDIwcHg7IH1cXHJcXG4uY3JvIC5iYW5uZXItY29sdW1uX19pbWFnZSB7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXHJcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcclxcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcclxcbiAgd2lkdGg6IDE1MHB4O1xcclxcbiAgaGVpZ2h0OiAxNTBweDtcXHJcXG59XFxyXFxuLmNybyAuYmFubmVyLWNvbHVtbl9faW1hZ2UgaW1nIHtcXHJcXG4gIG1heC13aWR0aDogMTAwJTtcXHJcXG4gIG1heC1oZWlnaHQ6IDEwMCU7XFxyXFxuICB3aWR0aDogYXV0bztcXHJcXG4gIGhlaWdodDogYXV0bztcXHJcXG59XFxyXFxuLmNybyAuYmFubmVyLWNvbHVtbl9faW1hZ2UgaW1nLmlzLXVzZWQge1xcclxcbiAgb3BhY2l0eTogLjM7XFxyXFxufVxcclxcbkBtZWRpYSBvbmx5IHNjcmVlbiBhbmQgKG1heC13aWR0aDogNzgwcHgpe1xcclxcbiAgLmNybyAuYmFubmVyLWNvbHVtbl9faW1hZ2Uge1xcclxcbiAgICB3aWR0aDogNjVweDtcXHJcXG4gICAgaGVpZ2h0OiA2NXB4O1xcclxcbiAgfVxcclxcbiAgI3BhZ2Uge1xcclxcbiAgICBwYWRkaW5nOiAwIDVweCA1cHg7XFxyXFxuICB9XFxyXFxuICAuY3JvIC5iYW5uZXIgLmJhbm5lci1jb2x1bW46Zmlyc3QtY2hpbGQgeyBwYWRkaW5nOiAxMHB4OyBtYXJnaW4tbGVmdDogMDsgfVxcclxcbiAgLmNybyAuYmFubmVyIC5iYW5uZXItY29sdW1uOmxhc3QtY2hpbGQgeyBwYWRkaW5nOiAxMHB4IDEwcHggMTBweCAwOyBtYXJnaW4tcmlnaHQ6IDA7IH1cXHJcXG4gIC5jcm8gLmJhbm5lciAuYmFubmVyLWNvbHVtbiB7IHBhZGRpbmc6IDEwcHggMDsgfVxcclxcbn1cXHJcXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyIS4vc3JjL3N0YXJ0LXBhZ2UvY291cG9ucy1zdHlsZS5jc3Ncbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7IHZlcnNpb246ICcyLjUuMScgfTtcbmlmICh0eXBlb2YgX19lID09ICdudW1iZXInKSBfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29yZS5qc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHN0b3JlID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ3drcycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlN5bWJvbDtcbnZhciBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xuXG52YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuaWYgKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpIF9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbiAodHlwZSwgbmFtZSwgc291cmNlKSB7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GO1xuICB2YXIgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuRztcbiAgdmFyIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlM7XG4gIHZhciBJU19QUk9UTyA9IHR5cGUgJiAkZXhwb3J0LlA7XG4gIHZhciBJU19CSU5EID0gdHlwZSAmICRleHBvcnQuQjtcbiAgdmFyIElTX1dSQVAgPSB0eXBlICYgJGV4cG9ydC5XO1xuICB2YXIgZXhwb3J0cyA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pO1xuICB2YXIgZXhwUHJvdG8gPSBleHBvcnRzW1BST1RPVFlQRV07XG4gIHZhciB0YXJnZXQgPSBJU19HTE9CQUwgPyBnbG9iYWwgOiBJU19TVEFUSUMgPyBnbG9iYWxbbmFtZV0gOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdO1xuICB2YXIga2V5LCBvd24sIG91dDtcbiAgaWYgKElTX0dMT0JBTCkgc291cmNlID0gbmFtZTtcbiAgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICBpZiAob3duICYmIGtleSBpbiBleHBvcnRzKSBjb250aW51ZTtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IG93biA/IHRhcmdldFtrZXldIDogc291cmNlW2tleV07XG4gICAgLy8gcHJldmVudCBnbG9iYWwgcG9sbHV0aW9uIGZvciBuYW1lc3BhY2VzXG4gICAgZXhwb3J0c1trZXldID0gSVNfR0xPQkFMICYmIHR5cGVvZiB0YXJnZXRba2V5XSAhPSAnZnVuY3Rpb24nID8gc291cmNlW2tleV1cbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIDogSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpXG4gICAgLy8gd3JhcCBnbG9iYWwgY29uc3RydWN0b3JzIGZvciBwcmV2ZW50IGNoYW5nZSB0aGVtIGluIGxpYnJhcnlcbiAgICA6IElTX1dSQVAgJiYgdGFyZ2V0W2tleV0gPT0gb3V0ID8gKGZ1bmN0aW9uIChDKSB7XG4gICAgICB2YXIgRiA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgQykge1xuICAgICAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IEMoKTtcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBDKGEpO1xuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IEMoYSwgYik7XG4gICAgICAgICAgfSByZXR1cm4gbmV3IEMoYSwgYiwgYyk7XG4gICAgICAgIH0gcmV0dXJuIEMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgICBGW1BST1RPVFlQRV0gPSBDW1BST1RPVFlQRV07XG4gICAgICByZXR1cm4gRjtcbiAgICAvLyBtYWtlIHN0YXRpYyB2ZXJzaW9ucyBmb3IgcHJvdG90eXBlIG1ldGhvZHNcbiAgICB9KShvdXQpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLm1ldGhvZHMuJU5BTUUlXG4gICAgaWYgKElTX1BST1RPKSB7XG4gICAgICAoZXhwb3J0cy52aXJ0dWFsIHx8IChleHBvcnRzLnZpcnR1YWwgPSB7fSkpW2tleV0gPSBvdXQ7XG4gICAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUucHJvdG90eXBlLiVOQU1FJVxuICAgICAgaWYgKHR5cGUgJiAkZXhwb3J0LlIgJiYgZXhwUHJvdG8gJiYgIWV4cFByb3RvW2tleV0pIGhpZGUoZXhwUHJvdG8sIGtleSwgb3V0KTtcbiAgICB9XG4gIH1cbn07XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG4kZXhwb3J0LlMgPSA0OyAgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgIC8vIHdyYXBcbiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4tb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGlkZS5qc1xuLy8gbW9kdWxlIGlkID0gMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgZFAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHAuanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLW9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanNcbi8vIG1vZHVsZSBpZCA9IDIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge307XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlcmF0b3JzLmpzXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzXG4vLyBtb2R1bGUgaWQgPSAyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgJGF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbi8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24gKGl0ZXJhdGVkKSB7XG4gIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIE8gPSB0aGlzLl90O1xuICB2YXIgaW5kZXggPSB0aGlzLl9pO1xuICB2YXIgcG9pbnQ7XG4gIGlmIChpbmRleCA+PSBPLmxlbmd0aCkgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICBwb2ludCA9ICRhdChPLCBpbmRleCk7XG4gIHRoaXMuX2kgKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4geyB2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlIH07XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICh0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29mLmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1vYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWludGVnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVmaW5lZC5qc1xuLy8gbW9kdWxlIGlkID0gMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYml0bWFwLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGU6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzXG4vLyBtb2R1bGUgaWQgPSAzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSAzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWlvYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMS4xNSBUb0xlbmd0aFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWxlbmd0aC5qc1xuLy8gbW9kdWxlIGlkID0gMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdrZXlzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLWtleS5qc1xuLy8gbW9kdWxlIGlkID0gMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGRlZiA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCB0YWcsIHN0YXQpIHtcbiAgaWYgKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpIGRlZihpdCwgVEFHLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZyB9KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanNcbi8vIG1vZHVsZSBpZCA9IDM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciBUT19TVFJJTkdfVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbnZhciBET01JdGVyYWJsZXMgPSAoJ0NTU1J1bGVMaXN0LENTU1N0eWxlRGVjbGFyYXRpb24sQ1NTVmFsdWVMaXN0LENsaWVudFJlY3RMaXN0LERPTVJlY3RMaXN0LERPTVN0cmluZ0xpc3QsJyArXG4gICdET01Ub2tlbkxpc3QsRGF0YVRyYW5zZmVySXRlbUxpc3QsRmlsZUxpc3QsSFRNTEFsbENvbGxlY3Rpb24sSFRNTENvbGxlY3Rpb24sSFRNTEZvcm1FbGVtZW50LEhUTUxTZWxlY3RFbGVtZW50LCcgK1xuICAnTWVkaWFMaXN0LE1pbWVUeXBlQXJyYXksTmFtZWROb2RlTWFwLE5vZGVMaXN0LFBhaW50UmVxdWVzdExpc3QsUGx1Z2luLFBsdWdpbkFycmF5LFNWR0xlbmd0aExpc3QsU1ZHTnVtYmVyTGlzdCwnICtcbiAgJ1NWR1BhdGhTZWdMaXN0LFNWR1BvaW50TGlzdCxTVkdTdHJpbmdMaXN0LFNWR1RyYW5zZm9ybUxpc3QsU291cmNlQnVmZmVyTGlzdCxTdHlsZVNoZWV0TGlzdCxUZXh0VHJhY2tDdWVMaXN0LCcgK1xuICAnVGV4dFRyYWNrTGlzdCxUb3VjaExpc3QnKS5zcGxpdCgnLCcpO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IERPTUl0ZXJhYmxlcy5sZW5ndGg7IGkrKykge1xuICB2YXIgTkFNRSA9IERPTUl0ZXJhYmxlc1tpXTtcbiAgdmFyIENvbGxlY3Rpb24gPSBnbG9iYWxbTkFNRV07XG4gIHZhciBwcm90byA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIGlmIChwcm90byAmJiAhcHJvdG9bVE9fU1RSSU5HX1RBR10pIGhpZGUocHJvdG8sIFRPX1NUUklOR19UQUcsIE5BTUUpO1xuICBJdGVyYXRvcnNbTkFNRV0gPSBJdGVyYXRvcnMuQXJyYXk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSA0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xudmFyIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuLy8gRVMzIHdyb25nIGhlcmVcbnZhciBBUkcgPSBjb2YoZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8sIFQsIEI7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mIChUID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUQUcpKSA9PSAnc3RyaW5nJyA/IFRcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IEFSRyA/IGNvZihPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChCID0gY29mKE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogQjtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY2xhc3NvZi5qc1xuLy8gbW9kdWxlIGlkID0gNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmdldEl0ZXJhdG9yTWV0aG9kID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCAhPSB1bmRlZmluZWQpIHJldHVybiBpdFtJVEVSQVRPUl1cbiAgICB8fCBpdFsnQEBpdGVyYXRvciddXG4gICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanNcbi8vIG1vZHVsZSBpZCA9IDQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIDI1LjQuMS41IE5ld1Byb21pc2VDYXBhYmlsaXR5KEMpXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xuXG5mdW5jdGlvbiBQcm9taXNlQ2FwYWJpbGl0eShDKSB7XG4gIHZhciByZXNvbHZlLCByZWplY3Q7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBDKGZ1bmN0aW9uICgkJHJlc29sdmUsICQkcmVqZWN0KSB7XG4gICAgaWYgKHJlc29sdmUgIT09IHVuZGVmaW5lZCB8fCByZWplY3QgIT09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKCdCYWQgUHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgIHJlc29sdmUgPSAkJHJlc29sdmU7XG4gICAgcmVqZWN0ID0gJCRyZWplY3Q7XG4gIH0pO1xuICB0aGlzLnJlc29sdmUgPSBhRnVuY3Rpb24ocmVzb2x2ZSk7XG4gIHRoaXMucmVqZWN0ID0gYUZ1bmN0aW9uKHJlamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiAoQykge1xuICByZXR1cm4gbmV3IFByb21pc2VDYXBhYmlsaXR5KEMpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5LmpzXG4vLyBtb2R1bGUgaWQgPSA0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vcHJvbWlzZVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9wcm9taXNlLmpzXG4vLyBtb2R1bGUgaWQgPSA0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgJGl0ZXJDcmVhdGUgPSByZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEJVR0dZID0gIShbXS5rZXlzICYmICduZXh0JyBpbiBbXS5rZXlzKCkpOyAvLyBTYWZhcmkgaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXG52YXIgRkZfSVRFUkFUT1IgPSAnQEBpdGVyYXRvcic7XG52YXIgS0VZUyA9ICdrZXlzJztcbnZhciBWQUxVRVMgPSAndmFsdWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChCYXNlLCBOQU1FLCBDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpIHtcbiAgJGl0ZXJDcmVhdGUoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuICB2YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24gKGtpbmQpIHtcbiAgICBpZiAoIUJVR0dZICYmIGtpbmQgaW4gcHJvdG8pIHJldHVybiBwcm90b1traW5kXTtcbiAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICB9O1xuICB2YXIgVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICB2YXIgREVGX1ZBTFVFUyA9IERFRkFVTFQgPT0gVkFMVUVTO1xuICB2YXIgVkFMVUVTX0JVRyA9IGZhbHNlO1xuICB2YXIgcHJvdG8gPSBCYXNlLnByb3RvdHlwZTtcbiAgdmFyICRuYXRpdmUgPSBwcm90b1tJVEVSQVRPUl0gfHwgcHJvdG9bRkZfSVRFUkFUT1JdIHx8IERFRkFVTFQgJiYgcHJvdG9bREVGQVVMVF07XG4gIHZhciAkZGVmYXVsdCA9ICRuYXRpdmUgfHwgZ2V0TWV0aG9kKERFRkFVTFQpO1xuICB2YXIgJGVudHJpZXMgPSBERUZBVUxUID8gIURFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZCgnZW50cmllcycpIDogdW5kZWZpbmVkO1xuICB2YXIgJGFueU5hdGl2ZSA9IE5BTUUgPT0gJ0FycmF5JyA/IHByb3RvLmVudHJpZXMgfHwgJG5hdGl2ZSA6ICRuYXRpdmU7XG4gIHZhciBtZXRob2RzLCBrZXksIEl0ZXJhdG9yUHJvdG90eXBlO1xuICAvLyBGaXggbmF0aXZlXG4gIGlmICgkYW55TmF0aXZlKSB7XG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZigkYW55TmF0aXZlLmNhbGwobmV3IEJhc2UoKSkpO1xuICAgIGlmIChJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJiBJdGVyYXRvclByb3RvdHlwZS5uZXh0KSB7XG4gICAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXG4gICAgICBzZXRUb1N0cmluZ1RhZyhJdGVyYXRvclByb3RvdHlwZSwgVEFHLCB0cnVlKTtcbiAgICAgIC8vIGZpeCBmb3Igc29tZSBvbGQgZW5naW5lc1xuICAgICAgaWYgKCFMSUJSQVJZICYmICFoYXMoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SKSkgaGlkZShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuICAgIH1cbiAgfVxuICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmIChERUZfVkFMVUVTICYmICRuYXRpdmUgJiYgJG5hdGl2ZS5uYW1lICE9PSBWQUxVRVMpIHtcbiAgICBWQUxVRVNfQlVHID0gdHJ1ZTtcbiAgICAkZGVmYXVsdCA9IGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuICRuYXRpdmUuY2FsbCh0aGlzKTsgfTtcbiAgfVxuICAvLyBEZWZpbmUgaXRlcmF0b3JcbiAgaWYgKCghTElCUkFSWSB8fCBGT1JDRUQpICYmIChCVUdHWSB8fCBWQUxVRVNfQlVHIHx8ICFwcm90b1tJVEVSQVRPUl0pKSB7XG4gICAgaGlkZShwcm90bywgSVRFUkFUT1IsICRkZWZhdWx0KTtcbiAgfVxuICAvLyBQbHVnIGZvciBsaWJyYXJ5XG4gIEl0ZXJhdG9yc1tOQU1FXSA9ICRkZWZhdWx0O1xuICBJdGVyYXRvcnNbVEFHXSA9IHJldHVyblRoaXM7XG4gIGlmIChERUZBVUxUKSB7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKFZBTFVFUyksXG4gICAgICBrZXlzOiBJU19TRVQgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6ICRlbnRyaWVzXG4gICAgfTtcbiAgICBpZiAoRk9SQ0VEKSBmb3IgKGtleSBpbiBtZXRob2RzKSB7XG4gICAgICBpZiAoIShrZXkgaW4gcHJvdG8pKSByZWRlZmluZShwcm90bywga2V5LCBtZXRob2RzW2tleV0pO1xuICAgIH0gZWxzZSAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChCVUdHWSB8fCBWQUxVRVNfQlVHKSwgTkFNRSwgbWV0aG9kcyk7XG4gIH1cbiAgcmV0dXJuIG1ldGhvZHM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSA0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHRydWU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbGlicmFyeS5qc1xuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG52YXIgc3RvcmUgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB7fSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC5qc1xuLy8gbW9kdWxlIGlkID0gNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlkID0gMDtcbnZhciBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdWlkLmpzXG4vLyBtb2R1bGUgaWQgPSA0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSA1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbm1vZHVsZS5leHBvcnRzID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2h0bWwuanNcbi8vIG1vZHVsZSBpZCA9IDUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3JcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIGZuLCB2YWx1ZSwgZW50cmllcykge1xuICB0cnkge1xuICAgIHJldHVybiBlbnRyaWVzID8gZm4oYW5PYmplY3QodmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7XG4gIC8vIDcuNC42IEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIGNvbXBsZXRpb24pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIgcmV0ID0gaXRlcmF0b3JbJ3JldHVybiddO1xuICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCkgYW5PYmplY3QocmV0LmNhbGwoaXRlcmF0b3IpKTtcbiAgICB0aHJvdyBlO1xuICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY2FsbC5qc1xuLy8gbW9kdWxlIGlkID0gNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gY2hlY2sgb24gZGVmYXVsdCBBcnJheSBpdGVyYXRvclxudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKEl0ZXJhdG9ycy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b1tJVEVSQVRPUl0gPT09IGl0KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtYXJyYXktaXRlci5qc1xuLy8gbW9kdWxlIGlkID0gNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gNy4zLjIwIFNwZWNpZXNDb25zdHJ1Y3RvcihPLCBkZWZhdWx0Q29uc3RydWN0b3IpXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgU1BFQ0lFUyA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBEKSB7XG4gIHZhciBDID0gYW5PYmplY3QoTykuY29uc3RydWN0b3I7XG4gIHZhciBTO1xuICByZXR1cm4gQyA9PT0gdW5kZWZpbmVkIHx8IChTID0gYW5PYmplY3QoQylbU1BFQ0lFU10pID09IHVuZGVmaW5lZCA/IEQgOiBhRnVuY3Rpb24oUyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NwZWNpZXMtY29uc3RydWN0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBpbnZva2UgPSByZXF1aXJlKCcuL19pbnZva2UnKTtcbnZhciBodG1sID0gcmVxdWlyZSgnLi9faHRtbCcpO1xudmFyIGNlbCA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgc2V0VGFzayA9IGdsb2JhbC5zZXRJbW1lZGlhdGU7XG52YXIgY2xlYXJUYXNrID0gZ2xvYmFsLmNsZWFySW1tZWRpYXRlO1xudmFyIE1lc3NhZ2VDaGFubmVsID0gZ2xvYmFsLk1lc3NhZ2VDaGFubmVsO1xudmFyIERpc3BhdGNoID0gZ2xvYmFsLkRpc3BhdGNoO1xudmFyIGNvdW50ZXIgPSAwO1xudmFyIHF1ZXVlID0ge307XG52YXIgT05SRUFEWVNUQVRFQ0hBTkdFID0gJ29ucmVhZHlzdGF0ZWNoYW5nZSc7XG52YXIgZGVmZXIsIGNoYW5uZWwsIHBvcnQ7XG52YXIgcnVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaWQgPSArdGhpcztcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICBpZiAocXVldWUuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgdmFyIGZuID0gcXVldWVbaWRdO1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gICAgZm4oKTtcbiAgfVxufTtcbnZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCkge1xuICBydW4uY2FsbChldmVudC5kYXRhKTtcbn07XG4vLyBOb2RlLmpzIDAuOSsgJiBJRTEwKyBoYXMgc2V0SW1tZWRpYXRlLCBvdGhlcndpc2U6XG5pZiAoIXNldFRhc2sgfHwgIWNsZWFyVGFzaykge1xuICBzZXRUYXNrID0gZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGZuKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICB2YXIgaSA9IDE7XG4gICAgd2hpbGUgKGFyZ3VtZW50cy5sZW5ndGggPiBpKSBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgIHF1ZXVlWysrY291bnRlcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgICAgIGludm9rZSh0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pLCBhcmdzKTtcbiAgICB9O1xuICAgIGRlZmVyKGNvdW50ZXIpO1xuICAgIHJldHVybiBjb3VudGVyO1xuICB9O1xuICBjbGVhclRhc2sgPSBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShpZCkge1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gIH07XG4gIC8vIE5vZGUuanMgMC44LVxuICBpZiAocmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBTcGhlcmUgKEpTIGdhbWUgZW5naW5lKSBEaXNwYXRjaCBBUElcbiAgfSBlbHNlIGlmIChEaXNwYXRjaCAmJiBEaXNwYXRjaC5ub3cpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgRGlzcGF0Y2gubm93KGN0eChydW4sIGlkLCAxKSk7XG4gICAgfTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBNZXNzYWdlQ2hhbm5lbCwgaW5jbHVkZXMgV2ViV29ya2Vyc1xuICB9IGVsc2UgaWYgKE1lc3NhZ2VDaGFubmVsKSB7XG4gICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgIHBvcnQgPSBjaGFubmVsLnBvcnQyO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbGlzdGVuZXI7XG4gICAgZGVmZXIgPSBjdHgocG9ydC5wb3N0TWVzc2FnZSwgcG9ydCwgMSk7XG4gIC8vIEJyb3dzZXJzIHdpdGggcG9zdE1lc3NhZ2UsIHNraXAgV2ViV29ya2Vyc1xuICAvLyBJRTggaGFzIHBvc3RNZXNzYWdlLCBidXQgaXQncyBzeW5jICYgdHlwZW9mIGl0cyBwb3N0TWVzc2FnZSBpcyAnb2JqZWN0J1xuICB9IGVsc2UgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICYmIHR5cGVvZiBwb3N0TWVzc2FnZSA9PSAnZnVuY3Rpb24nICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoaWQgKyAnJywgJyonKTtcbiAgICB9O1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIsIGZhbHNlKTtcbiAgLy8gSUU4LVxuICB9IGVsc2UgaWYgKE9OUkVBRFlTVEFURUNIQU5HRSBpbiBjZWwoJ3NjcmlwdCcpKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoY2VsKCdzY3JpcHQnKSlbT05SRUFEWVNUQVRFQ0hBTkdFXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaHRtbC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgcnVuLmNhbGwoaWQpO1xuICAgICAgfTtcbiAgICB9O1xuICAvLyBSZXN0IG9sZCBicm93c2Vyc1xuICB9IGVsc2Uge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBzZXRUaW1lb3V0KGN0eChydW4sIGlkLCAxKSwgMCk7XG4gICAgfTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogc2V0VGFzayxcbiAgY2xlYXI6IGNsZWFyVGFza1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190YXNrLmpzXG4vLyBtb2R1bGUgaWQgPSA1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHsgZTogZmFsc2UsIHY6IGV4ZWMoKSB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHsgZTogdHJ1ZSwgdjogZSB9O1xuICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3BlcmZvcm0uanNcbi8vIG1vZHVsZSBpZCA9IDU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSByZXF1aXJlKCcuL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEMsIHgpIHtcbiAgYW5PYmplY3QoQyk7XG4gIGlmIChpc09iamVjdCh4KSAmJiB4LmNvbnN0cnVjdG9yID09PSBDKSByZXR1cm4geDtcbiAgdmFyIHByb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkuZihDKTtcbiAgdmFyIHJlc29sdmUgPSBwcm9taXNlQ2FwYWJpbGl0eS5yZXNvbHZlO1xuICByZXNvbHZlKHgpO1xuICByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHkucHJvbWlzZTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvbWlzZS1yZXNvbHZlLmpzXG4vLyBtb2R1bGUgaWQgPSA1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIHJpdGVyID0gWzddW0lURVJBVE9SXSgpO1xuICByaXRlclsncmV0dXJuJ10gPSBmdW5jdGlvbiAoKSB7IFNBRkVfQ0xPU0lORyA9IHRydWU7IH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXG4gIEFycmF5LmZyb20ocml0ZXIsIGZ1bmN0aW9uICgpIHsgdGhyb3cgMjsgfSk7XG59IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYywgc2tpcENsb3NpbmcpIHtcbiAgaWYgKCFza2lwQ2xvc2luZyAmJiAhU0FGRV9DTE9TSU5HKSByZXR1cm4gZmFsc2U7XG4gIHZhciBzYWZlID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IFs3XTtcbiAgICB2YXIgaXRlciA9IGFycltJVEVSQVRPUl0oKTtcbiAgICBpdGVyLm5leHQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB7IGRvbmU6IHNhZmUgPSB0cnVlIH07IH07XG4gICAgYXJyW0lURVJBVE9SXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGl0ZXI7IH07XG4gICAgZXhlYyhhcnIpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIHNhZmU7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGV0ZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vanNvbi9zdHJpbmdpZnlcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvanNvbi9zdHJpbmdpZnkuanNcbi8vIG1vZHVsZSBpZCA9IDU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9hc3NpZ24uanNcbi8vIG1vZHVsZSBpZCA9IDYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9hcnJheS9mcm9tXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL2FycmF5L2Zyb20uanNcbi8vIG1vZHVsZSBpZCA9IDYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2lzSXRlcmFibGUyID0gcmVxdWlyZShcIi4uL2NvcmUtanMvaXMtaXRlcmFibGVcIik7XG5cbnZhciBfaXNJdGVyYWJsZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc0l0ZXJhYmxlMik7XG5cbnZhciBfZ2V0SXRlcmF0b3IyID0gcmVxdWlyZShcIi4uL2NvcmUtanMvZ2V0LWl0ZXJhdG9yXCIpO1xuXG52YXIgX2dldEl0ZXJhdG9yMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldEl0ZXJhdG9yMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHtcbiAgICB2YXIgX2FyciA9IFtdO1xuICAgIHZhciBfbiA9IHRydWU7XG4gICAgdmFyIF9kID0gZmFsc2U7XG4gICAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9pID0gKDAsIF9nZXRJdGVyYXRvcjMuZGVmYXVsdCkoYXJyKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfZCA9IHRydWU7XG4gICAgICBfZSA9IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9hcnI7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgIHJldHVybiBhcnI7XG4gICAgfSBlbHNlIGlmICgoMCwgX2lzSXRlcmFibGUzLmRlZmF1bHQpKE9iamVjdChhcnIpKSkge1xuICAgICAgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG4gICAgfVxuICB9O1xufSgpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSA2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYucHJvbWlzZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcucHJvbWlzZS5maW5hbGx5Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNy5wcm9taXNlLnRyeScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL19jb3JlJykuUHJvbWlzZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9wcm9taXNlLmpzXG4vLyBtb2R1bGUgaWQgPSA2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG4vLyB0cnVlICAtPiBTdHJpbmcjYXRcbi8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVE9fU1RSSU5HKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGhhdCwgcG9zKSB7XG4gICAgdmFyIHMgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG4gICAgdmFyIGkgPSB0b0ludGVnZXIocG9zKTtcbiAgICB2YXIgbCA9IHMubGVuZ3RoO1xuICAgIHZhciBhLCBiO1xuICAgIGlmIChpIDwgMCB8fCBpID49IGwpIHJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG4gICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYVxuICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3N0cmluZy1hdC5qc1xuLy8gbW9kdWxlIGlkID0gNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdkaXYnKSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qc1xuLy8gbW9kdWxlIGlkID0gNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFMpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qc1xuLy8gbW9kdWxlIGlkID0gNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19oaWRlJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcmVkZWZpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgZGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2hpZGUnKShJdGVyYXRvclByb3RvdHlwZSwgcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCkge1xuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHsgbmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KSB9KTtcbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGRQcyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBFbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2lmcmFtZScpO1xuICB2YXIgaSA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiAgdmFyIGx0ID0gJzwnO1xuICB2YXIgZ3QgPSAnPic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIHJlcXVpcmUoJy4vX2h0bWwnKS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZSAoaS0tKSBkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHkoKTtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBrZXlzID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaSA9IDA7XG4gIHZhciBQO1xuICB3aGlsZSAobGVuZ3RoID4gaSkgZFAuZihPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTtcbiAgcmV0dXJuIE87XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcHMuanNcbi8vIG1vZHVsZSBpZCA9IDcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgYXJyYXlJbmRleE9mID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKShmYWxzZSk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZXMpIHtcbiAgdmFyIE8gPSB0b0lPYmplY3Qob2JqZWN0KTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIE8pIGlmIChrZXkgIT0gSUVfUFJPVE8pIGhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzXG4vLyBtb2R1bGUgaWQgPSA3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBmYWxzZSAtPiBBcnJheSNpbmRleE9mXG4vLyB0cnVlICAtPiBBcnJheSNpbmNsdWRlc1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJU19JTkNMVURFUykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBlbCwgZnJvbUluZGV4KSB7XG4gICAgdmFyIE8gPSB0b0lPYmplY3QoJHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGZyb21JbmRleCwgbGVuZ3RoKTtcbiAgICB2YXIgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICBpZiAoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpIHdoaWxlIChsZW5ndGggPiBpbmRleCkge1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTykge1xuICAgICAgaWYgKE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qc1xuLy8gbW9kdWxlIGlkID0gNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgaW5kZXggPSB0b0ludGVnZXIoaW5kZXgpO1xuICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tYWJzb2x1dGUtaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBPYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIChPKSB7XG4gIE8gPSB0b09iamVjdChPKTtcbiAgaWYgKGhhcyhPLCBJRV9QUk9UTykpIHJldHVybiBPW0lFX1BST1RPXTtcbiAgaWYgKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1ncG8uanNcbi8vIG1vZHVsZSBpZCA9IDc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJyk7XG52YXIgc3RlcCA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxuLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBPID0gdGhpcy5fdDtcbiAgdmFyIGtpbmQgPSB0aGlzLl9rO1xuICB2YXIgaW5kZXggPSB0aGlzLl9pKys7XG4gIGlmICghTyB8fCBpbmRleCA+PSBPLmxlbmd0aCkge1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cbiAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FkZC10by11bnNjb3BhYmxlcy5qc1xuLy8gbW9kdWxlIGlkID0gNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZG9uZSwgdmFsdWUpIHtcbiAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmUgfTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1zdGVwLmpzXG4vLyBtb2R1bGUgaWQgPSA3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKTtcbnZhciB0YXNrID0gcmVxdWlyZSgnLi9fdGFzaycpLnNldDtcbnZhciBtaWNyb3Rhc2sgPSByZXF1aXJlKCcuL19taWNyb3Rhc2snKSgpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlID0gcmVxdWlyZSgnLi9fbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xudmFyIHBlcmZvcm0gPSByZXF1aXJlKCcuL19wZXJmb3JtJyk7XG52YXIgcHJvbWlzZVJlc29sdmUgPSByZXF1aXJlKCcuL19wcm9taXNlLXJlc29sdmUnKTtcbnZhciBQUk9NSVNFID0gJ1Byb21pc2UnO1xudmFyIFR5cGVFcnJvciA9IGdsb2JhbC5UeXBlRXJyb3I7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyICRQcm9taXNlID0gZ2xvYmFsW1BST01JU0VdO1xudmFyIGlzTm9kZSA9IGNsYXNzb2YocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xudmFyIGVtcHR5ID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xudmFyIEludGVybmFsLCBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHksIE93blByb21pc2VDYXBhYmlsaXR5LCBXcmFwcGVyO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUuZjtcblxudmFyIFVTRV9OQVRJVkUgPSAhIWZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICAvLyBjb3JyZWN0IHN1YmNsYXNzaW5nIHdpdGggQEBzcGVjaWVzIHN1cHBvcnRcbiAgICB2YXIgcHJvbWlzZSA9ICRQcm9taXNlLnJlc29sdmUoMSk7XG4gICAgdmFyIEZha2VQcm9taXNlID0gKHByb21pc2UuY29uc3RydWN0b3IgPSB7fSlbcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKV0gPSBmdW5jdGlvbiAoZXhlYykge1xuICAgICAgZXhlYyhlbXB0eSwgZW1wdHkpO1xuICAgIH07XG4gICAgLy8gdW5oYW5kbGVkIHJlamVjdGlvbnMgdHJhY2tpbmcgc3VwcG9ydCwgTm9kZUpTIFByb21pc2Ugd2l0aG91dCBpdCBmYWlscyBAQHNwZWNpZXMgdGVzdFxuICAgIHJldHVybiAoaXNOb2RlIHx8IHR5cGVvZiBQcm9taXNlUmVqZWN0aW9uRXZlbnQgPT0gJ2Z1bmN0aW9uJykgJiYgcHJvbWlzZS50aGVuKGVtcHR5KSBpbnN0YW5jZW9mIEZha2VQcm9taXNlO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbn0oKTtcblxuLy8gaGVscGVyc1xudmFyIGlzVGhlbmFibGUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHRoZW47XG4gIHJldHVybiBpc09iamVjdChpdCkgJiYgdHlwZW9mICh0aGVuID0gaXQudGhlbikgPT0gJ2Z1bmN0aW9uJyA/IHRoZW4gOiBmYWxzZTtcbn07XG52YXIgbm90aWZ5ID0gZnVuY3Rpb24gKHByb21pc2UsIGlzUmVqZWN0KSB7XG4gIGlmIChwcm9taXNlLl9uKSByZXR1cm47XG4gIHByb21pc2UuX24gPSB0cnVlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9jO1xuICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3Y7XG4gICAgdmFyIG9rID0gcHJvbWlzZS5fcyA9PSAxO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgcnVuID0gZnVuY3Rpb24gKHJlYWN0aW9uKSB7XG4gICAgICB2YXIgaGFuZGxlciA9IG9rID8gcmVhY3Rpb24ub2sgOiByZWFjdGlvbi5mYWlsO1xuICAgICAgdmFyIHJlc29sdmUgPSByZWFjdGlvbi5yZXNvbHZlO1xuICAgICAgdmFyIHJlamVjdCA9IHJlYWN0aW9uLnJlamVjdDtcbiAgICAgIHZhciBkb21haW4gPSByZWFjdGlvbi5kb21haW47XG4gICAgICB2YXIgcmVzdWx0LCB0aGVuO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICBpZiAoIW9rKSB7XG4gICAgICAgICAgICBpZiAocHJvbWlzZS5faCA9PSAyKSBvbkhhbmRsZVVuaGFuZGxlZChwcm9taXNlKTtcbiAgICAgICAgICAgIHByb21pc2UuX2ggPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGFuZGxlciA9PT0gdHJ1ZSkgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZG9tYWluKSBkb21haW4uZW50ZXIoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGhhbmRsZXIodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGRvbWFpbikgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gcmVhY3Rpb24ucHJvbWlzZSkge1xuICAgICAgICAgICAgcmVqZWN0KFR5cGVFcnJvcignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoZW4gPSBpc1RoZW5hYmxlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRoZW4uY2FsbChyZXN1bHQsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSBlbHNlIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHJlamVjdCh2YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdoaWxlIChjaGFpbi5sZW5ndGggPiBpKSBydW4oY2hhaW5baSsrXSk7IC8vIHZhcmlhYmxlIGxlbmd0aCAtIGNhbid0IHVzZSBmb3JFYWNoXG4gICAgcHJvbWlzZS5fYyA9IFtdO1xuICAgIHByb21pc2UuX24gPSBmYWxzZTtcbiAgICBpZiAoaXNSZWplY3QgJiYgIXByb21pc2UuX2gpIG9uVW5oYW5kbGVkKHByb21pc2UpO1xuICB9KTtcbn07XG52YXIgb25VbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdjtcbiAgICB2YXIgdW5oYW5kbGVkID0gaXNVbmhhbmRsZWQocHJvbWlzZSk7XG4gICAgdmFyIHJlc3VsdCwgaGFuZGxlciwgY29uc29sZTtcbiAgICBpZiAodW5oYW5kbGVkKSB7XG4gICAgICByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGlzTm9kZSkge1xuICAgICAgICAgIHByb2Nlc3MuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGhhbmRsZXIgPSBnbG9iYWwub251bmhhbmRsZWRyZWplY3Rpb24pIHtcbiAgICAgICAgICBoYW5kbGVyKHsgcHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiB2YWx1ZSB9KTtcbiAgICAgICAgfSBlbHNlIGlmICgoY29uc29sZSA9IGdsb2JhbC5jb25zb2xlKSAmJiBjb25zb2xlLmVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIEJyb3dzZXJzIHNob3VsZCBub3QgdHJpZ2dlciBgcmVqZWN0aW9uSGFuZGxlZGAgZXZlbnQgaWYgaXQgd2FzIGhhbmRsZWQgaGVyZSwgTm9kZUpTIC0gc2hvdWxkXG4gICAgICBwcm9taXNlLl9oID0gaXNOb2RlIHx8IGlzVW5oYW5kbGVkKHByb21pc2UpID8gMiA6IDE7XG4gICAgfSBwcm9taXNlLl9hID0gdW5kZWZpbmVkO1xuICAgIGlmICh1bmhhbmRsZWQgJiYgcmVzdWx0LmUpIHRocm93IHJlc3VsdC52O1xuICB9KTtcbn07XG52YXIgaXNVbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICBpZiAocHJvbWlzZS5faCA9PSAxKSByZXR1cm4gZmFsc2U7XG4gIHZhciBjaGFpbiA9IHByb21pc2UuX2EgfHwgcHJvbWlzZS5fYztcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVhY3Rpb247XG4gIHdoaWxlIChjaGFpbi5sZW5ndGggPiBpKSB7XG4gICAgcmVhY3Rpb24gPSBjaGFpbltpKytdO1xuICAgIGlmIChyZWFjdGlvbi5mYWlsIHx8ICFpc1VuaGFuZGxlZChyZWFjdGlvbi5wcm9taXNlKSkgcmV0dXJuIGZhbHNlO1xuICB9IHJldHVybiB0cnVlO1xufTtcbnZhciBvbkhhbmRsZVVuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaGFuZGxlcjtcbiAgICBpZiAoaXNOb2RlKSB7XG4gICAgICBwcm9jZXNzLmVtaXQoJ3JlamVjdGlvbkhhbmRsZWQnLCBwcm9taXNlKTtcbiAgICB9IGVsc2UgaWYgKGhhbmRsZXIgPSBnbG9iYWwub25yZWplY3Rpb25oYW5kbGVkKSB7XG4gICAgICBoYW5kbGVyKHsgcHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiBwcm9taXNlLl92IH0pO1xuICAgIH1cbiAgfSk7XG59O1xudmFyICRyZWplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIHByb21pc2UgPSB0aGlzO1xuICBpZiAocHJvbWlzZS5fZCkgcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fcyA9IDI7XG4gIGlmICghcHJvbWlzZS5fYSkgcHJvbWlzZS5fYSA9IHByb21pc2UuX2Muc2xpY2UoKTtcbiAgbm90aWZ5KHByb21pc2UsIHRydWUpO1xufTtcbnZhciAkcmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gIHZhciB0aGVuO1xuICBpZiAocHJvbWlzZS5fZCkgcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHRyeSB7XG4gICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB0aHJvdyBUeXBlRXJyb3IoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTtcbiAgICBpZiAodGhlbiA9IGlzVGhlbmFibGUodmFsdWUpKSB7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd3JhcHBlciA9IHsgX3c6IHByb21pc2UsIF9kOiBmYWxzZSB9OyAvLyB3cmFwXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBjdHgoJHJlc29sdmUsIHdyYXBwZXIsIDEpLCBjdHgoJHJlamVjdCwgd3JhcHBlciwgMSkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgJHJlamVjdC5jYWxsKHdyYXBwZXIsIGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvbWlzZS5fdiA9IHZhbHVlO1xuICAgICAgcHJvbWlzZS5fcyA9IDE7XG4gICAgICBub3RpZnkocHJvbWlzZSwgZmFsc2UpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgICRyZWplY3QuY2FsbCh7IF93OiBwcm9taXNlLCBfZDogZmFsc2UgfSwgZSk7IC8vIHdyYXBcbiAgfVxufTtcblxuLy8gY29uc3RydWN0b3IgcG9seWZpbGxcbmlmICghVVNFX05BVElWRSkge1xuICAvLyAyNS40LjMuMSBQcm9taXNlKGV4ZWN1dG9yKVxuICAkUHJvbWlzZSA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcbiAgICBhbkluc3RhbmNlKHRoaXMsICRQcm9taXNlLCBQUk9NSVNFLCAnX2gnKTtcbiAgICBhRnVuY3Rpb24oZXhlY3V0b3IpO1xuICAgIEludGVybmFsLmNhbGwodGhpcyk7XG4gICAgdHJ5IHtcbiAgICAgIGV4ZWN1dG9yKGN0eCgkcmVzb2x2ZSwgdGhpcywgMSksIGN0eCgkcmVqZWN0LCB0aGlzLCAxKSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAkcmVqZWN0LmNhbGwodGhpcywgZXJyKTtcbiAgICB9XG4gIH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBJbnRlcm5hbCA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcbiAgICB0aGlzLl9jID0gW107ICAgICAgICAgICAgIC8vIDwtIGF3YWl0aW5nIHJlYWN0aW9uc1xuICAgIHRoaXMuX2EgPSB1bmRlZmluZWQ7ICAgICAgLy8gPC0gY2hlY2tlZCBpbiBpc1VuaGFuZGxlZCByZWFjdGlvbnNcbiAgICB0aGlzLl9zID0gMDsgICAgICAgICAgICAgIC8vIDwtIHN0YXRlXG4gICAgdGhpcy5fZCA9IGZhbHNlOyAgICAgICAgICAvLyA8LSBkb25lXG4gICAgdGhpcy5fdiA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSB2YWx1ZVxuICAgIHRoaXMuX2ggPSAwOyAgICAgICAgICAgICAgLy8gPC0gcmVqZWN0aW9uIHN0YXRlLCAwIC0gZGVmYXVsdCwgMSAtIGhhbmRsZWQsIDIgLSB1bmhhbmRsZWRcbiAgICB0aGlzLl9uID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIG5vdGlmeVxuICB9O1xuICBJbnRlcm5hbC5wcm90b3R5cGUgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKSgkUHJvbWlzZS5wcm90b3R5cGUsIHtcbiAgICAvLyAyNS40LjUuMyBQcm9taXNlLnByb3RvdHlwZS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKVxuICAgIHRoZW46IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgIHZhciByZWFjdGlvbiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCAkUHJvbWlzZSkpO1xuICAgICAgcmVhY3Rpb24ub2sgPSB0eXBlb2Ygb25GdWxmaWxsZWQgPT0gJ2Z1bmN0aW9uJyA/IG9uRnVsZmlsbGVkIDogdHJ1ZTtcbiAgICAgIHJlYWN0aW9uLmZhaWwgPSB0eXBlb2Ygb25SZWplY3RlZCA9PSAnZnVuY3Rpb24nICYmIG9uUmVqZWN0ZWQ7XG4gICAgICByZWFjdGlvbi5kb21haW4gPSBpc05vZGUgPyBwcm9jZXNzLmRvbWFpbiA6IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX2MucHVzaChyZWFjdGlvbik7XG4gICAgICBpZiAodGhpcy5fYSkgdGhpcy5fYS5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmICh0aGlzLl9zKSBub3RpZnkodGhpcywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHJlYWN0aW9uLnByb21pc2U7XG4gICAgfSxcbiAgICAvLyAyNS40LjUuMSBQcm9taXNlLnByb3RvdHlwZS5jYXRjaChvblJlamVjdGVkKVxuICAgICdjYXRjaCc6IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XG4gICAgfVxuICB9KTtcbiAgT3duUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgSW50ZXJuYWwoKTtcbiAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICAgIHRoaXMucmVzb2x2ZSA9IGN0eCgkcmVzb2x2ZSwgcHJvbWlzZSwgMSk7XG4gICAgdGhpcy5yZWplY3QgPSBjdHgoJHJlamVjdCwgcHJvbWlzZSwgMSk7XG4gIH07XG4gIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlLmYgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uIChDKSB7XG4gICAgcmV0dXJuIEMgPT09ICRQcm9taXNlIHx8IEMgPT09IFdyYXBwZXJcbiAgICAgID8gbmV3IE93blByb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICA6IG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgeyBQcm9taXNlOiAkUHJvbWlzZSB9KTtcbnJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJykoJFByb21pc2UsIFBST01JU0UpO1xucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKShQUk9NSVNFKTtcbldyYXBwZXIgPSByZXF1aXJlKCcuL19jb3JlJylbUFJPTUlTRV07XG5cbi8vIHN0YXRpY3NcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjUgUHJvbWlzZS5yZWplY3QocilcbiAgcmVqZWN0OiBmdW5jdGlvbiByZWplY3Qocikge1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkodGhpcyk7XG4gICAgdmFyICQkcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgJCRyZWplY3Qocik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChMSUJSQVJZIHx8ICFVU0VfTkFUSVZFKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNiBQcm9taXNlLnJlc29sdmUoeClcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSh4KSB7XG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKExJQlJBUlkgJiYgdGhpcyA9PT0gV3JhcHBlciA/ICRQcm9taXNlIDogdGhpcywgeCk7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKFVTRV9OQVRJVkUgJiYgcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKShmdW5jdGlvbiAoaXRlcikge1xuICAkUHJvbWlzZS5hbGwoaXRlcilbJ2NhdGNoJ10oZW1wdHkpO1xufSkpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC4xIFByb21pc2UuYWxsKGl0ZXJhYmxlKVxuICBhbGw6IGZ1bmN0aW9uIGFsbChpdGVyYWJsZSkge1xuICAgIHZhciBDID0gdGhpcztcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICAgIHZhciByZXNvbHZlID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdmFyIHJlbWFpbmluZyA9IDE7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIHZhciAkaW5kZXggPSBpbmRleCsrO1xuICAgICAgICB2YXIgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICByZW1haW5pbmcrKztcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKGFscmVhZHlDYWxsZWQpIHJldHVybjtcbiAgICAgICAgICBhbHJlYWR5Q2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZXNbJGluZGV4XSA9IHZhbHVlO1xuICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgIH0pO1xuICAgIGlmIChyZXN1bHQuZSkgcmVqZWN0KHJlc3VsdC52KTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9LFxuICAvLyAyNS40LjQuNCBQcm9taXNlLnJhY2UoaXRlcmFibGUpXG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihjYXBhYmlsaXR5LnJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmUpIHJlamVjdChyZXN1bHQudik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYucHJvbWlzZS5qc1xuLy8gbW9kdWxlIGlkID0gNzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIENvbnN0cnVjdG9yLCBuYW1lLCBmb3JiaWRkZW5GaWVsZCkge1xuICBpZiAoIShpdCBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSB8fCAoZm9yYmlkZGVuRmllbGQgIT09IHVuZGVmaW5lZCAmJiBmb3JiaWRkZW5GaWVsZCBpbiBpdCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IobmFtZSArICc6IGluY29ycmVjdCBpbnZvY2F0aW9uIScpO1xuICB9IHJldHVybiBpdDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4taW5zdGFuY2UuanNcbi8vIG1vZHVsZSBpZCA9IDgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJyk7XG52YXIgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGdldEl0ZXJGbiA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG52YXIgQlJFQUsgPSB7fTtcbnZhciBSRVRVUk4gPSB7fTtcbnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmFibGUsIGVudHJpZXMsIGZuLCB0aGF0LCBJVEVSQVRPUikge1xuICB2YXIgaXRlckZuID0gSVRFUkFUT1IgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBpdGVyYWJsZTsgfSA6IGdldEl0ZXJGbihpdGVyYWJsZSk7XG4gIHZhciBmID0gY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGVuZ3RoLCBzdGVwLCBpdGVyYXRvciwgcmVzdWx0O1xuICBpZiAodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXRlcmFibGUgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgLy8gZmFzdCBjYXNlIGZvciBhcnJheXMgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yXG4gIGlmIChpc0FycmF5SXRlcihpdGVyRm4pKSBmb3IgKGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgcmVzdWx0ID0gZW50cmllcyA/IGYoYW5PYmplY3Qoc3RlcCA9IGl0ZXJhYmxlW2luZGV4XSlbMF0sIHN0ZXBbMV0pIDogZihpdGVyYWJsZVtpbmRleF0pO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9IGVsc2UgZm9yIChpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKGl0ZXJhYmxlKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOykge1xuICAgIHJlc3VsdCA9IGNhbGwoaXRlcmF0b3IsIGYsIHN0ZXAudmFsdWUsIGVudHJpZXMpO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuZXhwb3J0cy5CUkVBSyA9IEJSRUFLO1xuZXhwb3J0cy5SRVRVUk4gPSBSRVRVUk47XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZm9yLW9mLmpzXG4vLyBtb2R1bGUgaWQgPSA4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBmYXN0IGFwcGx5LCBodHRwOi8vanNwZXJmLmxua2l0LmNvbS9mYXN0LWFwcGx5LzVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCBhcmdzLCB0aGF0KSB7XG4gIHZhciB1biA9IHRoYXQgPT09IHVuZGVmaW5lZDtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIHVuID8gZm4oKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0KTtcbiAgICBjYXNlIDE6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICBjYXNlIDQ6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICB9IHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmdzKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faW52b2tlLmpzXG4vLyBtb2R1bGUgaWQgPSA4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgbWFjcm90YXNrID0gcmVxdWlyZSgnLi9fdGFzaycpLnNldDtcbnZhciBPYnNlcnZlciA9IGdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciBQcm9taXNlID0gZ2xvYmFsLlByb21pc2U7XG52YXIgaXNOb2RlID0gcmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhlYWQsIGxhc3QsIG5vdGlmeTtcblxuICB2YXIgZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhcmVudCwgZm47XG4gICAgaWYgKGlzTm9kZSAmJiAocGFyZW50ID0gcHJvY2Vzcy5kb21haW4pKSBwYXJlbnQuZXhpdCgpO1xuICAgIHdoaWxlIChoZWFkKSB7XG4gICAgICBmbiA9IGhlYWQuZm47XG4gICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGhlYWQpIG5vdGlmeSgpO1xuICAgICAgICBlbHNlIGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgIGlmIChwYXJlbnQpIHBhcmVudC5lbnRlcigpO1xuICB9O1xuXG4gIC8vIE5vZGUuanNcbiAgaWYgKGlzTm9kZSkge1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICAgIH07XG4gIC8vIGJyb3dzZXJzIHdpdGggTXV0YXRpb25PYnNlcnZlclxuICB9IGVsc2UgaWYgKE9ic2VydmVyKSB7XG4gICAgdmFyIHRvZ2dsZSA9IHRydWU7XG4gICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgbmV3IE9ic2VydmVyKGZsdXNoKS5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBub2RlLmRhdGEgPSB0b2dnbGUgPSAhdG9nZ2xlO1xuICAgIH07XG4gIC8vIGVudmlyb25tZW50cyB3aXRoIG1heWJlIG5vbi1jb21wbGV0ZWx5IGNvcnJlY3QsIGJ1dCBleGlzdGVudCBQcm9taXNlXG4gIH0gZWxzZSBpZiAoUHJvbWlzZSAmJiBQcm9taXNlLnJlc29sdmUpIHtcbiAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb21pc2UudGhlbihmbHVzaCk7XG4gICAgfTtcbiAgLy8gZm9yIG90aGVyIGVudmlyb25tZW50cyAtIG1hY3JvdGFzayBiYXNlZCBvbjpcbiAgLy8gLSBzZXRJbW1lZGlhdGVcbiAgLy8gLSBNZXNzYWdlQ2hhbm5lbFxuICAvLyAtIHdpbmRvdy5wb3N0TWVzc2FnXG4gIC8vIC0gb25yZWFkeXN0YXRlY2hhbmdlXG4gIC8vIC0gc2V0VGltZW91dFxuICB9IGVsc2Uge1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIHN0cmFuZ2UgSUUgKyB3ZWJwYWNrIGRldiBzZXJ2ZXIgYnVnIC0gdXNlIC5jYWxsKGdsb2JhbClcbiAgICAgIG1hY3JvdGFzay5jYWxsKGdsb2JhbCwgZmx1c2gpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XG4gICAgdmFyIHRhc2sgPSB7IGZuOiBmbiwgbmV4dDogdW5kZWZpbmVkIH07XG4gICAgaWYgKGxhc3QpIGxhc3QubmV4dCA9IHRhc2s7XG4gICAgaWYgKCFoZWFkKSB7XG4gICAgICBoZWFkID0gdGFzaztcbiAgICAgIG5vdGlmeSgpO1xuICAgIH0gbGFzdCA9IHRhc2s7XG4gIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX21pY3JvdGFzay5qc1xuLy8gbW9kdWxlIGlkID0gODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNyYywgc2FmZSkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgaWYgKHNhZmUgJiYgdGFyZ2V0W2tleV0pIHRhcmdldFtrZXldID0gc3JjW2tleV07XG4gICAgZWxzZSBoaWRlKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gIH0gcmV0dXJuIHRhcmdldDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcmVkZWZpbmUtYWxsLmpzXG4vLyBtb2R1bGUgaWQgPSA4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZKSB7XG4gIHZhciBDID0gdHlwZW9mIGNvcmVbS0VZXSA9PSAnZnVuY3Rpb24nID8gY29yZVtLRVldIDogZ2xvYmFsW0tFWV07XG4gIGlmIChERVNDUklQVE9SUyAmJiBDICYmICFDW1NQRUNJRVNdKSBkUC5mKEMsIFNQRUNJRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9XG4gIH0pO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtc3BlY2llcy5qc1xuLy8gbW9kdWxlIGlkID0gODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcHJvbWlzZS1maW5hbGx5XG4ndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xudmFyIHByb21pc2VSZXNvbHZlID0gcmVxdWlyZSgnLi9fcHJvbWlzZS1yZXNvbHZlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5SLCAnUHJvbWlzZScsIHsgJ2ZpbmFsbHknOiBmdW5jdGlvbiAob25GaW5hbGx5KSB7XG4gIHZhciBDID0gc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsIGNvcmUuUHJvbWlzZSB8fCBnbG9iYWwuUHJvbWlzZSk7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIG9uRmluYWxseSA9PSAnZnVuY3Rpb24nO1xuICByZXR1cm4gdGhpcy50aGVuKFxuICAgIGlzRnVuY3Rpb24gPyBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKEMsIG9uRmluYWxseSgpKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHg7IH0pO1xuICAgIH0gOiBvbkZpbmFsbHksXG4gICAgaXNGdW5jdGlvbiA/IGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmUoQywgb25GaW5hbGx5KCkpLnRoZW4oZnVuY3Rpb24gKCkgeyB0aHJvdyBlOyB9KTtcbiAgICB9IDogb25GaW5hbGx5XG4gICk7XG59IH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnByb21pc2UuZmluYWxseS5qc1xuLy8gbW9kdWxlIGlkID0gODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcHJvbWlzZS10cnlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSByZXF1aXJlKCcuL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5Jyk7XG52YXIgcGVyZm9ybSA9IHJlcXVpcmUoJy4vX3BlcmZvcm0nKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdQcm9taXNlJywgeyAndHJ5JzogZnVuY3Rpb24gKGNhbGxiYWNrZm4pIHtcbiAgdmFyIHByb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkuZih0aGlzKTtcbiAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oY2FsbGJhY2tmbik7XG4gIChyZXN1bHQuZSA/IHByb21pc2VDYXBhYmlsaXR5LnJlamVjdCA6IHByb21pc2VDYXBhYmlsaXR5LnJlc29sdmUpKHJlc3VsdC52KTtcbiAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5LnByb21pc2U7XG59IH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnByb21pc2UudHJ5LmpzXG4vLyBtb2R1bGUgaWQgPSA4N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKTtcbnZhciAkSlNPTiA9IGNvcmUuSlNPTiB8fCAoY29yZS5KU09OID0geyBzdHJpbmdpZnk6IEpTT04uc3RyaW5naWZ5IH0pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICByZXR1cm4gJEpTT04uc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmd1bWVudHMpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9qc29uL3N0cmluZ2lmeS5qc1xuLy8gbW9kdWxlIGlkID0gODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LmFzc2lnbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduLmpzXG4vLyBtb2R1bGUgaWQgPSA4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjMuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYsICdPYmplY3QnLCB7IGFzc2lnbjogcmVxdWlyZSgnLi9fb2JqZWN0LWFzc2lnbicpIH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24uanNcbi8vIG1vZHVsZSBpZCA9IDkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BTID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKTtcbnZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyICRhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG4vLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1Zylcbm1vZHVsZS5leHBvcnRzID0gISRhc3NpZ24gfHwgcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHZhciBBID0ge307XG4gIHZhciBCID0ge307XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2YXIgUyA9IFN5bWJvbCgpO1xuICB2YXIgSyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbU10gPSA3O1xuICBLLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7IEJba10gPSBrOyB9KTtcbiAgcmV0dXJuICRhc3NpZ24oe30sIEEpW1NdICE9IDcgfHwgT2JqZWN0LmtleXMoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IEs7XG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciBUID0gdG9PYmplY3QodGFyZ2V0KTtcbiAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAxO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgdmFyIGlzRW51bSA9IHBJRS5mO1xuICB3aGlsZSAoYUxlbiA+IGluZGV4KSB7XG4gICAgdmFyIFMgPSBJT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAgdmFyIGtleXMgPSBnZXRTeW1ib2xzID8gZ2V0S2V5cyhTKS5jb25jYXQoZ2V0U3ltYm9scyhTKSkgOiBnZXRLZXlzKFMpO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaikgaWYgKGlzRW51bS5jYWxsKFMsIGtleSA9IGtleXNbaisrXSkpIFRba2V5XSA9IFNba2V5XTtcbiAgfSByZXR1cm4gVDtcbn0gOiAkYXNzaWduO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1hc3NpZ24uanNcbi8vIG1vZHVsZSBpZCA9IDkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanNcbi8vIG1vZHVsZSBpZCA9IDkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMuZiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1waWUuanNcbi8vIG1vZHVsZSBpZCA9IDkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9udW1iZXIvaXMtaW50ZWdlclwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9udW1iZXIvaXMtaW50ZWdlci5qc1xuLy8gbW9kdWxlIGlkID0gOTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYubnVtYmVyLmlzLWludGVnZXInKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk51bWJlci5pc0ludGVnZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vbnVtYmVyL2lzLWludGVnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIwLjEuMi4zIE51bWJlci5pc0ludGVnZXIobnVtYmVyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7IGlzSW50ZWdlcjogcmVxdWlyZSgnLi9faXMtaW50ZWdlcicpIH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm51bWJlci5pcy1pbnRlZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4xLjIuMyBOdW1iZXIuaXNJbnRlZ2VyKG51bWJlcilcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNJbnRlZ2VyKGl0KSB7XG4gIHJldHVybiAhaXNPYmplY3QoaXQpICYmIGlzRmluaXRlKGl0KSAmJiBmbG9vcihpdCkgPT09IGl0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1pbnRlZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2tleXNcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2tleXMuanNcbi8vIG1vZHVsZSBpZCA9IDk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Qua2V5cztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qva2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gOTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMS4yLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgna2V5cycsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGtleXMoaXQpIHtcbiAgICByZXR1cm4gJGtleXModG9PYmplY3QoaXQpKTtcbiAgfTtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gbW9zdCBPYmplY3QgbWV0aG9kcyBieSBFUzYgc2hvdWxkIGFjY2VwdCBwcmltaXRpdmVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZLCBleGVjKSB7XG4gIHZhciBmbiA9IChjb3JlLk9iamVjdCB8fCB7fSlbS0VZXSB8fCBPYmplY3RbS0VZXTtcbiAgdmFyIGV4cCA9IHt9O1xuICBleHBbS0VZXSA9IGV4ZWMoZm4pO1xuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uICgpIHsgZm4oMSk7IH0pLCAnT2JqZWN0JywgZXhwKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXNhcC5qc1xuLy8gbW9kdWxlIGlkID0gMTAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuYXJyYXkuZnJvbScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuQXJyYXkuZnJvbTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9hcnJheS9mcm9tLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKTtcbnZhciBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fY3JlYXRlLXByb3BlcnR5Jyk7XG52YXIgZ2V0SXRlckZuID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKShmdW5jdGlvbiAoaXRlcikgeyBBcnJheS5mcm9tKGl0ZXIpOyB9KSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjIuMSBBcnJheS5mcm9tKGFycmF5TGlrZSwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gIGZyb206IGZ1bmN0aW9uIGZyb20oYXJyYXlMaWtlIC8qICwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQgKi8pIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KGFycmF5TGlrZSk7XG4gICAgdmFyIEMgPSB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5O1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgbWFwZm4gPSBhTGVuID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWQ7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgaXRlckZuID0gZ2V0SXRlckZuKE8pO1xuICAgIHZhciBsZW5ndGgsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3I7XG4gICAgaWYgKG1hcHBpbmcpIG1hcGZuID0gY3R4KG1hcGZuLCBhTGVuID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCwgMik7XG4gICAgLy8gaWYgb2JqZWN0IGlzbid0IGl0ZXJhYmxlIG9yIGl0J3MgYXJyYXkgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yIC0gdXNlIHNpbXBsZSBjYXNlXG4gICAgaWYgKGl0ZXJGbiAhPSB1bmRlZmluZWQgJiYgIShDID09IEFycmF5ICYmIGlzQXJyYXlJdGVyKGl0ZXJGbikpKSB7XG4gICAgICBmb3IgKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoTyksIHJlc3VsdCA9IG5ldyBDKCk7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgaW5kZXgrKykge1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gY2FsbChpdGVyYXRvciwgbWFwZm4sIFtzdGVwLnZhbHVlLCBpbmRleF0sIHRydWUpIDogc3RlcC52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICAgIGZvciAocmVzdWx0ID0gbmV3IEMobGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IG1hcGZuKE9baW5kZXhdLCBpbmRleCkgOiBPW2luZGV4XSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5sZW5ndGggPSBpbmRleDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5hcnJheS5mcm9tLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgaW5kZXgsIHZhbHVlKSB7XG4gIGlmIChpbmRleCBpbiBvYmplY3QpICRkZWZpbmVQcm9wZXJ0eS5mKG9iamVjdCwgaW5kZXgsIGNyZWF0ZURlc2MoMCwgdmFsdWUpKTtcbiAgZWxzZSBvYmplY3RbaW5kZXhdID0gdmFsdWU7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NyZWF0ZS1wcm9wZXJ0eS5qc1xuLy8gbW9kdWxlIGlkID0gMTA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2Zyb20gPSByZXF1aXJlKFwiLi4vY29yZS1qcy9hcnJheS9mcm9tXCIpO1xuXG52YXIgX2Zyb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZnJvbSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFycjJbaV0gPSBhcnJbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycjI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICgwLCBfZnJvbTIuZGVmYXVsdCkoYXJyKTtcbiAgfVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDEwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vaXMtaXRlcmFibGVcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvaXMtaXRlcmFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDEwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL2NvcmUuaXMtaXRlcmFibGUnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9pcy1pdGVyYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5pc0l0ZXJhYmxlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPID0gT2JqZWN0KGl0KTtcbiAgcmV0dXJuIE9bSVRFUkFUT1JdICE9PSB1bmRlZmluZWRcbiAgICB8fCAnQEBpdGVyYXRvcicgaW4gT1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICB8fCBJdGVyYXRvcnMuaGFzT3duUHJvcGVydHkoY2xhc3NvZihPKSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5pcy1pdGVyYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9nZXQtaXRlcmF0b3JcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvZ2V0LWl0ZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvcicpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL2dldC1pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMTEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGdldCA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvciA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgaXRlckZuID0gZ2V0KGl0KTtcbiAgaWYgKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgaXRlcmFibGUhJyk7XG4gIHJldHVybiBhbk9iamVjdChpdGVyRm4uY2FsbChpdCkpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5XCIpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlZmluZVByb3BlcnR5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qc1xuLy8gbW9kdWxlIGlkID0gMTEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHknKTtcbnZhciAkT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYykge1xuICByZXR1cm4gJE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qc1xuLy8gbW9kdWxlIGlkID0gMTE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4vLyAxOS4xLjIuNCAvIDE1LjIuMy42IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSwgJ09iamVjdCcsIHsgZGVmaW5lUHJvcGVydHk6IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmYgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eS5qc1xuLy8gbW9kdWxlIGlkID0gMTE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlZ2VuZXJhdG9yLXJ1bnRpbWVcIik7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gVGhpcyBtZXRob2Qgb2Ygb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0IG5lZWRzIHRvIGJlXG4vLyBrZXB0IGlkZW50aWNhbCB0byB0aGUgd2F5IGl0IGlzIG9idGFpbmVkIGluIHJ1bnRpbWUuanNcbnZhciBnID0gKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcyB9KSgpIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcblxuLy8gVXNlIGBnZXRPd25Qcm9wZXJ0eU5hbWVzYCBiZWNhdXNlIG5vdCBhbGwgYnJvd3NlcnMgc3VwcG9ydCBjYWxsaW5nXG4vLyBgaGFzT3duUHJvcGVydHlgIG9uIHRoZSBnbG9iYWwgYHNlbGZgIG9iamVjdCBpbiBhIHdvcmtlci4gU2VlICMxODMuXG52YXIgaGFkUnVudGltZSA9IGcucmVnZW5lcmF0b3JSdW50aW1lICYmXG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGcpLmluZGV4T2YoXCJyZWdlbmVyYXRvclJ1bnRpbWVcIikgPj0gMDtcblxuLy8gU2F2ZSB0aGUgb2xkIHJlZ2VuZXJhdG9yUnVudGltZSBpbiBjYXNlIGl0IG5lZWRzIHRvIGJlIHJlc3RvcmVkIGxhdGVyLlxudmFyIG9sZFJ1bnRpbWUgPSBoYWRSdW50aW1lICYmIGcucmVnZW5lcmF0b3JSdW50aW1lO1xuXG4vLyBGb3JjZSByZWV2YWx1dGF0aW9uIG9mIHJ1bnRpbWUuanMuXG5nLnJlZ2VuZXJhdG9yUnVudGltZSA9IHVuZGVmaW5lZDtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9ydW50aW1lXCIpO1xuXG5pZiAoaGFkUnVudGltZSkge1xuICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBydW50aW1lLlxuICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IG9sZFJ1bnRpbWU7XG59IGVsc2Uge1xuICAvLyBSZW1vdmUgdGhlIGdsb2JhbCBwcm9wZXJ0eSBhZGRlZCBieSBydW50aW1lLmpzLlxuICB0cnkge1xuICAgIGRlbGV0ZSBnLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgfSBjYXRjaChlKSB7XG4gICAgZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSB1bmRlZmluZWQ7XG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS1tb2R1bGUuanNcbi8vIG1vZHVsZSBpZCA9IDExN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBodHRwczovL3Jhdy5naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL21hc3Rlci9MSUNFTlNFIGZpbGUuIEFuXG4gKiBhZGRpdGlvbmFsIGdyYW50IG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW5cbiAqIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4hKGZ1bmN0aW9uKGdsb2JhbCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIHZhciBpbk1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCI7XG4gIHZhciBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgaWYgKHJ1bnRpbWUpIHtcbiAgICBpZiAoaW5Nb2R1bGUpIHtcbiAgICAgIC8vIElmIHJlZ2VuZXJhdG9yUnVudGltZSBpcyBkZWZpbmVkIGdsb2JhbGx5IGFuZCB3ZSdyZSBpbiBhIG1vZHVsZSxcbiAgICAgIC8vIG1ha2UgdGhlIGV4cG9ydHMgb2JqZWN0IGlkZW50aWNhbCB0byByZWdlbmVyYXRvclJ1bnRpbWUuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XG4gICAgfVxuICAgIC8vIERvbid0IGJvdGhlciBldmFsdWF0aW5nIHRoZSByZXN0IG9mIHRoaXMgZmlsZSBpZiB0aGUgcnVudGltZSB3YXNcbiAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRGVmaW5lIHRoZSBydW50aW1lIGdsb2JhbGx5IChhcyBleHBlY3RlZCBieSBnZW5lcmF0ZWQgY29kZSkgYXMgZWl0aGVyXG4gIC8vIG1vZHVsZS5leHBvcnRzIChpZiB3ZSdyZSBpbiBhIG1vZHVsZSkgb3IgYSBuZXcsIGVtcHR5IG9iamVjdC5cbiAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgcnVudGltZS53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID1cbiAgICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBydW50aW1lLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGlmICghKHRvU3RyaW5nVGFnU3ltYm9sIGluIGdlbkZ1bikpIHtcbiAgICAgICAgZ2VuRnVuW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgcnVudGltZS5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uIElmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBob3dldmVyLCB0aGVcbiAgICAgICAgICAvLyByZXN1bHQgZm9yIHRoaXMgaXRlcmF0aW9uIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgc2FtZVxuICAgICAgICAgIC8vIHJlYXNvbi4gTm90ZSB0aGF0IHJlamVjdGlvbnMgb2YgeWllbGRlZCBQcm9taXNlcyBhcmUgbm90XG4gICAgICAgICAgLy8gdGhyb3duIGJhY2sgaW50byB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBhcyBpcyB0aGUgY2FzZVxuICAgICAgICAgIC8vIHdoZW4gYW4gYXdhaXRlZCBQcm9taXNlIGlzIHJlamVjdGVkLiBUaGlzIGRpZmZlcmVuY2UgaW5cbiAgICAgICAgICAvLyBiZWhhdmlvciBiZXR3ZWVuIHlpZWxkIGFuZCBhd2FpdCBpcyBpbXBvcnRhbnQsIGJlY2F1c2UgaXRcbiAgICAgICAgICAvLyBhbGxvd3MgdGhlIGNvbnN1bWVyIHRvIGRlY2lkZSB3aGF0IHRvIGRvIHdpdGggdGhlIHlpZWxkZWRcbiAgICAgICAgICAvLyByZWplY3Rpb24gKHN3YWxsb3cgaXQgYW5kIGNvbnRpbnVlLCBtYW51YWxseSAudGhyb3cgaXQgYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGdlbmVyYXRvciwgYWJhbmRvbiBpdGVyYXRpb24sIHdoYXRldmVyKS4gV2l0aFxuICAgICAgICAgIC8vIGF3YWl0LCBieSBjb250cmFzdCwgdGhlcmUgaXMgbm8gb3Bwb3J0dW5pdHkgdG8gZXhhbWluZSB0aGVcbiAgICAgICAgICAvLyByZWplY3Rpb24gcmVhc29uIG91dHNpZGUgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgc28gdGhlXG4gICAgICAgICAgLy8gb25seSBvcHRpb24gaXMgdG8gdGhyb3cgaXQgZnJvbSB0aGUgYXdhaXQgZXhwcmVzc2lvbiwgYW5kXG4gICAgICAgICAgLy8gbGV0IHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gaGFuZGxlIHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIEFzeW5jSXRlcmF0b3IucHJvdG90eXBlW2FzeW5jSXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBydW50aW1lLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBydW50aW1lLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdClcbiAgICApO1xuXG4gICAgcmV0dXJuIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCEgaW5mbykge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcblxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcblxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBHcFt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvclwiO1xuXG4gIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXG4gIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIHJ1bnRpbWUua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBydW50aW1lLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xufSkoXG4gIC8vIEluIHNsb3BweSBtb2RlLCB1bmJvdW5kIGB0aGlzYCByZWZlcnMgdG8gdGhlIGdsb2JhbCBvYmplY3QsIGZhbGxiYWNrIHRvXG4gIC8vIEZ1bmN0aW9uIGNvbnN0cnVjdG9yIGlmIHdlJ3JlIGluIGdsb2JhbCBzdHJpY3QgbW9kZS4gVGhhdCBpcyBzYWRseSBhIGZvcm1cbiAgLy8gb2YgaW5kaXJlY3QgZXZhbCB3aGljaCB2aW9sYXRlcyBDb250ZW50IFNlY3VyaXR5IFBvbGljeS5cbiAgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcyB9KSgpIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKVxuKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qc1xuLy8gbW9kdWxlIGlkID0gMTE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3Byb21pc2UgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9wcm9taXNlXCIpO1xuXG52YXIgX3Byb21pc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJvbWlzZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBnZW4gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiBuZXcgX3Byb21pc2UyLmRlZmF1bHQoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgZnVuY3Rpb24gc3RlcChrZXksIGFyZykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBfcHJvbWlzZTIuZGVmYXVsdC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgc3RlcChcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIHN0ZXAoXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdGVwKFwibmV4dFwiKTtcbiAgICB9KTtcbiAgfTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDExOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJjb25zdCBzdG9yYWdlID0gKCkgPT4ge1xyXG4gIGNvbnN0IGZhbGxCYWNrID0ge1xyXG4gICAgc3RvcmFnZToge30sXHJcbiAgICBzZXRJdGVtKGtleSwgdmFsdWUpIHtcclxuICAgICAgdGhpcy5zdG9yYWdlW2tleV0gPSB2YWx1ZTtcclxuICAgIH0sXHJcbiAgICBnZXRJdGVtKGtleSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5zdG9yYWdlW2tleV07XHJcbiAgICB9LFxyXG4gIH07XHJcbiAgY29uc3QgY2hvb3NlU3RvcmFnZSA9ICh0eXBlT2ZTdG9yYWdlKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBpZiAodHlwZU9mU3RvcmFnZSBpbiB3aW5kb3cgJiYgd2luZG93W3R5cGVPZlN0b3JhZ2VdICE9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHdpbmRvd1t0eXBlT2ZTdG9yYWdlXTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmFsbEJhY2s7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgc2V0VXAodHlwZU9mU3RvcmFnZSA9ICdzZXNzaW9uU3RvcmFnZScpIHtcclxuICAgICAgY29uc3Qgc3RvcmFnZVR5cGUgPSBjaG9vc2VTdG9yYWdlKHR5cGVPZlN0b3JhZ2UpO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHNldChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICBzdG9yYWdlVHlwZS5zZXRJdGVtKGtleSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldChrZXkpIHtcclxuICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHN0b3JhZ2VUeXBlLmdldEl0ZW0oa2V5KSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZW1vdmUoa2V5KSB7XHJcbiAgICAgICAgICBzdG9yYWdlVHlwZS5yZW1vdmVJdGVtKGtleSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgfTtcclxuICAgIH0sXHJcbiAgfTtcclxufTtcclxuXHJcbmNvbnN0IGRiID0gc3RvcmFnZSgpO1xyXG5leHBvcnQgZGVmYXVsdCBkYi5zZXRVcCgpO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdXRpbC9tb2R1bGVzL3N0b3JhZ2UuanMiXSwic291cmNlUm9vdCI6IiJ9