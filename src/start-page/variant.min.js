/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 52);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

var core = module.exports = { version: '2.5.1' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(35)('wks');
var uid = __webpack_require__(36);
var Symbol = __webpack_require__(2).Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),
/* 2 */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var core = __webpack_require__(0);
var ctx = __webpack_require__(10);
var hide = __webpack_require__(5);
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && key in exports) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(7);
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(6);
var createDesc = __webpack_require__(20);
module.exports = __webpack_require__(8) ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(4);
var IE8_DOM_DEFINE = __webpack_require__(56);
var toPrimitive = __webpack_require__(57);
var dP = Object.defineProperty;

exports.f = __webpack_require__(8) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(13)(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 9 */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(12);
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at = __webpack_require__(55)(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(32)(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),
/* 12 */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),
/* 13 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),
/* 14 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),
/* 15 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(18);
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),
/* 17 */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),
/* 18 */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(7);
var document = __webpack_require__(2).document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),
/* 20 */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(62);
var enumBugKeys = __webpack_require__(37);

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(34);
var defined = __webpack_require__(18);
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(17);
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(35)('keys');
var uid = __webpack_require__(36);
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(6).f;
var has = __webpack_require__(14);
var TAG = __webpack_require__(1)('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(66);
var global = __webpack_require__(2);
var hide = __webpack_require__(5);
var Iterators = __webpack_require__(9);
var TO_STRING_TAG = __webpack_require__(1)('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(15);
var TAG = __webpack_require__(1)('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(27);
var ITERATOR = __webpack_require__(1)('iterator');
var Iterators = __webpack_require__(9);
module.exports = __webpack_require__(0).getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 25.4.1.5 NewPromiseCapability(C)
var aFunction = __webpack_require__(12);

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(79), __esModule: true };

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(53), __esModule: true };

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(33);
var $export = __webpack_require__(3);
var redefine = __webpack_require__(58);
var hide = __webpack_require__(5);
var has = __webpack_require__(14);
var Iterators = __webpack_require__(9);
var $iterCreate = __webpack_require__(59);
var setToStringTag = __webpack_require__(25);
var getPrototypeOf = __webpack_require__(65);
var ITERATOR = __webpack_require__(1)('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),
/* 33 */
/***/ (function(module, exports) {

module.exports = true;


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(15);
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});
module.exports = function (key) {
  return store[key] || (store[key] = {});
};


/***/ }),
/* 36 */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),
/* 37 */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(2).document;
module.exports = document && document.documentElement;


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(4);
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(9);
var ITERATOR = __webpack_require__(1)('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__(4);
var aFunction = __webpack_require__(12);
var SPECIES = __webpack_require__(1)('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(10);
var invoke = __webpack_require__(72);
var html = __webpack_require__(38);
var cel = __webpack_require__(19);
var global = __webpack_require__(2);
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (__webpack_require__(15)(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};


/***/ }),
/* 43 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(4);
var isObject = __webpack_require__(7);
var newPromiseCapability = __webpack_require__(29);

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__(1)('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(78), __esModule: true };

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ICACRO = exports.$ELM = undefined;

var _isInteger = __webpack_require__(84);

var _isInteger2 = _interopRequireDefault(_isInteger);

var _keys = __webpack_require__(88);

var _keys2 = _interopRequireDefault(_keys);

var _assign = __webpack_require__(30);

var _assign2 = _interopRequireDefault(_assign);

var _from = __webpack_require__(48);

var _from2 = _interopRequireDefault(_from);

var _toConsumableArray2 = __webpack_require__(95);

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _slicedToArray2 = __webpack_require__(49);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _storage = __webpack_require__(118);

var _storage2 = _interopRequireDefault(_storage);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var reservedElements = ['div', 'body', 'head', 'img', 'style', 'span', 'ul', 'li', 'input', 'button', 'h1', 'h2', 'h3', 'h4', 'a', 'p', 'strong', 'svg']; /*
                                                                                                                                                          eslint no-param-reassign: [
                                                                                                                                                            "error", { "props": true, "ignorePropertyModificationsFor": ["element"] }
                                                                                                                                                          ]
                                                                                                                                                          */
/* eslint no-use-before-define: ["error", { "functions": false }] */
/* eslint-env es6 */

var GetElement = function GetElement(selector) {
  return document.querySelector(selector);
};

var $ELM_ELEMENT = function $ELM_ELEMENT(element) {
  var rect = function rect(arg) {
    return element.getBoundingClientRect()[arg];
  };
  return {
    attr: function attr() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (element) {
        var _ref = args.length === 2 ? [].concat((0, _toConsumableArray3.default)(args)) : args[0].split(':'),
            _ref2 = (0, _slicedToArray3.default)(_ref, 2),
            attr = _ref2[0],
            value = _ref2[1];

        if (value) {
          element.setAttribute(attr, value);
          return this;
        }
        return element.getAttribute(attr);
      }
      throw new Error(args + ' Element does not exist! Function \'attr\'');
    },
    height: function height() {
      return rect('height');
    },
    click: function click(callback) {
      if (element) {
        element.addEventListener('click', callback);
        return this;
      }
      throw new Error(callback + ' Element does not exist! Function \'click\'');
    },
    html: function html(str) {
      if (element) {
        if (!str) return element.innerHTML;
        element.innerHTML = str;
        return this;
      }
      throw new Error(str + ' Element does not exist! Function \'html\'');
    },
    text: function text(str) {
      if (element) {
        if (!str) return element.innerText || element.textContent;
        element.innerHTML = '';
        element.appendChild(document.createTextNode(str));
        return this;
      }
      throw new Error(str + ' Element does not exist! Function \'text\'');
    },
    image: function image(src) {
      if (element) {
        element.src = src;
        return this;
      }
      throw new Error(src + ' Element does not exist! Function \'image\'');
    },
    href: function href(url) {
      if (element) {
        element.href = url;
        return this;
      }
      throw new Error(url + ' Element does not exist! Function \'href\'');
    },
    appendFirst: function appendFirst(child) {
      var c = child.nodeType ? child : child.element;
      if (element) {
        element.insertBefore(c, element.childNodes[0]);
        return this;
      }
      throw new Error(child + ' Element does not exist! Function \'append\'');
    },
    append: function append(child) {
      var c = child.nodeType ? child : child.element;
      if (element) {
        element.appendChild(c);
        return this;
      }
      throw new Error(child + ' Element does not exist! Function \'append\'');
    },
    appendAll: function appendAll() {
      for (var _len2 = arguments.length, childs = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        childs[_key2] = arguments[_key2];
      }

      return childs.map(this.append);
    },
    css: function css(cn) {
      if (cn) {
        cn.split(' ').join(',').split(',').forEach(function (c) {
          return c && element && element.classList.add(c.replace(/\./g, '').trim());
        });
      }
      return this;
    },
    toggle: function toggle(cn) {
      if (cn) {
        element.classList.toggle(cn);
      }
      return this;
    },
    get: function get() {
      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      if (element) {
        if (args.length === 1) return $ELM_ELEMENT(element.querySelector(args[0]));
        return args.map(function (arg) {
          return $ELM_ELEMENT(element.querySelector(arg));
        });
      }
      throw new Error(args + ' Element does not exist! Function \'get\'');
    },
    children: function children(arg) {
      if (arg) {
        var _list = (0, _from2.default)(element.getElementsByTagName(arg));
        return _list.map(function (child) {
          return $ELM_ELEMENT(child);
        });
      }
      var list = (0, _from2.default)(element.childNodes);
      return list.map(function (child) {
        return $ELM_ELEMENT(child);
      });
    },
    style: function style(stl) {
      if (element) {
        (0, _assign2.default)(element.style, stl);
        return this;
      }
      throw new Error(stl + ' Element does not exist! Function \'style\'');
    },
    data: function data(key, value) {
      if (element) {
        element.dataset[key] = value;
        return this;
      }
      throw new Error(key + ' ' + value + ' Element does not exist! Function \'data\'');
    },

    element: element
  };
};

var CreateElement = function CreateElement(arg) {
  if (arg instanceof HTMLElement) return $ELM_ELEMENT(arg);
  var arr = arg.split(' ');
  var type = arr.reduce(function (acc, current) {
    if (reservedElements.includes(current)) {
      return current;
    }
    return acc;
  }, 'div');

  var classNames = arr.filter(function (current) {
    return !reservedElements.includes(current);
  }).join();
  var dom = document.createElement(type);
  return $ELM_ELEMENT(dom).css(classNames);
};

var CreateElementByObject = function CreateElementByObject(type, iterable) {
  var element = CreateElement(type);
  (0, _keys2.default)(iterable).forEach(function (item) {
    var func = element[item];
    if (func) {
      var value = iterable[item];
      if (value && value.length) {
        func(value);
      }
    }
  });
  return element;
};

var $ELM = exports.$ELM = {
  elms: {},
  create: function create() {
    for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }

    if (args.length === 1) return CreateElement(args[0]);
    return args.map(function (arg) {
      return CreateElement(arg);
    });
  },
  build: function build(type, iterable) {
    return CreateElementByObject(type, iterable);
  },
  get: function get() {
    var _this = this;

    for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }

    if (args.length === 1) {
      var key = (0, _isInteger2.default)(parseInt(args[0], 10)) ? parseInt(args[0], 10) : args[0];
      return this.elms[key] || $ELM_ELEMENT(GetElement(key));
    }
    return args.map(function (arg) {
      var key = (0, _isInteger2.default)(parseInt(arg, 10)) ? parseInt(arg, 10) : arg;
      return _this.elms[key] || $ELM_ELEMENT(GetElement(key));
    });
  },
  save: function save(id, element) {
    this.elms[id] = this.elms[id] || {};
    this.elms[id] = element;
  },
  copy: function copy(selector) {
    var child = GetElement(selector);
    if (child) {
      return CreateElement(child.cloneNode(true));
    }
    throw new Error(selector + ' Element does not exist! Function \'copy\'');
  }
};

var ICACRO = exports.ICACRO = function ICACRO() {
  $ELM.get('body').css('cro');
  return {
    getElementContentByTagAndAttr: function getElementContentByTagAndAttr(regexp, tag, attr) {
      var qsa = document.querySelectorAll(tag);
      return this.toArray(qsa).reduce(function (acc, element) {
        if (new RegExp(regexp).test(element[attr])) {
          acc.push(element[attr]);
        }
        return acc;
      }, []);
    },
    removeElements: function removeElements(classNames) {
      classNames.forEach(function (className) {
        var elm = document.querySelector(className);
        if (elm instanceof HTMLElement) elm.parentNode.removeChild(elm);
      });
    },
    toArray: function toArray(list) {
      return Array.prototype.slice.call(list);
    },
    load: function load() {
      for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }

      var _args = (0, _slicedToArray3.default)(args, 2),
          url = _args[0],
          options = _args[1];

      var ops = (0, _assign2.default)({}, { method: 'get' }, options);
      return fetch(url, ops).then(function (response) {
        return response.json();
      }).catch(function (err) {
        return err;
      });
    },
    style: function style(styles) {
      console.log('style is deprecated... use css and require.');
      var style = $ELM.create('style');
      style.attr('type', 'text/css');
      style.append(document.createTextNode(styles));
      $ELM.get('head').append(style);
    },
    isLoggedIn: function isLoggedIn() {
      return $ELM.get('#hdnIcaState').attr('value').length > 1;
    },
    gaPush: function gaPush(_ref3) {
      var _ref3$eventCategory = _ref3.eventCategory,
          eventCategory = _ref3$eventCategory === undefined ? 'A/B' : _ref3$eventCategory,
          eventAction = _ref3.eventAction,
          eventLabel = _ref3.eventLabel;

      if (ga) {
        ga('send', 'event', eventCategory, eventAction, eventLabel);
      }
    },

    storage: {
      set: function set(key, value) {
        _storage2.default.set(key, value);
      },
      get: function get(key) {
        return _storage2.default.get(key);
      },
      remove: function remove(key) {
        _storage2.default.remove(key);
      }
    }
  };
};

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(92), __esModule: true };

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _isIterable2 = __webpack_require__(96);

var _isIterable3 = _interopRequireDefault(_isIterable2);

var _getIterator2 = __webpack_require__(99);

var _getIterator3 = _interopRequireDefault(_getIterator2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if ((0, _isIterable3.default)(Object(arr))) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

/***/ }),
/* 50 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getElement = (function (fn) {
	var memo = {};

	return function(selector) {
		if (typeof memo[selector] === "undefined") {
			var styleTarget = fn.call(this, selector);
			// Special case to return head of iframe instead of iframe itself
			if (styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[selector] = styleTarget;
		}
		return memo[selector]
	};
})(function (target) {
	return document.querySelector(target)
});

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(115);

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton) options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
	if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertInto + " " + options.insertAt.before);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	options.attrs.type = "text/css";

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _promise = __webpack_require__(31);

var _promise2 = _interopRequireDefault(_promise);

var _stringify = __webpack_require__(46);

var _stringify2 = _interopRequireDefault(_stringify);

var _assign = __webpack_require__(30);

var _assign2 = _interopRequireDefault(_assign);

var _slicedToArray2 = __webpack_require__(49);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _main = __webpack_require__(47);

var _ratings = __webpack_require__(102);

var _ratings2 = _interopRequireDefault(_ratings);

var _banners = __webpack_require__(103);

var _banners2 = _interopRequireDefault(_banners);

var _coupons = __webpack_require__(104);

var _coupons2 = _interopRequireDefault(_coupons);

__webpack_require__(116);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(function ($) {
  'use strict';

  var LOGIN_ACTION = {
    SAVE_RECIPE: 'SPARA',
    LOAD_COUPON: 'LADDA'
  };
  var ACTION_COOKIES = {
    SAVE_RECIPE: 'cro_startpage_actionCookie_saveRecipe',
    LOAD_COUPON: 'cro_startpage_actionCookie_loadCoupon'
  };
  var loadedCoupons = [];

  // if (hj) hj('trigger','variant5');// eslint-disable-line
  var test = {
    create: function create(className, parent, text, type) {
      var t = type || 'div';
      var div = document.createElement(t);
      if (text && type === 'img') {
        div.src = text;
      } else if (text) {
        div.appendChild(document.createTextNode(text));
      }
      if (className) div.className = className;
      if (parent) parent.appendChild(div);
      return div;
    },
    addCoupon: function addCoupon(coupon) {
      var _this = this;

      var couponItem = _main.$ELM.create('coupons-container__item');
      var img = _main.$ELM.create('img');
      var wrapper = _main.$ELM.create('coupons-container__item-wrapper');
      var imageWrapper = _main.$ELM.create('coupons-container__item-image-wrapper');
      var title = _main.$ELM.create('h3');
      var discount = _main.$ELM.create('h1');
      var subtitle = _main.$ELM.create('h4');
      var moreInfo = _main.$ELM.create('a');
      var button = _main.$ELM.create('button .button coupon-button');

      title.text(coupon.title);
      discount.text(coupon.discount);
      subtitle.text(coupon.subtitle);
      moreInfo.text('Mer info');
      button.text('Ladda kupong');
      img.image(coupon.image);
      moreInfo.href(coupon.url);

      button.click(function () {
        if (_this.isLoggedIn()) {
          _this.loadCouponOnCard(coupon).then(function (response) {
            _this.changeOfferStatus(response, coupon);
          });
        } else {
          icadatalayer.add('HSE', {
            HSE: {
              action: 'login-mousedown',
              name: coupon.PageName,
              hseurl: coupon.url
            }
          });

          var cookieData = {
            PageName: coupon.PageName,
            recipeId: coupon.recipeId,
            title: coupon.PageName,
            url: coupon.PageName,
            OfferId: coupon.Offer,
            CampaignId: coupon.PageName
          };

          _this.setActionCookie(ACTION_COOKIES.LOAD_COUPON, cookieData);
          _this.createModal(LOGIN_ACTION.LOAD_COUPON);
        }
      });

      icadatalayer.add('HSE', {
        HSE: {
          action: 'display',
          title: coupon.PageName,
          hseurl: coupon.url
        }
      });
      couponItem.attr('id', 'coupon-' + coupon.OfferId + '-' + coupon.recipeId);
      this.loadCouponData(coupon).then(function (data) {
        if (data.Offer.LoadedOnCard) {
          couponItem.css('offer-loaded');
          button.text('Kupong laddad');
        }
      });
      imageWrapper.append(img);
      wrapper.appendAll(title, discount, subtitle, moreInfo);
      couponItem.appendAll(imageWrapper, wrapper, button);
      return couponItem;
    },
    addBanner: function addBanner(banner) {
      var _this2 = this;

      var _$ELM$create = _main.$ELM.create('li banner-container', 'banner-container__img', 'img', 'banner-container__text-container', 'a text-container__link', 'h1 text-container__title', 'text-container__ratings', 'h4 text-container__difficulty', 'coupons-container'),
          _$ELM$create2 = (0, _slicedToArray3.default)(_$ELM$create, 9),
          bannerContainer = _$ELM$create2[0],
          bannerContainerImg = _$ELM$create2[1],
          img = _$ELM$create2[2],
          textContainer = _$ELM$create2[3],
          link = _$ELM$create2[4],
          title = _$ELM$create2[5],
          ratings = _$ELM$create2[6],
          difficulty = _$ELM$create2[7],
          couponsWrapper = _$ELM$create2[8];

      var saveButton = this.createSaveRecipeCTA(banner);

      img.image(banner.image);
      bannerContainerImg.append(img);
      bannerContainerImg.image(banner.image);

      ratings.html((0, _ratings2.default)(banner.stars));
      title.text(banner.title);
      difficulty.text(banner.cookTime);

      banner.coupons.forEach(function (coupon) {
        couponsWrapper.append(_this2.addCoupon(coupon));
      });

      link.href(banner.url);
      link.appendAll(title, ratings, difficulty);
      textContainer.append(link);
      bannerContainer.appendAll(bannerContainerImg, textContainer, saveButton, couponsWrapper);
      return bannerContainer;
    },
    addStyle: function addStyle(element, stl) {
      (0, _assign2.default)(element.style, stl);
    },
    addBanners: function addBanners() {
      var _this3 = this;

      var header = _main.$ELM.get('.header');
      var ul = _main.$ELM.create('ul cro-slider');
      header.html(' ');
      _banners2.default.forEach(function (banner) {
        ul.append(_this3.addBanner(banner));
      });
      header.append(ul);
      $('.cro-slider').slick({
        adaptiveHeight: true
      });
    },
    addIcaCard: function addIcaCard() {
      var self = this;
      var icaImageContainer = self.create('ica-card-container');
      self.create('', icaImageContainer, 'Få rabatt med ICA-Kort', 'h1');
      var usps = self.create('usp-list', icaImageContainer, null, 'ul');
      usps.innerHTML = '\n      <li><svg viewBox="0 0 32 32" width="15px" height="15px"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="/Assets/icons/sprite.svg#check"></use></svg> ICA-kort med bonus</li>\n      <li><svg viewBox="0 0 32 32" width="15px" height="15px"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="/Assets/icons/sprite.svg#check"></use></svg> Personliga erbjudanden</li>\n      <li><svg viewBox="0 0 32 32" width="15px" height="15px"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="/Assets/icons/sprite.svg#check"></use></svg> Kortpriser varje vecka</li>\n      ';
      self.create('', icaImageContainer, 'https://www.ica.se/ImageVaultFiles/id_78649/cf_3/ICA_Kort_och_Bank.png', 'img');
      self.create('button', icaImageContainer, 'Skapa konto och bli medlem', 'a').href = '/ansokan/?step=6369766963666f726d';
      document.querySelector('.main').appendChild(icaImageContainer);
    },
    dinnerTonight: function dinnerTonight() {
      var container = _main.$ELM.get('.search-recipe-container');
      this.removeElements(['.recipe-trending-list h2']);
      container.get('h1').text('Vad är du sugen på?');
    },
    manipulateDom: function manipulateDom() {
      this.removeElements(['.image-slider li', '.image-slider .lazy-spinner', '.header-content', '.push-items-list', '.quicklink-list', '.main .link-list', '.recipe-category-listing .banner-image', '.recipe-category-listing > .col-12 > h2', '.search-recipe-container__recipe-count', '.recipe-category-listing .recipe-list-items']);
      this.addBanners();
      this.createOffers();
      this.addIcaCard();
      this.dinnerTonight();
      var returnUrl = encodeURIComponent(window.location.href);
      var iframeContainer = $('<div class="cro-iframe-container"><span class="loader"></span><iframe src="//www.ica.se/logga-in/?returnurl=' + returnUrl + '" frameborder="0"></iframe></div>');
      $('body').append(iframeContainer);
    },
    createSaveRecipeCTA: function createSaveRecipeCTA(banner) {
      var _this4 = this;

      var container = _main.$ELM.create('button-wrapper');
      var cta = _main.$ELM.create('a .button banner-button');
      cta.html('<div class="layer"><svg viewBox="0 0 32 32" width="15px" height="15px"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="/Assets/icons/sprite.svg#check"></use></svg></div>Lägg recept i inköpslistan');
      cta.href('#');
      cta.data('recipeId', banner.recipeId);
      cta.data('tracking', '{ "name": "' + banner.title + '", "URL": "' + banner.url + '" }');
      cta.css('js-add-to-new-shoppinglist banner-button-' + banner.recipeId);

      cta.click(function (e) {
        e.preventDefault();
        _this4.addRecipeToShoppingList(banner.recipeId);
        cta.toggle('added');
        _main.$ELM.get('#js-toggle-avatar').css('cro-startpage-shoppinglist-coachmark');
        setTimeout(function () {
          return cta.toggle('added');
        }, 1500);
      });
      container.append(cta);
      return container;
    },
    createOffers: function createOffers() {
      var main = _main.$ELM.get('.main');
      var container = _main.$ELM.create('div coupon-banner');
      container.click(function () {
        window.location.href = '/erbjudanden/butikserbjudanden/alla-digitala-kuponger/';
      });
      var offerButton = _main.$ELM.create('a .button offers-button').text('Gå till ICAs kuponger').href('/erbjudanden/butikserbjudanden/alla-digitala-kuponger/');
      var img = _main.$ELM.create('img').image('https://raw.githubusercontent.com/Banzaci/ica/master/src/start-page/Coupons_image.png');
      container.appendAll(img, offerButton);
      main.append(container);
    },
    addRecipeToShoppingList: function addRecipeToShoppingList(recipeId) {
      // tracking sker via klassnamn

      ICA.ajax.post('/Templates/Recipes/Handlers/ShoppingListHandler.ashx', {
        recipeIds: [recipeId],
        ShoppingListId: 0,
        numberOfServings: 0,
        recipes: [],
        shoppingListName: createShoppingsListName()
      });

      function createShoppingsListName() {
        var d = new Date();
        var year = d.getFullYear();
        var month = d.getMonth();
        var day = d.getDate();
        var months = { 10: 'nov', 11: 'dec' }; // testet kommer endast ligga ute i nov, senast dec

        return 'Att handla, ' + day + ' ' + months[month] + ' ' + year;
      }
    },
    setActionCookie: function setActionCookie(cookieName, cookieData) {
      // TODO: Flytta till main.js
      var d = new Date();
      d.setDate(new Date().getDate() + 1); // expires tomorrow

      ICA.legacy.setCookie(cookieName, (0, _stringify2.default)(cookieData), d);
    },
    getActionCookie: function getActionCookie(cookieName) {
      // TODO: Flytta till main.js
      var actionCookie = ICA.legacy.getCookie(cookieName);

      if (!actionCookie) {
        return null;
      }

      ICA.legacy.killCookie(cookieName);
      return JSON.parse(actionCookie);
    },
    checkActionCookies: function checkActionCookies() {
      var _this5 = this;

      if (!this.isLoggedIn) return;

      var coupon = this.getActionCookie(ACTION_COOKIES.LOAD_COUPON);
      if (coupon) {
        this.loadCouponOnCard(coupon).then(function (response) {
          _this5.changeOfferStatus(response, coupon);
        });
      }
    },
    changeOfferStatus: function changeOfferStatus(response, coupon) {
      if (response.ok) {
        _main.$ELM.get('#coupon-' + coupon.OfferId + '-' + coupon.recipeId).css('offer-loaded');
        _main.$ELM.get('#coupon-' + coupon.OfferId + '-' + coupon.recipeId + ' .coupon-button').text('Kupong laddad');
      }
    },

    // hotjarTriggered: false,
    loaderIsActive: false,
    buttonHandlerPollTimeout: null,
    showLoader: function showLoader() {
      var container = $('.cro-iframe-container');
      container.find('.loader').show();
      container.find('iframe').css('opacity', '0');
      this.loaderIsActive = true;
    },
    hideLoader: function hideLoader() {
      var container = $('.cro-iframe-container');
      container.find('.loader').hide();
      container.find('iframe').css('opacity', '1');
      this.loaderIsActive = false;
    },
    addButtonHandlerPoll: function addButtonHandlerPoll() {
      var self = this;
      var iframe = $('.cro-iframe-container iframe');
      var e = iframe.contents().find('.remodal-wrapper #grey-card-btn, .remodal-wrapper .pink-card-btn');

      if (e.length) {
        e.click(function () {
          self.showLoader();
        });
        window.clearTimeout(self.buttonHandlerPollTimeout);
      } else {
        self.buttonHandlerPollTimeout = window.setTimeout(self.addButtonHandlerPoll.bind(self), 1000);
      }
    },
    addEventListeners: function addEventListeners() {
      var self = this;

      $('.header').off('mousedown');

      $(window).on('message onmessage', function (e) {
        var origin = window.location.protocol + '//' + window.location.host;
        if (e.originalEvent.origin === origin && /mobilebankid/i.test(e.originalEvent.data)) {
          self.showLoader();
        }
      });
    },
    getIframeStyles: function getIframeStyles() {
      return '<style type="text/css">\n        @media  (max-width: 767px) {\n        h3.greeting, h3.card-heading { font-size: 18px; }\n        img.card-icon { width: 50px; }\n        .select-card-modal { border: 0; padding: 0; margin: 0; }\n        .remodal-wrapper { padding: 0; }\n        }\n        </style>';
    },
    createModal: function createModal() {
      var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : LOGIN_ACTION.SAVE_RECIPE;

      var self = this;
      var modal = new coreComponents.modal({
        tpl: $('.cro-iframe-container').get(0),
        size: 'md',
        container: $('.modal-container').get(0)
      });

      setTimeout(function () {
        self.showLoader();

        var iframe = $('.cro-iframe-container iframe');

        iframe.on('load', function () {
          var regex = new RegExp('^' + window.location.href + '$', 'gi');
          if (regex.test(this.contentWindow.location)) {
            window.location.reload(true);
          }

          if (this.contentWindow.location.href.indexOf('logga-in') !== -1) {
            var _hideHeaderBar = function _hideHeaderBar() {
              var e = $('.cro-iframe-container iframe').contents().find('.header-bar');
              if (e.length) {
                e.hide();
                window.clearTimeout(headerBarTimeout);
                hideHeaderBarDeferred.resolve();
              } else {
                headerBarTimeout = window.setTimeout(_hideHeaderBar, 0);
              }
            };

            var _appendHeader = function _appendHeader() {
              var e = $('.cro-iframe-container iframe').contents().find('h1');
              if (e.length) {
                var message = action === LOGIN_ACTION.SAVE_RECIPE ? ' för att lägga till i inköpslistan och spara recept' : ' för att ladda kupongen';
                e.append(message);
                e.css({ 'font-family': 'icahand, arial, sans-serif', 'font-size': '3rem' });

                if (window.screen.width < 768) {
                  e.css('font-size', '18px');
                  e.parent().css('margin', '0');
                }
                window.clearTimeout(appendHeaderTimeout);
                appendHeaderDeferred.resolve();
              } else {
                appendHeaderTimeout = window.setTimeout(_appendHeader, 0);
              }
            };

            var _addStyles = function _addStyles() {
              var e = $('.cro-iframe-container iframe').contents().find('body');
              if (e.length) {
                e.append(self.getIframeStyles());
                window.clearTimeout(addStylesTimeout);
                addStylesDeferred.resolve();
              } else {
                addStylesTimeout = window.setTimeout(_addStyles, 0);
              }
            };

            var _addIframeTracking = function _addIframeTracking() {
              var e = $('.cro-iframe-container iframe').contents();
              if (e.length) {
                var eventAction = action === LOGIN_ACTION.SAVE_RECIPE ? 'Spara recept från startsidan' : 'Ladda kupong från startsida';

                // Fortsätt (Mobilt BankId)
                e.find('#submit-login-mobile-bank-id').on('click', function () {
                  ga('send', 'event', 'A/B', eventAction, 'Logga in - Mobilt BankId');
                });

                // Behöver du hjälp (Mobilt BankId)
                e.find('.login-support-bank-id-link').on('click', function () {
                  ga('send', 'event', 'A/B', eventAction, 'Behöver du hjälp');
                });

                // Skapa konto (Mobilt BankId)
                e.find('.get-mobile-bank-id-link').on('click', function () {
                  ga('send', 'event', 'A/B', eventAction, 'Skapa konto - Mobilt BankId');
                });

                // Logga in (Lösenord)
                e.find('#log-in-submit').on('click', function () {
                  ga('send', 'event', 'A/B', eventAction, 'Logga in - Lösenord');
                });

                // Glömt lösenord (Lösenord)
                e.find('.login-support-password-link').on('click', function () {
                  ga('send', 'event', 'A/B', eventAction, 'Glömt lösenord');
                });

                // Skapa konto (Lösenord)
                e.find('.create-account-link').on('click', function () {
                  ga('send', 'event', 'A/B', eventAction, 'Skapa konto - Lösenord');
                });

                window.clearTimeout(addIframeTrackingTimeout);
                addIframeTrackingDeferred.resolve();
              } else {
                addIframeTrackingTimeout = window.setTimeout(_addIframeTracking, 0);
              }
            };

            var headerBarTimeout = window.setTimeout(_hideHeaderBar, 10);
            var appendHeaderTimeout = window.setTimeout(_appendHeader, 10);
            var addStylesTimeout = window.setTimeout(_addStyles, 10);
            var addIframeTrackingTimeout = window.setTimeout(_addIframeTracking, 10);
            var hideHeaderBarDeferred = $.Deferred();
            var appendHeaderDeferred = $.Deferred();
            var addStylesDeferred = $.Deferred();
            var addIframeTrackingDeferred = $.Deferred();

            $.when(hideHeaderBarDeferred, appendHeaderDeferred, addStylesDeferred, addIframeTrackingDeferred).done(function () {
              self.hideLoader();
            });
          }

          $('.cro-iframe-container iframe').contents().find('form').on('submit', function () {
            if (!$(this).find('input.error').length) {
              self.showLoader();
            }
          });

          $('.cro-iframe-container iframe').contents().find('#submit-login-mobile-bank-id').on('click', function () {
            if (!$(this).find('input.error').length) {
              self.buttonHandlerPollTimeout = setTimeout(self.addButtonHandlerPoll.bind(self), 1000);
            }
          });

          $('.cro-iframe-container iframe').contents().find('a[href*="www.ica.se"]').each(function () {
            $(this).attr('href', $(this).attr('href').replace('http://', 'https://'));
          }).click(function (e) {
            window.location.href = $(this).attr('href');
            e.preventDefault();
          });
        });

        // trigga hotjar heatmap första gången modalen öppnats
        // if (typeof hj === 'function' && !self.hotjarTriggered) {
        //     hj('trigger', 'variant');
        //     self.hotjarTriggered = true;
        // }
      }, 50);
    },
    loadCouponData: function loadCouponData(coupon) {
      return loadedCoupons[coupon.OfferId] ? _promise2.default.resolve(loadedCoupons[coupon.OfferId]) : window.fetch('/api/jsonhse/' + coupon.id, { credentials: 'same-origin' }).then(function (response) {
        return response.json();
      }).then(function (json) {
        loadedCoupons[coupon.OfferId] = json;
        return json;
      });
    },
    loadCouponOnCard: function loadCouponOnCard(coupon) {
      var opts = {
        OfferId: coupon.OfferId,
        CampaignId: coupon.CampaignId,
        StoreId: 0,
        StoreGroupId: 0
      };

      return window.fetch('/api/jsonhse/Claimoffer', {
        credentials: 'same-origin',
        method: 'POST',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        body: (0, _stringify2.default)(opts)
      }).then(function (response) {
        if (response.ok) {
          icadatalayer.add('HSE', {
            HSE: {
              action: 'coupon-loaded',
              name: coupon.PageName,
              offer: coupon.title,
              hseurl: coupon.url
            }
          });
        }
        return response;
      });
    },
    resetParallaxScrolling: function resetParallaxScrolling() {
      ICA.icaCallbacks.$parallaxContainers = $('.parallax');
    }
  };

  $(document).ready(function () {
    var IC = (0, _main.ICACRO)();
    if (/^https:\/\/www.ica.se\/$/.test(window.location)) {
      (0, _assign2.default)(test, IC);
      test.checkActionCookies();
      test.manipulateDom();
      test.addEventListeners();
      test.resetParallaxScrolling();
    }
    if (/^https:\/\/www.ica.se\/erbjudanden\/butikserbjudanden\/alla-digitala-kuponger\/$/.test(window.location)) {
      _coupons2.default.manipulateDom(IC, function () {
        test.createModal(LOGIN_ACTION.LOAD_COUPON);
      });
    }
  });
})(jQuery); /* eslint no-inner-declarations: "off" */
/* eslint no-use-before-define: "off" */

// ==UserScript==
// @name         Start-page
// @path         //./src/start-page/variant.js
// @namespace    http://tampermonkey.net/
// @version      0.1
// @match        https://www.ica.se/*
// @grant        none
// ==/UserScript==

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(54);
__webpack_require__(11);
__webpack_require__(26);
__webpack_require__(69);
__webpack_require__(76);
__webpack_require__(77);
module.exports = __webpack_require__(0).Promise;


/***/ }),
/* 54 */
/***/ (function(module, exports) {



/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(17);
var defined = __webpack_require__(18);
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(8) && !__webpack_require__(13)(function () {
  return Object.defineProperty(__webpack_require__(19)('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(7);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(5);


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__(60);
var descriptor = __webpack_require__(20);
var setToStringTag = __webpack_require__(25);
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(5)(IteratorPrototype, __webpack_require__(1)('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(4);
var dPs = __webpack_require__(61);
var enumBugKeys = __webpack_require__(37);
var IE_PROTO = __webpack_require__(24)('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(19)('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(38).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(6);
var anObject = __webpack_require__(4);
var getKeys = __webpack_require__(21);

module.exports = __webpack_require__(8) ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(14);
var toIObject = __webpack_require__(22);
var arrayIndexOf = __webpack_require__(63)(false);
var IE_PROTO = __webpack_require__(24)('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(22);
var toLength = __webpack_require__(23);
var toAbsoluteIndex = __webpack_require__(64);
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(17);
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(14);
var toObject = __webpack_require__(16);
var IE_PROTO = __webpack_require__(24)('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(67);
var step = __webpack_require__(68);
var Iterators = __webpack_require__(9);
var toIObject = __webpack_require__(22);

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(32)(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),
/* 67 */
/***/ (function(module, exports) {

module.exports = function () { /* empty */ };


/***/ }),
/* 68 */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(33);
var global = __webpack_require__(2);
var ctx = __webpack_require__(10);
var classof = __webpack_require__(27);
var $export = __webpack_require__(3);
var isObject = __webpack_require__(7);
var aFunction = __webpack_require__(12);
var anInstance = __webpack_require__(70);
var forOf = __webpack_require__(71);
var speciesConstructor = __webpack_require__(41);
var task = __webpack_require__(42).set;
var microtask = __webpack_require__(73)();
var newPromiseCapabilityModule = __webpack_require__(29);
var perform = __webpack_require__(43);
var promiseResolve = __webpack_require__(44);
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[__webpack_require__(1)('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value);
            if (domain) domain.exit();
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  if (promise._h == 1) return false;
  var chain = promise._a || promise._c;
  var i = 0;
  var reaction;
  while (chain.length > i) {
    reaction = chain[i++];
    if (reaction.fail || !isUnhandled(reaction.promise)) return false;
  } return true;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = __webpack_require__(74)($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
__webpack_require__(25)($Promise, PROMISE);
__webpack_require__(75)(PROMISE);
Wrapper = __webpack_require__(0)[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(45)(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});


/***/ }),
/* 70 */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(10);
var call = __webpack_require__(39);
var isArrayIter = __webpack_require__(40);
var anObject = __webpack_require__(4);
var toLength = __webpack_require__(23);
var getIterFn = __webpack_require__(28);
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;


/***/ }),
/* 72 */
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var macrotask = __webpack_require__(42).set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__(15)(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver
  } else if (Observer) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    var promise = Promise.resolve();
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

var hide = __webpack_require__(5);
module.exports = function (target, src, safe) {
  for (var key in src) {
    if (safe && target[key]) target[key] = src[key];
    else hide(target, key, src[key]);
  } return target;
};


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(2);
var core = __webpack_require__(0);
var dP = __webpack_require__(6);
var DESCRIPTORS = __webpack_require__(8);
var SPECIES = __webpack_require__(1)('species');

module.exports = function (KEY) {
  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// https://github.com/tc39/proposal-promise-finally

var $export = __webpack_require__(3);
var core = __webpack_require__(0);
var global = __webpack_require__(2);
var speciesConstructor = __webpack_require__(41);
var promiseResolve = __webpack_require__(44);

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-promise-try
var $export = __webpack_require__(3);
var newPromiseCapability = __webpack_require__(29);
var perform = __webpack_require__(43);

$export($export.S, 'Promise', { 'try': function (callbackfn) {
  var promiseCapability = newPromiseCapability.f(this);
  var result = perform(callbackfn);
  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
  return promiseCapability.promise;
} });


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(0);
var $JSON = core.JSON || (core.JSON = { stringify: JSON.stringify });
module.exports = function stringify(it) { // eslint-disable-line no-unused-vars
  return $JSON.stringify.apply($JSON, arguments);
};


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(80);
module.exports = __webpack_require__(0).Object.assign;


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(3);

$export($export.S + $export.F, 'Object', { assign: __webpack_require__(81) });


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = __webpack_require__(21);
var gOPS = __webpack_require__(82);
var pIE = __webpack_require__(83);
var toObject = __webpack_require__(16);
var IObject = __webpack_require__(34);
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__(13)(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;


/***/ }),
/* 82 */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),
/* 83 */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(85), __esModule: true };

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(86);
module.exports = __webpack_require__(0).Number.isInteger;


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var $export = __webpack_require__(3);

$export($export.S, 'Number', { isInteger: __webpack_require__(87) });


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var isObject = __webpack_require__(7);
var floor = Math.floor;
module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(89), __esModule: true };

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(90);
module.exports = __webpack_require__(0).Object.keys;


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__(16);
var $keys = __webpack_require__(21);

__webpack_require__(91)('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(3);
var core = __webpack_require__(0);
var fails = __webpack_require__(13);
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(11);
__webpack_require__(93);
module.exports = __webpack_require__(0).Array.from;


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ctx = __webpack_require__(10);
var $export = __webpack_require__(3);
var toObject = __webpack_require__(16);
var call = __webpack_require__(39);
var isArrayIter = __webpack_require__(40);
var toLength = __webpack_require__(23);
var createProperty = __webpack_require__(94);
var getIterFn = __webpack_require__(28);

$export($export.S + $export.F * !__webpack_require__(45)(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $defineProperty = __webpack_require__(6);
var createDesc = __webpack_require__(20);

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _from = __webpack_require__(48);

var _from2 = _interopRequireDefault(_from);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  } else {
    return (0, _from2.default)(arr);
  }
};

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(97), __esModule: true };

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(26);
__webpack_require__(11);
module.exports = __webpack_require__(98);


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(27);
var ITERATOR = __webpack_require__(1)('iterator');
var Iterators = __webpack_require__(9);
module.exports = __webpack_require__(0).isIterable = function (it) {
  var O = Object(it);
  return O[ITERATOR] !== undefined
    || '@@iterator' in O
    // eslint-disable-next-line no-prototype-builtins
    || Iterators.hasOwnProperty(classof(O));
};


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(100), __esModule: true };

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(26);
__webpack_require__(11);
module.exports = __webpack_require__(101);


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(4);
var get = __webpack_require__(28);
module.exports = __webpack_require__(0).getIterator = function (it) {
  var iterFn = get(it);
  if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');
  return anObject(iterFn.call(it));
};


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (stars) {
  var arr = ['0', '26', '52', '78', '104'];
  var strs = arr.map(function (x, index) {
    return '<g transform="translate(' + x + ' 0)" class="' + (index < stars ? 'active' : '') + '">\n      <path d="M23.2 10.303q.194.509-.073.97-1.188 2.182-5.067 5.479 1.018 4.194 1.212 6.715.049.679-.533 1.067-.315.194-.63.194-.242 0-.533-.121-.412-.242-1.333-.679-3.273-1.624-4.606-2.473-1.333.849-4.606 2.473-.921.436-1.333.679-.606.315-1.164-.073-.582-.388-.533-1.067.194-2.521 1.212-6.715-3.879-3.297-5.067-5.479-.267-.461-.073-.97.17-.509.63-.679 1.358-.606 6.861-.8 1.988-5.77 3.248-7.03.388-.339.824-.339.461 0 .8.339 1.285 1.261 3.273 7.03 5.503.194 6.861.8.461.194.63.679z"></path>\n      </g>';
  });
  return '<svg xmlns="http://www.w3.org/2000/svg" viewBox="-0.12099626660346985 1.4550001621246338 127.39400121569633 25.34600469470024">\n  <linearGradient id="half" x1="0" x2="100%" y1="0" y2="0">\n  <stop offset="50%" stop-color="currentColor"></stop>\n  <stop offset="50%" stop-color="#d5d7da"></stop>\n  </linearGradient>\n  ' + strs.join('') + '\n  </svg>';
};

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = [{
  recipeId: 718382,
  title: 'Lasagne med halloumi, spenat och pumpakärnor',
  stars: 4,
  cookTime: '60 MIN | MEDEL',
  image: 'https://www.ica.se/imagevaultfiles/id_106734/cf_259/lasagne-med-halloumi-spenat-och-pumpakarnor-718382.png',
  url: 'https://www.ica.se/recept/lasagne-med-halloumi-spenat-och-pumpakarnor-718382/',
  coupons: [{
    id: 458278,
    recipeId: 718382,
    title: 'Bönpasta/ lasagneplattor',
    image: 'https://www.ica.se/Handlers/Image.ashx?w=150&h=150&m=p&bgr=fff&u=http://extbild.ica.se//PictureWeb/80/1030/14_1000555309.jpg',
    discount: '20% rabatt',
    subtitle: 'Risenta 120-200 g',
    url: '/kampanj/hse/458278',
    PageName: 'LSR 1030 Bönpasta/lasagneplattor',
    OfferId: 1000555309,
    CampaignId: 1030
  }, {
    id: 458276,
    recipeId: 718382,
    title: 'Buljongkuber',
    image: 'https://www.ica.se/Handlers/Image.ashx?w=150&h=150&m=p&bgr=fff&u=http://extbild.ica.se//PictureWeb/80/1028/14_1000555307.jpg',
    discount: '25% rabatt',
    subtitle: 'Knorr 6-pack',
    url: '/kampanj/hse/458276',
    PageName: 'LSR 1028 Buljong',
    OfferId: 1000555307,
    CampaignId: 1028
  }]
}, {
  recipeId: 722803,
  title: 'Pasta med falafel och ärtpesto',
  stars: 3,
  cookTime: '45 MIN | MEDEL',
  image: 'https://www.ica.se/imagevaultfiles/id_168851/cf_259/pasta-med-falafel-artpesto-722803-700x654.jpg',
  url: 'https://www.ica.se/recept/pasta-med-falafel-och-artpesto-722803/',
  coupons: [{
    id: 458280,
    recipeId: 722803,
    title: 'Falafel',
    image: 'https://www.ica.se/Handlers/Image.ashx?w=150&h=150&m=p&bgr=fff&u=http://extbild.ica.se//PictureWeb/80/1031/14_1000555310.jpg',
    discount: '5 kr rabatt',
    subtitle: 'Findus 450 g',
    url: '/kampanj/hse/458280',
    PageName: 'LSR 1031 Falafel',
    OfferId: 1000555310,
    CampaignId: 1031
  }, {
    id: 458277,
    recipeId: 722803,
    title: 'iMat',
    image: 'https://www.ica.se/Handlers/Image.ashx?w=150&h=150&m=p&bgr=fff&u=http://extbild.ica.se//PictureWeb/80/1029/14_1000555308.jpg',
    discount: '15% rabatt',
    subtitle: 'Oatly 250 g',
    url: '/kampanj/hse/458277',
    PageName: 'LSR 1029 iMat',
    OfferId: 1000555308,
    CampaignId: 1029
  }]
}, {
  recipeId: 722867,
  title: 'Fryst cheesecake med saffran',
  stars: 4,
  cookTime: '1-4 TIM | MEDEL',
  image: 'https://www.ica.se/imagevaultfiles/id_170800/cf_259/fryst-cheesecake-med-saffran-722867-liten.jpg',
  url: 'https://www.ica.se/recept/fryst-cheesecake-med-saffran-722867/',
  coupons: [{
    id: 458282,
    recipeId: 722867,
    title: 'Färskost',
    image: 'https://www.ica.se/Handlers/Image.ashx?w=150&h=150&m=p&bgr=fff&u=http://extbild.ica.se//PictureWeb/80/1033/14_1000555312.jpg',
    discount: '3 kr rabatt',
    subtitle: 'Philadelphia 175-300 g',
    url: '/kampanj/hse/458282',
    PageName: 'LSR 1033 Färskost Philadelpia',
    OfferId: 1000555312,
    CampaignId: 1033
  }, {
    id: 458274,
    recipeId: 722867,
    title: 'Margarin',
    image: 'https://www.ica.se/Handlers/Image.ashx?w=150&h=150&m=p&bgr=fff&u=http://extbild.ica.se//PictureWeb/80/1026/14_1000555305.jpg',
    discount: '5 kr rabatt',
    subtitle: 'Milda 1 kg',
    url: '/kampanj/hse/458274',
    PageName: 'LSR 1026 Margarin',
    OfferId: 1000555305,
    CampaignId: 1026
  }]
}, {
  recipeId: 719374,
  title: 'Torsk i ugn med dill- och citronsås',
  stars: 4,
  cookTime: '30 MIN | MEDEL',
  image: 'https://www.ica.se/imagevaultfiles/id_122727/cf_259/torsk-i-ugn-med-dill-och-citronsas-v38-2015-719374.jpg',
  url: 'https://www.ica.se/recept/torsk-i-ugn-med-dill-och-citronsas-719374/',
  coupons: [{
    id: 458288,
    recipeId: 719374,
    title: 'Torskfilé',
    image: 'https://www.ica.se/Handlers/Image.ashx?w=150&h=150&m=p&bgr=fff&u=http://extbild.ica.se//PictureWeb/80/1038/14_1000555317.jpg',
    discount: '25% rabatt',
    subtitle: 'ICA 600 g',
    url: '/kampanj/hse/458288',
    PageName: 'LSR 1038 Torskfilé',
    OfferId: 1000555317,
    CampaignId: 1038
  }, {
    id: 458274,
    recipeId: 719374,
    title: 'Margarin',
    image: 'https://www.ica.se/Handlers/Image.ashx?w=150&h=150&m=p&bgr=fff&u=http://extbild.ica.se//PictureWeb/80/1026/14_1000555305.jpg',
    discount: '5 kr rabatt',
    subtitle: 'Milda 1 kg',
    url: '/kampanj/hse/458274',
    PageName: 'LSR 1026 Margarin',
    OfferId: 1000555305,
    CampaignId: 1026
  }]
}, {
  recipeId: 721310,
  title: 'Glutenfri saffranskaka',
  stars: 4,
  cookTime: '1-4 TIM | MEDEL',
  image: 'https://www.ica.se/imagevaultfiles/id_150397/cf_259/glutenfri-saffranskaka-721310-liten.jpg',
  url: 'https://www.ica.se/recept/glutenfri-saffranskaka-721310/',
  coupons: [{
    id: 458298,
    recipeId: 721310,
    title: 'Mandelmassa',
    image: 'https://www.ica.se/Handlers/Image.ashx?w=150&h=150&m=p&bgr=fff&u=http://extbild.ica.se//PictureWeb/80/1044/14_1000555323.jpg',
    discount: '25 % rabatt',
    subtitle: 'ICA 200 g',
    url: '/kampanj/hse/458298',
    PageName: 'LSR 1044 Mandelmassa',
    OfferId: 1000555323,
    CampaignId: 1044
  }, {
    id: 458274,
    recipeId: 721310,
    title: 'Margarin',
    image: 'https://www.ica.se/Handlers/Image.ashx?w=150&h=150&m=p&bgr=fff&u=http://extbild.ica.se//PictureWeb/80/1026/14_1000555305.jpg',
    discount: '5 kr rabatt',
    subtitle: 'Milda 1 kg',
    url: '/kampanj/hse/458274',
    PageName: 'LSR 1026 Margarin',
    OfferId: 1000555305,
    CampaignId: 1026
  }]
}, {
  recipeId: 722922,
  title: 'Mozartkulor',
  stars: 5,
  cookTime: '30 MIN | MEDEL',
  image: 'https://www.ica.se/imagevaultfiles/id_172499/cf_259/mozartkulor-722922-580x580.jpg',
  url: 'https://www.ica.se/recept/mozartkulor-722922/',
  coupons: [{
    id: 458298,
    recipeId: 722922,
    title: 'Mandelmassa',
    image: 'https://www.ica.se/Handlers/Image.ashx?w=150&h=150&m=p&bgr=fff&u=http://extbild.ica.se//PictureWeb/80/1044/14_1000555323.jpg',
    discount: '25 % rabatt',
    subtitle: 'ICA 200 g',
    url: '/kampanj/hse/458298',
    PageName: 'LSR 1044 Mandelmassa',
    OfferId: 1000555323,
    CampaignId: 1044
  }, {
    id: 458297,
    recipeId: 722922,
    title: 'Baknougat',
    image: 'https://www.ica.se/Handlers/Image.ashx?w=150&h=150&m=p&bgr=fff&u=http://extbild.ica.se//PictureWeb/80/1043/14_1000555322.jpg',
    discount: '5 kr rabatt',
    subtitle: 'ICA 250 g',
    url: '/kampanj/hse/458297',
    PageName: 'LSR 1043 Baknougat',
    OfferId: 1000555322,
    CampaignId: 1043
  }]
}];

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = __webpack_require__(30);

var _assign2 = _interopRequireDefault(_assign);

var _regenerator = __webpack_require__(109);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _stringify = __webpack_require__(46);

var _stringify2 = _interopRequireDefault(_stringify);

var _asyncToGenerator2 = __webpack_require__(112);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _slicedToArray2 = __webpack_require__(49);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _main = __webpack_require__(47);

__webpack_require__(113);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var coupons = {
  printBanner: function printBanner(content, _ref) {
    var _this = this;

    var title = _ref.title,
        discount = _ref.discount,
        preamble = _ref.preamble,
        url = _ref.url,
        img = _ref.img,
        isUsed = _ref.isUsed,
        id = _ref.id,
        data = _ref.data;

    var isUsedClass = isUsed ? ' is-used' : '';

    var _$ELM$create = _main.$ELM.create('banner', 'banner-row', 'banner-column', 'banner-column grow-one', 'banner-column', 'banner-column__image', 'h1', 'span', 'p', 'img', 'a', 'button .button download ' + isUsedClass),
        _$ELM$create2 = (0, _slicedToArray3.default)(_$ELM$create, 12),
        bannerElement = _$ELM$create2[0],
        bannerRow = _$ELM$create2[1],
        bannerColumn1 = _$ELM$create2[2],
        bannerColumn2 = _$ELM$create2[3],
        bannerColumn3 = _$ELM$create2[4],
        imgElement = _$ELM$create2[5],
        titleElement = _$ELM$create2[6],
        discountElement = _$ELM$create2[7],
        preambleElement = _$ELM$create2[8],
        imgHolder = _$ELM$create2[9],
        readMore = _$ELM$create2[10],
        downLoad = _$ELM$create2[11];

    var buttonText = isUsed ? 'Kupong laddad' : 'Ladda kupong';

    imgHolder.image(img);
    imgElement.append(imgHolder);

    readMore.href('/kampanj/hse/' + id).text('Läs mer');
    downLoad.href(url).text(buttonText);

    titleElement.html(title);
    discountElement.html(discount);
    preambleElement.html(preamble);

    bannerColumn1.append(imgElement);
    bannerColumn2.appendAll(titleElement, discountElement, preambleElement, readMore);
    bannerColumn3.append(downLoad);

    bannerRow.appendAll(bannerColumn1, bannerColumn2, bannerColumn3);
    bannerElement.append(bannerRow);
    content.append(bannerElement);

    downLoad.click(function (event) {
      return _this.onClick(event, data);
    });
    _main.$ELM.save(id, bannerElement);

    icadatalayer.add('HSE', {
      HSE: {
        action: 'display',
        title: data.PageName,
        hseurl: '/kampanj/hse/' + id
      }
    });
  },
  loadCouponOnCard: function () {
    var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(data) {
      return _regenerator2.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.load('/api/jsonhse/Claimoffer', {
                credentials: 'same-origin',
                method: 'POST',
                headers: {
                  Accept: 'application/json',
                  'Content-Type': 'application/json'
                },
                body: (0, _stringify2.default)(data)
              });

            case 2:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function loadCouponOnCard(_x) {
      return _ref2.apply(this, arguments);
    }

    return loadCouponOnCard;
  }(),
  checkActionCookie: function checkActionCookie() {
    var coupon = this.storage.get('coupon');
    if (coupon && this.isLoggedIn()) {
      this.storage.remove('coupon');
      this.loadCouponOnCard(coupon);
    }
  },
  deactivateCoupon: function deactivateCoupon(id) {
    _main.$ELM.get(id).get('button').css('is-used');
  },
  onClick: function () {
    var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(event, data) {
      return _regenerator2.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              event.preventDefault();

              if (!this.isLoggedIn()) {
                _context2.next = 8;
                break;
              }

              this.deactivateCoupon(data.id);
              _context2.next = 5;
              return this.loadCouponOnCard(data);

            case 5:
              icadatalayer.add('HSE', {
                HSE: {
                  action: 'coupon-loaded',
                  name: data.PageName,
                  offer: data.ProductName,
                  hseurl: '/kampanj/hse/' + data.id
                }
              });
              _context2.next = 11;
              break;

            case 8:
              icadatalayer.add('HSE', {
                HSE: {
                  action: 'login-mousedown',
                  name: data.PageName,
                  hseurl: '/kampanj/hse/' + data.id
                }
              });
              this.storage.set('coupon', data);
              this.createModal();

            case 11:
            case 'end':
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function onClick(_x2, _x3) {
      return _ref3.apply(this, arguments);
    }

    return onClick;
  }(),
  loadBanners: function loadBanners(ids, content) {
    var _this2 = this;

    ids.forEach(function (id) {
      _this2.load('https://www.ica.se/api/jsonhse/' + id, { credentials: 'same-origin' }).then(function (response) {
        var PageName = response.PageName,
            Header = response.Header,
            Offer = response.Offer,
            CampaignId = response.CampaignId,
            StoreGroupId = response.StoreGroupId,
            StoreId = response.StoreId;
        var ProductName = Offer.ProductName,
            LoadedOnCard = Offer.LoadedOnCard,
            OfferCondition = Offer.OfferCondition,
            Brand = Offer.Brand,
            SizeOrQuantity = Offer.SizeOrQuantity,
            OfferId = Offer.OfferId;


        var data = {
          id: id,
          CampaignId: CampaignId,
          ProductName: ProductName,
          PageName: PageName,
          OfferId: OfferId,
          StoreId: StoreId,
          StoreGroupId: StoreGroupId
        };
        _this2.printBanner(content, {
          data: data,
          id: id,
          isUsed: LoadedOnCard,
          title: Header,
          discount: OfferCondition.Conditions[0],
          preamble: Brand + ' ' + SizeOrQuantity.Text,
          url: '',
          img: Offer.Image.ImageUrl
        });
      });
    });
  },
  addIframe: function addIframe() {
    var returnUrl = encodeURIComponent(window.location.href);
    var iframe = _main.$ELM.create('cro-iframe-container');
    var iframeContainer = '<span class="loader"></span><iframe src="//www.ica.se/logga-in/?returnurl=' + returnUrl + '" frameborder="0"></iframe>';
    iframe.html(iframeContainer);
    _main.$ELM.get('body').append(iframe);
  },
  manipulateDom: function manipulateDom(ICACRO, createModal) {
    (0, _assign2.default)(this, ICACRO, { createModal: createModal });
    var content = _main.$ELM.get('#content');
    var regexp = /www.ica.se\/kampanj\/hse/g;
    var banners = this.getElementContentByTagAndAttr(regexp, 'a', 'href');
    var ids = banners.map(function (banner) {
      return banner.match(/\d+$/)[0];
    });
    this.addIframe();
    content.html(' ');
    this.loadBanners(ids, content);
    this.checkActionCookie();
  }
};

exports.default = coupons;

/***/ }),
/* 105 */,
/* 106 */,
/* 107 */,
/* 108 */,
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(110);


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g = (function() { return this })() || Function("return this")();

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = __webpack_require__(111);

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}


/***/ }),
/* 111 */
/***/ (function(module, exports) {

/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  (function() { return this })() || Function("return this")()
);


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _promise = __webpack_require__(31);

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (fn) {
  return function () {
    var gen = fn.apply(this, arguments);
    return new _promise2.default(function (resolve, reject) {
      function step(key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }

        if (info.done) {
          resolve(value);
        } else {
          return _promise2.default.resolve(value).then(function (value) {
            step("next", value);
          }, function (err) {
            step("throw", err);
          });
        }
      }

      return step("next");
    });
  };
};

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(114);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {"hmr":true}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(51)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../node_modules/css-loader/index.js!./coupons-style.css", function() {
			var newContent = require("!!../../node_modules/css-loader/index.js!./coupons-style.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(50)(undefined);
// imports


// module
exports.push([module.i, ".cro .grow-one { flex-grow: 1; }\r\n.cro .banner { display:flex; background-color: #F8EBF3; margin-bottom: 10px; }\r\n.cro .banner.is-used { background-color: rgba(247,247,247,1); }\r\n.cro .banner-row {\r\ndisplay:flex;\r\nwidth:100%;\r\nalign-items: center;\r\nbackground-color: white;\r\nmargin: 10px 15px;\r\nposition: relative;\r\n}\r\n.cro .banner-row::after {\r\nbackground:url(\"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIxLjAuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCAxMCAyMCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgMTAgMjA7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCS5zdDB7ZmlsbDojRjhFQkYzO30KPC9zdHlsZT4KPHBhdGggY2xhc3M9InN0MCIgZD0iTTIuNDk3MDIxLDkuOTg4ODA3YzAsNC4xNDIxNTEsMy4zNTc4NDksNy41MDAwMDEsNy41LDcuNTAwMDAxdi0xNQoJQzUuODU0ODcsMi40ODg4MDcsMi40OTcwMjEsNS44NDY2NTYsMi40OTcwMjEsOS45ODg4MDd6Ii8+Cjwvc3ZnPgo=\") space;\r\nbackground-size: 13px 26px;\r\nbottom: 0;\r\ncontent: '';\r\ndisplay: block;\r\nheight: 100%;\r\nposition: absolute;\r\nright: 0;\r\ntop: 0;\r\nwidth: 13px;\r\n}\r\n.cro .banner .banner-column:first-child { margin-left: 10px; }\r\n.cro .banner .banner-column:last-child {  margin-right: 10px; }\r\n.cro .banner .banner-column { padding: 10px; }\r\n.cro .banner .banner-column .download {\r\n  font-size: 12px;\r\n  align-items: center;\r\n  background: #F8EBF3;\r\n  font-weight: bold;\r\n  color: rgba(160,41,113,1);\r\n  cursor: pointer;\r\n  display: flex;\r\n  flex-direction: column;\r\n  justify-content: center;\r\n  margin: 10px 10px 10px 0;\r\n  border-radius: 6rem;\r\n  width: 100px;\r\n  line-height: 1.4rem;\r\n  padding-bottom: 10px;\r\n}\r\n.cro .banner .banner-column .download.is-used {\r\n  background: #DDE9BF;\r\n  color: #8DB72C;\r\n  pointer-events: none;\r\n  transition: width .2s ease, color .2s 250ms ease, background .2s ease\r\n}\r\n.cro .banner .banner-column h1 { font-size: 1.6rem; word-break: break-all;}\r\n.cro .banner .banner-column span {\r\n  color: #EB1F07;\r\n  font-family: icarubrik;\r\n  font-size: 2.2rem;\r\n  font-weight: bold;\r\n}\r\n.cro .banner .banner-column p {\r\n  color: #808283;\r\n  font-size: 1.3rem;\r\n  margin: 0;\r\n}\r\n/*rgba(141,183,44,1)*/\r\n.cro .banner .banner-column h1.is-used,\r\n.cro .banner .banner-column span.is-used,\r\n.cro .banner .banner-column p.is-used { color: #D5D7DA; }\r\n.cro .banner .banner-column .banner-column__more-info { font-size: 20px; }\r\n.cro .banner-column__image {\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  text-align: center;\r\n  width: 150px;\r\n  height: 150px;\r\n}\r\n.cro .banner-column__image img {\r\n  max-width: 100%;\r\n  max-height: 100%;\r\n  width: auto;\r\n  height: auto;\r\n}\r\n.cro .banner-column__image img.is-used {\r\n  opacity: .3;\r\n}\r\n@media only screen and (max-width: 780px){\r\n  .cro .banner-column__image {\r\n    width: 65px;\r\n    height: 65px;\r\n  }\r\n  #page {\r\n    padding: 0 5px 5px;\r\n  }\r\n  .cro .banner .banner-column:first-child { padding: 10px; margin-left: 0; }\r\n  .cro .banner .banner-column:last-child { padding: 10px 10px 10px 0; margin-right: 0; }\r\n  .cro .banner .banner-column { padding: 10px 0; }\r\n}\r\n", ""]);

// exports


/***/ }),
/* 115 */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(117);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {"hmr":true}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(51)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../node_modules/css-loader/index.js!./style.css", function() {
			var newContent = require("!!../../node_modules/css-loader/index.js!./style.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(50)(undefined);
// imports


// module
exports.push([module.i, "/*.cro header .image-slider {\r\n  position: absolute !important;\r\n}*/\r\n\r\n/*\r\nbackground-position: -338px -1885px; prev\r\n\r\n\r\nbackground-position: -438px -1885px;\r\n */\r\n\r\n.cro #header {\r\n  background-color: white;\r\n}\r\n\r\n.slick-slide, .slick-track:focus {\r\n  outline: none;\r\n}\r\n.start-page-icase #header {\r\n  height: 100%;\r\n}\r\n.coupon-banner {\r\n  text-align: center;\r\n  margin-bottom: 30px;\r\n  background-color: #F5E9F0;\r\n}\r\n.coupon-banner img {\r\n  margin: 10px 0 0;\r\n}\r\n\r\n.cro .search-recipe-container img {\r\n  margin-bottom: 20px;\r\n}\r\n.cro .search-recipe-container h1, .coupon-banner h1 {\r\n  font-size: 2.8rem;\r\n}\r\n.cro .search-recipe-container__all-recipes {\r\n  font-size: 1.5rem;\r\n}\r\n.cro .pl .container-backdrop {\r\n  padding: 20px 10px 30px;\r\n}\r\n\r\n.slick-prev:before, .slick-next:before { content: '' }\r\n.slick-prev {\r\n  top: 170px;\r\n  left: -10px;\r\n  background-position: -338px -1885px;\r\n  width: 40px !important;\r\n  height: 40px !important;\r\n}\r\n.slick-next {\r\n  top: 170px;\r\n  right: 5px;\r\n  background-position: -438px -1885px;\r\n  width: 40px !important;\r\n  height: 40px !important;\r\n}\r\n\r\n.cro .slick-prev:hover,\r\n.cro .slick-prev:focus,\r\n.cro .slick-prev:active {\r\n  background-color: transparent;\r\n  background-position: -338px -1885px;\r\n}\r\n.cro .slick-next:hover,\r\n.cro .slick-next:focus,\r\n.cro .slick-next:active {\r\n  background-color: transparent;\r\n  background-position: -438px -1885px;\r\n}\r\n.cro .slick-arrow {\r\n  background-color: transparent;\r\n  background-image: url('/Templates/General/Views/Images/RWD/sprites/general_sprite1.png?1');\r\n  background-repeat: no-repeat;\r\n}\r\nbutton:focus, button:active {outline:0;}\r\n.slick-initialized .slick-slider {\r\n  outline: none;\r\n}\r\n.cro .banner-container {\r\n  width: 100%;\r\n  height: 100%;\r\n  background-color: white;\r\n  z-index: 20 !important;\r\n  display: inline-block;\r\n}\r\n\r\n.cro .banner-container__img {\r\n  width: inherit;\r\n  height: 320px;\r\n  position: absolute;\r\n  top: 0;\r\n  overflow: hidden;\r\n  background-color: black;\r\n}\r\n\r\n.cro .banner-container__img img { height: auto; width: 100%; opacity: .8; }\r\n\r\n.cro .banner-container__text-container {\r\n  max-width: 100%;\r\n  margin: 70px 35px 10px;\r\n  text-shadow: 0 0 5px rgba(0, 0, 0, 0.4);\r\n  position: relative;\r\n}\r\n\r\n.cro .text-container__title {\r\n  font-size: 36px;\r\n  color: white;\r\n  font-family: icarubrik;\r\n  font-weight: 600;\r\n  line-height: 3rem;\r\n  white-space: normal;\r\n}\r\n\r\n.cro .text-container__ratings svg .active {\r\n  fill: #EB1F07;\r\n}\r\n\r\n.cro .text-container__ratings svg {\r\n  /*display: inline-block;*/\r\n  display: block;\r\n  fill: #D5D7DA;\r\n  height: 18px;\r\n  vertical-align: middle;\r\n  width: 91px;\r\n  -webkit-filter: drop-shadow( 1px 1px 2px rgba(0,0,0,0.4) );\r\n  filter: drop-shadow( 1px 1px 2px rgba(0,0,0,0.4) );\r\n}\r\n\r\n.cro .text-container__difficulty {\r\n  text-transform: uppercase;\r\n  font: 16px icatext;\r\n  font-weight: 900;\r\n  margin-top: 6px;\r\n  color: white;\r\n}\r\n\r\n.cro .coupons-container {\r\n  width: 100%;\r\n  z-index: 999;\r\n  display: flex;\r\n  flex-direction: row;\r\n  padding: 5px;\r\n  /*margin-bottom: 20px;*/\r\n}\r\n\r\n.cro .coupons-container__item {\r\n  background-color: white;\r\n  width: 50%;\r\n  margin: 0 4px;\r\n  padding: 10px;\r\n  border: 8px solid rgba(217,20,99,0.1);\r\n  border-bottom-width: 17px;\r\n  border-radius: 6px;\r\n  display: flex;\r\n  flex-direction: column;\r\n  position: relative;\r\n  justify-content:flex-start;\r\n}\r\n\r\n.cro .recipe-trending-list h2 {\r\n  font-size: 1.8rem;\r\n}\r\n\r\n.cro .coupons-container__item:after {\r\n  background: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMjAgMTAiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDIwIDEwOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+PHN0eWxlIHR5cGU9InRleHQvY3NzIj4uc3Qwe2ZpbGw6I2ZmZjt9PC9zdHlsZT48cGF0aCBjbGFzcz0ic3QwIiBkPSJNMTAsMi41Yy00LjEsMC03LjUsMy40LTcuNSw3LjVoMTVDMTcuNSw1LjksMTQuMiwyLjUsMTAsMi41eiIvPjwvc3ZnPg==) space;\r\n  background-size: 26px 13px;\r\n  content: '';\r\n  display: block;\r\n  width: 140%;\r\n  height: 13px;\r\n  position: absolute;\r\n  bottom: -17px;\r\n  left: -30px;\r\n}\r\n\r\n.cro .coupons-container__item-wrapper {\r\n  align-self: flex-start;\r\n  margin-bottom: 60px;\r\n}\r\n\r\n.coupons-container__item-image-wrapper {\r\n  align-self: flex-start;\r\n}\r\n.cro .coupons-container__item img {\r\n  width: 60% !important;\r\n  height: auto !important;\r\n  margin: 0 auto 10px !important;\r\n}\r\n\r\n.cro .coupons-container .coupons-container__item h3 {\r\n  font-size: 16px;\r\n  line-height: 1em;\r\n  margin-bottom: 6px;\r\n}\r\n\r\n.cro .coupons-container .coupons-container__item h1 {\r\n  font-size: 22px;\r\n  font-weight: 700;\r\n  color: #EB1F07;\r\n  line-height: 1.5rem;\r\n}\r\n\r\n.cro .coupons-container .coupons-container__item h4 {\r\n  color: #808283;\r\n  font-size: 1.3rem;\r\n  line-height: 1.4;\r\n  font-family: icatext;\r\n  font-weight: normal;\r\n}\r\n\r\n.cro .coupons-container .coupons-container__item a {\r\n  font-size: 14px;\r\n  line-height: 15px;\r\n  margin-bottom: 5px;\r\n}\r\n\r\n.cro .coupons-container .coupons-container__item .coupon-button {\r\n  font-size: 12px;\r\n  line-height: 2.2rem;\r\n  min-width: auto;\r\n  align-self: center;\r\n  width: 90%;\r\n  background: #F8EBF3;\r\n  color: #A02971;\r\n  position: absolute;\r\n  bottom: 15px;\r\n}\r\n\r\n.cro .coupons-container .coupons-container__item.offer-loaded .coupon-button {\r\n  background: #DDE9BF;\r\n  color: #8DB72C;\r\n  pointer-events: none;\r\n  transition: width .2s ease, color .2s 250ms ease, background .2s ease;\r\n}\r\n\r\n.cro .coupons-container .coupons-container__item .coupons-image {\r\n  width: 100%;\r\n  height: 60px;\r\n  background-repeat: no-repeat;\r\n  background-size: contain;\r\n  background-position: center;\r\n}\r\n\r\n.cro .banner-wrapper .banner-image img {\r\n  width: 100%;\r\n  position: relative;\r\n  margin-left: 0 !important;\r\n  height: auto !important;\r\n  margin-top: 0 !important;\r\n  min-width: 375px;\r\n}\r\n\r\n.cro .button-wrapper {\r\n  margin: 10px 0 30px 35px;\r\n}\r\n\r\n.cro .banner-button {\r\n  width: 60%;\r\n  display: block;\r\n  overflow: hidden;\r\n}\r\n.cro .banner-button .layer {\r\n  position: absolute;\r\n  top: -30px;\r\n  right: 20%;\r\n  transition: all 0.5s ease;\r\n}\r\n.cro .banner-button.saved {\r\n  background: #DDE9BF;\r\n  color: #8DB72C;\r\n  pointer-events: none;\r\n  transition: width .2s ease, color .2s 250ms ease, background .2s ease;\r\n  font-weight: 400;\r\n}\r\n\r\n.cro .banner-button.added .layer{\r\n  top: 0;\r\n}\r\n\r\n.cro .offers-button {\r\n  width: 90%;\r\n  margin-bottom: 20px;\r\n}\r\n\r\n.cro .rating-star-container {\r\n  position: absolute;\r\n  z-index: 50;\r\n  margin:10px;\r\n  top: 30px;\r\n  color: white;\r\n  text-shadow: 0 0 5px rgba(0, 0, 0, 0.4);\r\n}\r\n\r\n.cro .ica-card-container {\r\n  display: flex;\r\n  flex-direction: column;\r\n  min-height: 250px;\r\n}\r\n\r\n.cro .ica-card-container h1 {\r\n  color: #EB1F07;\r\n}\r\n\r\n.cro .ica-card-container a {\r\n  align-self: flex-start;\r\n  max-width: 250px;\r\n  margin-top:-160px;\r\n}\r\n\r\n.cro .ica-card-container img {\r\n  max-width: 385px;\r\n  width: 80%;\r\n  align-self: flex-end;\r\n  margin-top:-120px;\r\n}\r\n\r\n@media only screen and (max-width: 960px){\r\n  .cro .ica-card-container {\r\n    min-height: none;\r\n  }\r\n\r\n  .cro .ica-card-container h1 {\r\n    line-height: 3rem;\r\n    font-size: 3rem;\r\n    margin-bottom: 20px;\r\n  }\r\n\r\n  .cro .ica-card-container a {\r\n    align-self: center;\r\n    margin-top: 20px;\r\n    max-width: none;\r\n    width: 100%;\r\n  }\r\n\r\n  .cro .ica-card-container img {\r\n    align-self: center;\r\n    margin-top:auto;\r\n  }\r\n\r\n  .cro .offers-container {\r\n    width: 100%;\r\n    background-color: white;\r\n    -webkit-filter: drop-shadow( 1px 1px 2px rgba(0,0,0,0.4) );\r\n    filter: drop-shadow( 1px 1px 2px rgba(0,0,0,0.4) );\r\n  }\r\n\r\n  .start-page-icase > header.full-size-image .image-slider,\r\n  .start-page-icase > header.full-size-image .image-slider ul,\r\n  .start-page-icase > header.full-size-image .image-slider li {\r\n    max-height: 100%;\r\n    width: 100% !important;\r\n    height: 100% !important;\r\n  }\r\n}\r\n.cro .unslider-controls { pointer-events: none; }\r\n.cro .unslider-arrow { pointer-events: auto; }\r\n\r\n@media (max-width: 767px) { .cro .cro-iframe-container { padding-bottom: 135% !important; } }\r\n.cro > .cro-iframe-container { display: none; }\r\n.cro .modal-copntainer .cro-iframe-container { display: initial; }\r\n.cro .container { text-align: center; margin-top: 50px;}\r\n.cro .container h2 { font: 28px icahand; margin-bottom: 20px; }\r\n.cro .cro-iframe-container {\r\n  position: relative;\r\n  height: 0;\r\n  overflow: hidden;\r\n  padding-bottom: 85%;\r\n  background-color: #F3F0EB;\r\n}\r\n.cro .cro-iframe-container iframe {\r\n  opacity: 0;\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  width: 100%;\r\n  height: 100%;\r\n}\r\n\r\n.cro .usp-list { margin-bottom: 10px; }\r\n\r\n.cro .usp-list li {\r\n  font: 24px icarubrik;\r\n  font-weight: 600;\r\n  margin-bottom: 15px;\r\n}\r\n.cro .usp-list svg {\r\n  fill: #8DB72C;\r\n  margin-right: 5px;\r\n}\r\n", ""]);

// exports


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stringify = __webpack_require__(46);

var _stringify2 = _interopRequireDefault(_stringify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var storage = function storage() {
  var fallBack = {
    storage: {},
    setItem: function setItem(key, value) {
      this.storage[key] = value;
    },
    getItem: function getItem(key) {
      return this.storage[key];
    }
  };
  var chooseStorage = function chooseStorage(typeOfStorage) {
    try {
      if (typeOfStorage in window && window[typeOfStorage] !== null) {
        return window[typeOfStorage];
      }
      return fallBack;
    } catch (e) {
      return false;
    }
  };

  return {
    setUp: function setUp() {
      var typeOfStorage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'sessionStorage';

      var storageType = chooseStorage(typeOfStorage);
      return {
        set: function set(key, value) {
          storageType.setItem(key, (0, _stringify2.default)(value));
        },
        get: function get(key) {
          return JSON.parse(storageType.getItem(key));
        },
        remove: function remove(key) {
          storageType.removeItem(key);
        }
      };
    }
  };
};

var db = storage();
exports.default = db.setUp();

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNTJiYzFkNThmMjU0YjExYjJjMGUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb3JlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4tb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGlkZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlcmF0b3JzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2ZhaWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RlZmluZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWxlbmd0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC1rZXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NsYXNzb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX25ldy1wcm9taXNlLWNhcGFiaWxpdHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvcHJvbWlzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbGlicmFyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lvYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL191aWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faHRtbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY2FsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLWFycmF5LWl0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdGFzay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3BlcmZvcm0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wcm9taXNlLXJlc29sdmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWRldGVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL2pzb24vc3RyaW5naWZ5LmpzIiwid2VicGFjazovLy8uL3NyYy91dGlsL21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9hcnJheS9mcm9tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvc2xpY2VkVG9BcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzIiwid2VicGFjazovLy8uL3NyYy9zdGFydC1wYWdlL3ZhcmlhbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9wcm9taXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc3RyaW5nLWF0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19yZWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tYWJzb2x1dGUtaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ3BvLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLXN0ZXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5wcm9taXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4taW5zdGFuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19mb3Itb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pbnZva2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19taWNyb3Rhc2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19yZWRlZmluZS1hbGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtc3BlY2llcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnByb21pc2UuZmluYWxseS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnByb21pc2UudHJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vanNvbi9zdHJpbmdpZnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1waWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9udW1iZXIvaXMtaW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL251bWJlci9pcy1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYubnVtYmVyLmlzLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2tleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qva2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXNhcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL2FycmF5L2Zyb20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5hcnJheS5mcm9tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3JlYXRlLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9pcy1pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL2lzLWl0ZXJhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmlzLWl0ZXJhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvZ2V0LWl0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vZ2V0LWl0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbC9tb2R1bGVzL3JhdGluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3N0YXJ0LXBhZ2UvYmFubmVycy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc3RhcnQtcGFnZS9jb3Vwb25zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUtbW9kdWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yLmpzIiwid2VicGFjazovLy8uL3NyYy9zdGFydC1wYWdlL2NvdXBvbnMtc3R5bGUuY3NzPzJkMTkiLCJ3ZWJwYWNrOi8vLy4vc3JjL3N0YXJ0LXBhZ2UvY291cG9ucy1zdHlsZS5jc3MiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvdXJscy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc3RhcnQtcGFnZS9zdHlsZS5jc3M/NjQ5MCIsIndlYnBhY2s6Ly8vLi9zcmMvc3RhcnQtcGFnZS9zdHlsZS5jc3MiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWwvbW9kdWxlcy9zdG9yYWdlLmpzIl0sIm5hbWVzIjpbInJlc2VydmVkRWxlbWVudHMiLCJHZXRFbGVtZW50IiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwic2VsZWN0b3IiLCIkRUxNX0VMRU1FTlQiLCJlbGVtZW50IiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImFyZyIsImF0dHIiLCJhcmdzIiwibGVuZ3RoIiwic3BsaXQiLCJ2YWx1ZSIsInNldEF0dHJpYnV0ZSIsImdldEF0dHJpYnV0ZSIsIkVycm9yIiwiaGVpZ2h0IiwiY2xpY2siLCJjYWxsYmFjayIsImFkZEV2ZW50TGlzdGVuZXIiLCJodG1sIiwic3RyIiwiaW5uZXJIVE1MIiwidGV4dCIsImlubmVyVGV4dCIsInRleHRDb250ZW50IiwiYXBwZW5kQ2hpbGQiLCJjcmVhdGVUZXh0Tm9kZSIsImltYWdlIiwic3JjIiwiaHJlZiIsInVybCIsImFwcGVuZEZpcnN0IiwiY2hpbGQiLCJjIiwibm9kZVR5cGUiLCJpbnNlcnRCZWZvcmUiLCJjaGlsZE5vZGVzIiwiYXBwZW5kIiwiYXBwZW5kQWxsIiwiY2hpbGRzIiwibWFwIiwiY3NzIiwiY24iLCJqb2luIiwiZm9yRWFjaCIsImNsYXNzTGlzdCIsImFkZCIsInJlcGxhY2UiLCJ0cmltIiwidG9nZ2xlIiwiZ2V0IiwiY2hpbGRyZW4iLCJsaXN0IiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJzdHlsZSIsInN0bCIsImRhdGEiLCJrZXkiLCJkYXRhc2V0IiwiQ3JlYXRlRWxlbWVudCIsIkhUTUxFbGVtZW50IiwiYXJyIiwidHlwZSIsInJlZHVjZSIsImFjYyIsImN1cnJlbnQiLCJpbmNsdWRlcyIsImNsYXNzTmFtZXMiLCJmaWx0ZXIiLCJkb20iLCJjcmVhdGVFbGVtZW50IiwiQ3JlYXRlRWxlbWVudEJ5T2JqZWN0IiwiaXRlcmFibGUiLCJpdGVtIiwiZnVuYyIsIiRFTE0iLCJlbG1zIiwiY3JlYXRlIiwiYnVpbGQiLCJwYXJzZUludCIsInNhdmUiLCJpZCIsImNvcHkiLCJjbG9uZU5vZGUiLCJJQ0FDUk8iLCJnZXRFbGVtZW50Q29udGVudEJ5VGFnQW5kQXR0ciIsInJlZ2V4cCIsInRhZyIsInFzYSIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJ0b0FycmF5IiwiUmVnRXhwIiwidGVzdCIsInB1c2giLCJyZW1vdmVFbGVtZW50cyIsImNsYXNzTmFtZSIsImVsbSIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsIkFycmF5IiwicHJvdG90eXBlIiwic2xpY2UiLCJjYWxsIiwibG9hZCIsIm9wdGlvbnMiLCJvcHMiLCJtZXRob2QiLCJmZXRjaCIsInRoZW4iLCJyZXNwb25zZSIsImpzb24iLCJjYXRjaCIsImVyciIsInN0eWxlcyIsImNvbnNvbGUiLCJsb2ciLCJpc0xvZ2dlZEluIiwiZ2FQdXNoIiwiZXZlbnRDYXRlZ29yeSIsImV2ZW50QWN0aW9uIiwiZXZlbnRMYWJlbCIsImdhIiwic3RvcmFnZSIsInNldCIsInJlbW92ZSIsIiQiLCJMT0dJTl9BQ1RJT04iLCJTQVZFX1JFQ0lQRSIsIkxPQURfQ09VUE9OIiwiQUNUSU9OX0NPT0tJRVMiLCJsb2FkZWRDb3Vwb25zIiwicGFyZW50IiwidCIsImRpdiIsImFkZENvdXBvbiIsImNvdXBvbiIsImNvdXBvbkl0ZW0iLCJpbWciLCJ3cmFwcGVyIiwiaW1hZ2VXcmFwcGVyIiwidGl0bGUiLCJkaXNjb3VudCIsInN1YnRpdGxlIiwibW9yZUluZm8iLCJidXR0b24iLCJsb2FkQ291cG9uT25DYXJkIiwiY2hhbmdlT2ZmZXJTdGF0dXMiLCJpY2FkYXRhbGF5ZXIiLCJIU0UiLCJhY3Rpb24iLCJuYW1lIiwiUGFnZU5hbWUiLCJoc2V1cmwiLCJjb29raWVEYXRhIiwicmVjaXBlSWQiLCJPZmZlcklkIiwiT2ZmZXIiLCJDYW1wYWlnbklkIiwic2V0QWN0aW9uQ29va2llIiwiY3JlYXRlTW9kYWwiLCJsb2FkQ291cG9uRGF0YSIsIkxvYWRlZE9uQ2FyZCIsImFkZEJhbm5lciIsImJhbm5lciIsImJhbm5lckNvbnRhaW5lciIsImJhbm5lckNvbnRhaW5lckltZyIsInRleHRDb250YWluZXIiLCJsaW5rIiwicmF0aW5ncyIsImRpZmZpY3VsdHkiLCJjb3Vwb25zV3JhcHBlciIsInNhdmVCdXR0b24iLCJjcmVhdGVTYXZlUmVjaXBlQ1RBIiwic3RhcnMiLCJjb29rVGltZSIsImNvdXBvbnMiLCJhZGRTdHlsZSIsImFkZEJhbm5lcnMiLCJoZWFkZXIiLCJ1bCIsInNsaWNrIiwiYWRhcHRpdmVIZWlnaHQiLCJhZGRJY2FDYXJkIiwic2VsZiIsImljYUltYWdlQ29udGFpbmVyIiwidXNwcyIsImRpbm5lclRvbmlnaHQiLCJjb250YWluZXIiLCJtYW5pcHVsYXRlRG9tIiwiY3JlYXRlT2ZmZXJzIiwicmV0dXJuVXJsIiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwid2luZG93IiwibG9jYXRpb24iLCJpZnJhbWVDb250YWluZXIiLCJjdGEiLCJlIiwicHJldmVudERlZmF1bHQiLCJhZGRSZWNpcGVUb1Nob3BwaW5nTGlzdCIsInNldFRpbWVvdXQiLCJtYWluIiwib2ZmZXJCdXR0b24iLCJJQ0EiLCJhamF4IiwicG9zdCIsInJlY2lwZUlkcyIsIlNob3BwaW5nTGlzdElkIiwibnVtYmVyT2ZTZXJ2aW5ncyIsInJlY2lwZXMiLCJzaG9wcGluZ0xpc3ROYW1lIiwiY3JlYXRlU2hvcHBpbmdzTGlzdE5hbWUiLCJkIiwiRGF0ZSIsInllYXIiLCJnZXRGdWxsWWVhciIsIm1vbnRoIiwiZ2V0TW9udGgiLCJkYXkiLCJnZXREYXRlIiwibW9udGhzIiwiY29va2llTmFtZSIsInNldERhdGUiLCJsZWdhY3kiLCJzZXRDb29raWUiLCJnZXRBY3Rpb25Db29raWUiLCJhY3Rpb25Db29raWUiLCJnZXRDb29raWUiLCJraWxsQ29va2llIiwiSlNPTiIsInBhcnNlIiwiY2hlY2tBY3Rpb25Db29raWVzIiwib2siLCJsb2FkZXJJc0FjdGl2ZSIsImJ1dHRvbkhhbmRsZXJQb2xsVGltZW91dCIsInNob3dMb2FkZXIiLCJmaW5kIiwic2hvdyIsImhpZGVMb2FkZXIiLCJoaWRlIiwiYWRkQnV0dG9uSGFuZGxlclBvbGwiLCJpZnJhbWUiLCJjb250ZW50cyIsImNsZWFyVGltZW91dCIsImJpbmQiLCJhZGRFdmVudExpc3RlbmVycyIsIm9mZiIsIm9uIiwib3JpZ2luIiwicHJvdG9jb2wiLCJob3N0Iiwib3JpZ2luYWxFdmVudCIsImdldElmcmFtZVN0eWxlcyIsIm1vZGFsIiwiY29yZUNvbXBvbmVudHMiLCJ0cGwiLCJzaXplIiwicmVnZXgiLCJjb250ZW50V2luZG93IiwicmVsb2FkIiwiaW5kZXhPZiIsImhpZGVIZWFkZXJCYXIiLCJoZWFkZXJCYXJUaW1lb3V0IiwiaGlkZUhlYWRlckJhckRlZmVycmVkIiwicmVzb2x2ZSIsImFwcGVuZEhlYWRlciIsIm1lc3NhZ2UiLCJzY3JlZW4iLCJ3aWR0aCIsImFwcGVuZEhlYWRlclRpbWVvdXQiLCJhcHBlbmRIZWFkZXJEZWZlcnJlZCIsImFkZFN0eWxlcyIsImFkZFN0eWxlc1RpbWVvdXQiLCJhZGRTdHlsZXNEZWZlcnJlZCIsImFkZElmcmFtZVRyYWNraW5nIiwiYWRkSWZyYW1lVHJhY2tpbmdUaW1lb3V0IiwiYWRkSWZyYW1lVHJhY2tpbmdEZWZlcnJlZCIsIkRlZmVycmVkIiwid2hlbiIsImRvbmUiLCJlYWNoIiwiY3JlZGVudGlhbHMiLCJvcHRzIiwiU3RvcmVJZCIsIlN0b3JlR3JvdXBJZCIsImhlYWRlcnMiLCJBY2NlcHQiLCJib2R5Iiwib2ZmZXIiLCJyZXNldFBhcmFsbGF4U2Nyb2xsaW5nIiwiaWNhQ2FsbGJhY2tzIiwiJHBhcmFsbGF4Q29udGFpbmVycyIsInJlYWR5IiwiSUMiLCJqUXVlcnkiLCJzdHJzIiwieCIsImluZGV4IiwicHJpbnRCYW5uZXIiLCJjb250ZW50IiwicHJlYW1ibGUiLCJpc1VzZWQiLCJpc1VzZWRDbGFzcyIsImJhbm5lckVsZW1lbnQiLCJiYW5uZXJSb3ciLCJiYW5uZXJDb2x1bW4xIiwiYmFubmVyQ29sdW1uMiIsImJhbm5lckNvbHVtbjMiLCJpbWdFbGVtZW50IiwidGl0bGVFbGVtZW50IiwiZGlzY291bnRFbGVtZW50IiwicHJlYW1ibGVFbGVtZW50IiwiaW1nSG9sZGVyIiwicmVhZE1vcmUiLCJkb3duTG9hZCIsImJ1dHRvblRleHQiLCJvbkNsaWNrIiwiZXZlbnQiLCJjaGVja0FjdGlvbkNvb2tpZSIsImRlYWN0aXZhdGVDb3Vwb24iLCJQcm9kdWN0TmFtZSIsImxvYWRCYW5uZXJzIiwiaWRzIiwiSGVhZGVyIiwiT2ZmZXJDb25kaXRpb24iLCJCcmFuZCIsIlNpemVPclF1YW50aXR5IiwiQ29uZGl0aW9ucyIsIlRleHQiLCJJbWFnZSIsIkltYWdlVXJsIiwiYWRkSWZyYW1lIiwiYmFubmVycyIsIm1hdGNoIiwiZmFsbEJhY2siLCJzZXRJdGVtIiwiZ2V0SXRlbSIsImNob29zZVN0b3JhZ2UiLCJ0eXBlT2ZTdG9yYWdlIiwic2V0VXAiLCJzdG9yYWdlVHlwZSIsInJlbW92ZUl0ZW0iLCJkYiJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVB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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEOztBQUVBLDZCQUE2QixtQkFBbUI7O0FBRWhEOztBQUVBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaldBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBOzs7O0FBRUEsQ0FBQyxV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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLEtBQUs7QUFDTCxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsa0JBQWtCO0FBQ25E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OEksU0FESyxtQkFDbUM7QUFBQSxVQUFsQ0QsYUFBa0MsdUVBQWxCLGdCQUFrQjs7QUFDdEMsVUFBTUUsY0FBY0gsY0FBY0MsYUFBZCxDQUFwQjtBQUNBLGFBQU87QUFDTHROLFdBREssZUFDRGxFLEdBREMsRUFDSTlDLEtBREosRUFDVztBQUNkd1Usc0JBQVlMLE9BQVosQ0FBb0JyUixHQUFwQixFQUF5Qix5QkFBZTlDLEtBQWYsQ0FBekI7QUFDRCxTQUhJO0FBSUx1QyxXQUpLLGVBSURPLEdBSkMsRUFJSTtBQUNQLGlCQUFPMkssS0FBS0MsS0FBTCxDQUFXOEcsWUFBWUosT0FBWixDQUFvQnRSLEdBQXBCLENBQVgsQ0FBUDtBQUNELFNBTkk7QUFPTG1FLGNBUEssa0JBT0VuRSxHQVBGLEVBT087QUFDVjBSLHNCQUFZQyxVQUFaLENBQXVCM1IsR0FBdkI7QUFDRDtBQVRJLE9BQVA7QUFXRDtBQWRJLEdBQVA7QUFnQkQsQ0FyQ0Q7O0FBdUNBLElBQU00UixLQUFLM04sU0FBWDtrQkFDZTJOLEdBQUdILEtBQUgsRSIsImZpbGUiOiJ2YXJpYW50Lm1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDUyKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCA1MmJjMWQ1OGYyNTRiMTFiMmMwZSIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7IHZlcnNpb246ICcyLjUuMScgfTtcbmlmICh0eXBlb2YgX19lID09ICdudW1iZXInKSBfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29yZS5qc1xuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgc3RvcmUgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnd2tzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG52YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuU3ltYm9sO1xudmFyIFVTRV9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09ICdmdW5jdGlvbic7XG5cbnZhciAkZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9XG4gICAgVVNFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV0gfHwgKFVTRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07XG5cbiRleHBvcnRzLnN0b3JlID0gc3RvcmU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmICh0eXBlb2YgX19nID09ICdudW1iZXInKSBfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbiAodHlwZSwgbmFtZSwgc291cmNlKSB7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GO1xuICB2YXIgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuRztcbiAgdmFyIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlM7XG4gIHZhciBJU19QUk9UTyA9IHR5cGUgJiAkZXhwb3J0LlA7XG4gIHZhciBJU19CSU5EID0gdHlwZSAmICRleHBvcnQuQjtcbiAgdmFyIElTX1dSQVAgPSB0eXBlICYgJGV4cG9ydC5XO1xuICB2YXIgZXhwb3J0cyA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pO1xuICB2YXIgZXhwUHJvdG8gPSBleHBvcnRzW1BST1RPVFlQRV07XG4gIHZhciB0YXJnZXQgPSBJU19HTE9CQUwgPyBnbG9iYWwgOiBJU19TVEFUSUMgPyBnbG9iYWxbbmFtZV0gOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdO1xuICB2YXIga2V5LCBvd24sIG91dDtcbiAgaWYgKElTX0dMT0JBTCkgc291cmNlID0gbmFtZTtcbiAgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICBpZiAob3duICYmIGtleSBpbiBleHBvcnRzKSBjb250aW51ZTtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IG93biA/IHRhcmdldFtrZXldIDogc291cmNlW2tleV07XG4gICAgLy8gcHJldmVudCBnbG9iYWwgcG9sbHV0aW9uIGZvciBuYW1lc3BhY2VzXG4gICAgZXhwb3J0c1trZXldID0gSVNfR0xPQkFMICYmIHR5cGVvZiB0YXJnZXRba2V5XSAhPSAnZnVuY3Rpb24nID8gc291cmNlW2tleV1cbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIDogSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpXG4gICAgLy8gd3JhcCBnbG9iYWwgY29uc3RydWN0b3JzIGZvciBwcmV2ZW50IGNoYW5nZSB0aGVtIGluIGxpYnJhcnlcbiAgICA6IElTX1dSQVAgJiYgdGFyZ2V0W2tleV0gPT0gb3V0ID8gKGZ1bmN0aW9uIChDKSB7XG4gICAgICB2YXIgRiA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgQykge1xuICAgICAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IEMoKTtcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBDKGEpO1xuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IEMoYSwgYik7XG4gICAgICAgICAgfSByZXR1cm4gbmV3IEMoYSwgYiwgYyk7XG4gICAgICAgIH0gcmV0dXJuIEMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgICBGW1BST1RPVFlQRV0gPSBDW1BST1RPVFlQRV07XG4gICAgICByZXR1cm4gRjtcbiAgICAvLyBtYWtlIHN0YXRpYyB2ZXJzaW9ucyBmb3IgcHJvdG90eXBlIG1ldGhvZHNcbiAgICB9KShvdXQpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLm1ldGhvZHMuJU5BTUUlXG4gICAgaWYgKElTX1BST1RPKSB7XG4gICAgICAoZXhwb3J0cy52aXJ0dWFsIHx8IChleHBvcnRzLnZpcnR1YWwgPSB7fSkpW2tleV0gPSBvdXQ7XG4gICAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUucHJvdG90eXBlLiVOQU1FJVxuICAgICAgaWYgKHR5cGUgJiAkZXhwb3J0LlIgJiYgZXhwUHJvdG8gJiYgIWV4cFByb3RvW2tleV0pIGhpZGUoZXhwUHJvdG8sIGtleSwgb3V0KTtcbiAgICB9XG4gIH1cbn07XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG4kZXhwb3J0LlMgPSA0OyAgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgIC8vIHdyYXBcbiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hbi1vYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgZFAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHAuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge307XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlcmF0b3JzLmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCB0aGF0LCBsZW5ndGgpIHtcbiAgYUZ1bmN0aW9uKGZuKTtcbiAgaWYgKHRoYXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZuO1xuICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoLyogLi4uYXJncyAqLykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jdHguanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciAkYXQgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKSh0cnVlKTtcblxuLy8gMjEuMS4zLjI3IFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbiAoaXRlcmF0ZWQpIHtcbiAgdGhpcy5fdCA9IFN0cmluZyhpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuLy8gMjEuMS41LjIuMSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgTyA9IHRoaXMuX3Q7XG4gIHZhciBpbmRleCA9IHRoaXMuX2k7XG4gIHZhciBwb2ludDtcbiAgaWYgKGluZGV4ID49IE8ubGVuZ3RoKSByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIHBvaW50ID0gJGF0KE8sIGluZGV4KTtcbiAgdGhpcy5faSArPSBwb2ludC5sZW5ndGg7XG4gIHJldHVybiB7IHZhbHVlOiBwb2ludCwgZG9uZTogZmFsc2UgfTtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2EtZnVuY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19mYWlscy5qc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oYXMuanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2YuanNcbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLW9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW50ZWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZWZpbmVkLmpzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xuLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG52YXIgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kb20tY3JlYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcbiAgcmV0dXJuICRrZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMuanNcbi8vIG1vZHVsZSBpZCA9IDIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gNy4xLjE1IFRvTGVuZ3RoXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQta2V5LmpzXG4vLyBtb2R1bGUgaWQgPSAyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZGVmID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIHRhZywgc3RhdCkge1xuICBpZiAoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSkgZGVmKGl0LCBUQUcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdGFnIH0pO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qc1xuLy8gbW9kdWxlIGlkID0gMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIFRPX1NUUklOR19UQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxudmFyIERPTUl0ZXJhYmxlcyA9ICgnQ1NTUnVsZUxpc3QsQ1NTU3R5bGVEZWNsYXJhdGlvbixDU1NWYWx1ZUxpc3QsQ2xpZW50UmVjdExpc3QsRE9NUmVjdExpc3QsRE9NU3RyaW5nTGlzdCwnICtcbiAgJ0RPTVRva2VuTGlzdCxEYXRhVHJhbnNmZXJJdGVtTGlzdCxGaWxlTGlzdCxIVE1MQWxsQ29sbGVjdGlvbixIVE1MQ29sbGVjdGlvbixIVE1MRm9ybUVsZW1lbnQsSFRNTFNlbGVjdEVsZW1lbnQsJyArXG4gICdNZWRpYUxpc3QsTWltZVR5cGVBcnJheSxOYW1lZE5vZGVNYXAsTm9kZUxpc3QsUGFpbnRSZXF1ZXN0TGlzdCxQbHVnaW4sUGx1Z2luQXJyYXksU1ZHTGVuZ3RoTGlzdCxTVkdOdW1iZXJMaXN0LCcgK1xuICAnU1ZHUGF0aFNlZ0xpc3QsU1ZHUG9pbnRMaXN0LFNWR1N0cmluZ0xpc3QsU1ZHVHJhbnNmb3JtTGlzdCxTb3VyY2VCdWZmZXJMaXN0LFN0eWxlU2hlZXRMaXN0LFRleHRUcmFja0N1ZUxpc3QsJyArXG4gICdUZXh0VHJhY2tMaXN0LFRvdWNoTGlzdCcpLnNwbGl0KCcsJyk7XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgRE9NSXRlcmFibGVzLmxlbmd0aDsgaSsrKSB7XG4gIHZhciBOQU1FID0gRE9NSXRlcmFibGVzW2ldO1xuICB2YXIgQ29sbGVjdGlvbiA9IGdsb2JhbFtOQU1FXTtcbiAgdmFyIHByb3RvID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgaWYgKHByb3RvICYmICFwcm90b1tUT19TVFJJTkdfVEFHXSkgaGlkZShwcm90bywgVE9fU1RSSU5HX1RBRywgTkFNRSk7XG4gIEl0ZXJhdG9yc1tOQU1FXSA9IEl0ZXJhdG9ycy5BcnJheTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGdldHRpbmcgdGFnIGZyb20gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG4vLyBFUzMgd3JvbmcgaGVyZVxudmFyIEFSRyA9IGNvZihmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTywgVCwgQjtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKFQgPSB0cnlHZXQoTyA9IE9iamVjdChpdCksIFRBRykpID09ICdzdHJpbmcnID8gVFxuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQVJHID8gY29mKE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKEIgPSBjb2YoTykpID09ICdPYmplY3QnICYmIHR5cGVvZiBPLmNhbGxlZSA9PSAnZnVuY3Rpb24nID8gJ0FyZ3VtZW50cycgOiBCO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jbGFzc29mLmpzXG4vLyBtb2R1bGUgaWQgPSAyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb3JlJykuZ2V0SXRlcmF0b3JNZXRob2QgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ICE9IHVuZGVmaW5lZCkgcmV0dXJuIGl0W0lURVJBVE9SXVxuICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cbiAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qc1xuLy8gbW9kdWxlIGlkID0gMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjUuNC4xLjUgTmV3UHJvbWlzZUNhcGFiaWxpdHkoQylcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5cbmZ1bmN0aW9uIFByb21pc2VDYXBhYmlsaXR5KEMpIHtcbiAgdmFyIHJlc29sdmUsIHJlamVjdDtcbiAgdGhpcy5wcm9taXNlID0gbmV3IEMoZnVuY3Rpb24gKCQkcmVzb2x2ZSwgJCRyZWplY3QpIHtcbiAgICBpZiAocmVzb2x2ZSAhPT0gdW5kZWZpbmVkIHx8IHJlamVjdCAhPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoJ0JhZCBQcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgcmVzb2x2ZSA9ICQkcmVzb2x2ZTtcbiAgICByZWplY3QgPSAkJHJlamVjdDtcbiAgfSk7XG4gIHRoaXMucmVzb2x2ZSA9IGFGdW5jdGlvbihyZXNvbHZlKTtcbiAgdGhpcy5yZWplY3QgPSBhRnVuY3Rpb24ocmVqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIChDKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX25ldy1wcm9taXNlLWNhcGFiaWxpdHkuanNcbi8vIG1vZHVsZSBpZCA9IDI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9hc3NpZ24uanNcbi8vIG1vZHVsZSBpZCA9IDMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9wcm9taXNlXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3Byb21pc2UuanNcbi8vIG1vZHVsZSBpZCA9IDMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciAkaXRlckNyZWF0ZSA9IHJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1kgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSk7IC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbnZhciBGRl9JVEVSQVRPUiA9ICdAQGl0ZXJhdG9yJztcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbiAoa2luZCkge1xuICAgIGlmICghQlVHR1kgJiYga2luZCBpbiBwcm90bykgcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVM7XG4gIHZhciBWQUxVRVNfQlVHID0gZmFsc2U7XG4gIHZhciBwcm90byA9IEJhc2UucHJvdG90eXBlO1xuICB2YXIgJG5hdGl2ZSA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXTtcbiAgdmFyICRkZWZhdWx0ID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVCk7XG4gIHZhciAkZW50cmllcyA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWQ7XG4gIHZhciAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZTtcbiAgdmFyIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYgKCRhbnlOYXRpdmUpIHtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSgpKSk7XG4gICAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZiAoIUxJQlJBUlkgJiYgIWhhcyhJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IpKSBoaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUykge1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZiAoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpIHtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddID0gcmV0dXJuVGhpcztcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoa2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIGlmICghKGtleSBpbiBwcm90bykpIHJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1kZWZpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gdHJ1ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19saWJyYXJ5LmpzXG4vLyBtb2R1bGUgaWQgPSAzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gY29mKGl0KSA9PSAnU3RyaW5nJyA/IGl0LnNwbGl0KCcnKSA6IE9iamVjdChpdCk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lvYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHt9KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLmpzXG4vLyBtb2R1bGUgaWQgPSAzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaWQgPSAwO1xudmFyIHB4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL191aWQuanNcbi8vIG1vZHVsZSBpZCA9IDM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gKFxuICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJ1xuKS5zcGxpdCgnLCcpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0tYnVnLWtleXMuanNcbi8vIG1vZHVsZSBpZCA9IDM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xubW9kdWxlLmV4cG9ydHMgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faHRtbC5qc1xuLy8gbW9kdWxlIGlkID0gMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYXRvciwgZm4sIHZhbHVlLCBlbnRyaWVzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVudHJpZXMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSBhbk9iamVjdChyZXQuY2FsbChpdGVyYXRvcikpO1xuICAgIHRocm93IGU7XG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1jYWxsLmpzXG4vLyBtb2R1bGUgaWQgPSAzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvW0lURVJBVE9SXSA9PT0gaXQpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyA3LjMuMjAgU3BlY2llc0NvbnN0cnVjdG9yKE8sIGRlZmF1bHRDb25zdHJ1Y3RvcilcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIEQpIHtcbiAgdmFyIEMgPSBhbk9iamVjdChPKS5jb25zdHJ1Y3RvcjtcbiAgdmFyIFM7XG4gIHJldHVybiBDID09PSB1bmRlZmluZWQgfHwgKFMgPSBhbk9iamVjdChDKVtTUEVDSUVTXSkgPT0gdW5kZWZpbmVkID8gRCA6IGFGdW5jdGlvbihTKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc3BlY2llcy1jb25zdHJ1Y3Rvci5qc1xuLy8gbW9kdWxlIGlkID0gNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGludm9rZSA9IHJlcXVpcmUoJy4vX2ludm9rZScpO1xudmFyIGh0bWwgPSByZXF1aXJlKCcuL19odG1sJyk7XG52YXIgY2VsID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciBzZXRUYXNrID0gZ2xvYmFsLnNldEltbWVkaWF0ZTtcbnZhciBjbGVhclRhc2sgPSBnbG9iYWwuY2xlYXJJbW1lZGlhdGU7XG52YXIgTWVzc2FnZUNoYW5uZWwgPSBnbG9iYWwuTWVzc2FnZUNoYW5uZWw7XG52YXIgRGlzcGF0Y2ggPSBnbG9iYWwuRGlzcGF0Y2g7XG52YXIgY291bnRlciA9IDA7XG52YXIgcXVldWUgPSB7fTtcbnZhciBPTlJFQURZU1RBVEVDSEFOR0UgPSAnb25yZWFkeXN0YXRlY2hhbmdlJztcbnZhciBkZWZlciwgY2hhbm5lbCwgcG9ydDtcbnZhciBydW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpZCA9ICt0aGlzO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gIGlmIChxdWV1ZS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICB2YXIgZm4gPSBxdWV1ZVtpZF07XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgICBmbigpO1xuICB9XG59O1xudmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHJ1bi5jYWxsKGV2ZW50LmRhdGEpO1xufTtcbi8vIE5vZGUuanMgMC45KyAmIElFMTArIGhhcyBzZXRJbW1lZGlhdGUsIG90aGVyd2lzZTpcbmlmICghc2V0VGFzayB8fCAhY2xlYXJUYXNrKSB7XG4gIHNldFRhc2sgPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoZm4pIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIHZhciBpID0gMTtcbiAgICB3aGlsZSAoYXJndW1lbnRzLmxlbmd0aCA+IGkpIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcXVldWVbKytjb3VudGVyXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICAgICAgaW52b2tlKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbiksIGFyZ3MpO1xuICAgIH07XG4gICAgZGVmZXIoY291bnRlcik7XG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH07XG4gIGNsZWFyVGFzayA9IGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGlkKSB7XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgfTtcbiAgLy8gTm9kZS5qcyAwLjgtXG4gIGlmIChyZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2VzcycpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjdHgocnVuLCBpZCwgMSkpO1xuICAgIH07XG4gIC8vIFNwaGVyZSAoSlMgZ2FtZSBlbmdpbmUpIERpc3BhdGNoIEFQSVxuICB9IGVsc2UgaWYgKERpc3BhdGNoICYmIERpc3BhdGNoLm5vdykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBEaXNwYXRjaC5ub3coY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBCcm93c2VycyB3aXRoIE1lc3NhZ2VDaGFubmVsLCBpbmNsdWRlcyBXZWJXb3JrZXJzXG4gIH0gZWxzZSBpZiAoTWVzc2FnZUNoYW5uZWwpIHtcbiAgICBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgcG9ydCA9IGNoYW5uZWwucG9ydDI7XG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBsaXN0ZW5lcjtcbiAgICBkZWZlciA9IGN0eChwb3J0LnBvc3RNZXNzYWdlLCBwb3J0LCAxKTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBwb3N0TWVzc2FnZSwgc2tpcCBXZWJXb3JrZXJzXG4gIC8vIElFOCBoYXMgcG9zdE1lc3NhZ2UsIGJ1dCBpdCdzIHN5bmMgJiB0eXBlb2YgaXRzIHBvc3RNZXNzYWdlIGlzICdvYmplY3QnXG4gIH0gZWxzZSBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgJiYgdHlwZW9mIHBvc3RNZXNzYWdlID09ICdmdW5jdGlvbicgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShpZCArICcnLCAnKicpO1xuICAgIH07XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAvLyBJRTgtXG4gIH0gZWxzZSBpZiAoT05SRUFEWVNUQVRFQ0hBTkdFIGluIGNlbCgnc2NyaXB0JykpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgaHRtbC5hcHBlbmRDaGlsZChjZWwoJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICBydW4uY2FsbChpZCk7XG4gICAgICB9O1xuICAgIH07XG4gIC8vIFJlc3Qgb2xkIGJyb3dzZXJzXG4gIH0gZWxzZSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHNldFRpbWVvdXQoY3R4KHJ1biwgaWQsIDEpLCAwKTtcbiAgICB9O1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBzZXRUYXNrLFxuICBjbGVhcjogY2xlYXJUYXNrXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Rhc2suanNcbi8vIG1vZHVsZSBpZCA9IDQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4geyBlOiBmYWxzZSwgdjogZXhlYygpIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4geyBlOiB0cnVlLCB2OiBlIH07XG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcGVyZm9ybS5qc1xuLy8gbW9kdWxlIGlkID0gNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IHJlcXVpcmUoJy4vX25ldy1wcm9taXNlLWNhcGFiaWxpdHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQywgeCkge1xuICBhbk9iamVjdChDKTtcbiAgaWYgKGlzT2JqZWN0KHgpICYmIHguY29uc3RydWN0b3IgPT09IEMpIHJldHVybiB4O1xuICB2YXIgcHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eS5mKEMpO1xuICB2YXIgcmVzb2x2ZSA9IHByb21pc2VDYXBhYmlsaXR5LnJlc29sdmU7XG4gIHJlc29sdmUoeCk7XG4gIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eS5wcm9taXNlO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wcm9taXNlLXJlc29sdmUuanNcbi8vIG1vZHVsZSBpZCA9IDQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgcml0ZXIgPSBbN11bSVRFUkFUT1JdKCk7XG4gIHJpdGVyWydyZXR1cm4nXSA9IGZ1bmN0aW9uICgpIHsgU0FGRV9DTE9TSU5HID0gdHJ1ZTsgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcbiAgQXJyYXkuZnJvbShyaXRlciwgZnVuY3Rpb24gKCkgeyB0aHJvdyAyOyB9KTtcbn0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjLCBza2lwQ2xvc2luZykge1xuICBpZiAoIXNraXBDbG9zaW5nICYmICFTQUZFX0NMT1NJTkcpIHJldHVybiBmYWxzZTtcbiAgdmFyIHNhZmUgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gWzddO1xuICAgIHZhciBpdGVyID0gYXJyW0lURVJBVE9SXSgpO1xuICAgIGl0ZXIubmV4dCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHsgZG9uZTogc2FmZSA9IHRydWUgfTsgfTtcbiAgICBhcnJbSVRFUkFUT1JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXRlcjsgfTtcbiAgICBleGVjKGFycik7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gc2FmZTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1kZXRlY3QuanNcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9qc29uL3N0cmluZ2lmeVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9qc29uL3N0cmluZ2lmeS5qc1xuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOiBbXHJcbiAgXCJlcnJvclwiLCB7IFwicHJvcHNcIjogdHJ1ZSwgXCJpZ25vcmVQcm9wZXJ0eU1vZGlmaWNhdGlvbnNGb3JcIjogW1wiZWxlbWVudFwiXSB9XHJcbl1cclxuKi9cclxuLyogZXNsaW50IG5vLXVzZS1iZWZvcmUtZGVmaW5lOiBbXCJlcnJvclwiLCB7IFwiZnVuY3Rpb25zXCI6IGZhbHNlIH1dICovXHJcbi8qIGVzbGludC1lbnYgZXM2ICovXHJcbmltcG9ydCBTdG9yYWdlIGZyb20gJy4vbW9kdWxlcy9zdG9yYWdlJztcclxuXHJcbmNvbnN0IHJlc2VydmVkRWxlbWVudHMgPSBbJ2RpdicsICdib2R5JywgJ2hlYWQnLCAnaW1nJywgJ3N0eWxlJywgJ3NwYW4nLCAndWwnLCAnbGknLCAnaW5wdXQnLCAnYnV0dG9uJywgJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2EnLCAncCcsICdzdHJvbmcnLCAnc3ZnJ107XHJcbmNvbnN0IEdldEVsZW1lbnQgPSBzZWxlY3RvciA9PiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcclxuXHJcbmNvbnN0ICRFTE1fRUxFTUVOVCA9IChlbGVtZW50KSA9PiB7XHJcbiAgY29uc3QgcmVjdCA9IGFyZyA9PiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2FyZ107XHJcbiAgcmV0dXJuIHtcclxuICAgIGF0dHIoLi4uYXJncykge1xyXG4gICAgICBpZiAoZWxlbWVudCkge1xyXG4gICAgICAgIGNvbnN0IFthdHRyLCB2YWx1ZV0gPSBhcmdzLmxlbmd0aCA9PT0gMiA/IFsuLi5hcmdzXSA6IGFyZ3NbMF0uc3BsaXQoJzonKTtcclxuICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGF0dHIsIHZhbHVlKTtcclxuICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoYXR0cik7XHJcbiAgICAgIH1cclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2FyZ3N9IEVsZW1lbnQgZG9lcyBub3QgZXhpc3QhIEZ1bmN0aW9uICdhdHRyJ2ApO1xyXG4gICAgfSxcclxuICAgIGhlaWdodCgpIHtcclxuICAgICAgcmV0dXJuIHJlY3QoJ2hlaWdodCcpO1xyXG4gICAgfSxcclxuICAgIGNsaWNrKGNhbGxiYWNrKSB7XHJcbiAgICAgIGlmIChlbGVtZW50KSB7XHJcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNhbGxiYWNrKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgfVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Y2FsbGJhY2t9IEVsZW1lbnQgZG9lcyBub3QgZXhpc3QhIEZ1bmN0aW9uICdjbGljaydgKTtcclxuICAgIH0sXHJcbiAgICBodG1sKHN0cikge1xyXG4gICAgICBpZiAoZWxlbWVudCkge1xyXG4gICAgICAgIGlmICghc3RyKSByZXR1cm4gZWxlbWVudC5pbm5lckhUTUw7XHJcbiAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSBzdHI7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgIH1cclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3N0cn0gRWxlbWVudCBkb2VzIG5vdCBleGlzdCEgRnVuY3Rpb24gJ2h0bWwnYCk7XHJcbiAgICB9LFxyXG4gICAgdGV4dChzdHIpIHtcclxuICAgICAgaWYgKGVsZW1lbnQpIHtcclxuICAgICAgICBpZiAoIXN0cikgcmV0dXJuIGVsZW1lbnQuaW5uZXJUZXh0IHx8IGVsZW1lbnQudGV4dENvbnRlbnQ7XHJcbiAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSAnJztcclxuICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHN0cikpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICB9XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtzdHJ9IEVsZW1lbnQgZG9lcyBub3QgZXhpc3QhIEZ1bmN0aW9uICd0ZXh0J2ApO1xyXG4gICAgfSxcclxuICAgIGltYWdlKHNyYykge1xyXG4gICAgICBpZiAoZWxlbWVudCkge1xyXG4gICAgICAgIGVsZW1lbnQuc3JjID0gc3JjO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICB9XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtzcmN9IEVsZW1lbnQgZG9lcyBub3QgZXhpc3QhIEZ1bmN0aW9uICdpbWFnZSdgKTtcclxuICAgIH0sXHJcbiAgICBocmVmKHVybCkge1xyXG4gICAgICBpZiAoZWxlbWVudCkge1xyXG4gICAgICAgIGVsZW1lbnQuaHJlZiA9IHVybDtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgfVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dXJsfSBFbGVtZW50IGRvZXMgbm90IGV4aXN0ISBGdW5jdGlvbiAnaHJlZidgKTtcclxuICAgIH0sXHJcbiAgICBhcHBlbmRGaXJzdChjaGlsZCkge1xyXG4gICAgICBjb25zdCBjID0gY2hpbGQubm9kZVR5cGUgPyBjaGlsZCA6IGNoaWxkLmVsZW1lbnQ7XHJcbiAgICAgIGlmIChlbGVtZW50KSB7XHJcbiAgICAgICAgZWxlbWVudC5pbnNlcnRCZWZvcmUoYywgZWxlbWVudC5jaGlsZE5vZGVzWzBdKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgfVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Y2hpbGR9IEVsZW1lbnQgZG9lcyBub3QgZXhpc3QhIEZ1bmN0aW9uICdhcHBlbmQnYCk7XHJcbiAgICB9LFxyXG4gICAgYXBwZW5kKGNoaWxkKSB7XHJcbiAgICAgIGNvbnN0IGMgPSBjaGlsZC5ub2RlVHlwZSA/IGNoaWxkIDogY2hpbGQuZWxlbWVudDtcclxuICAgICAgaWYgKGVsZW1lbnQpIHtcclxuICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICB9XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjaGlsZH0gRWxlbWVudCBkb2VzIG5vdCBleGlzdCEgRnVuY3Rpb24gJ2FwcGVuZCdgKTtcclxuICAgIH0sXHJcbiAgICBhcHBlbmRBbGwoLi4uY2hpbGRzKSB7XHJcbiAgICAgIHJldHVybiBjaGlsZHMubWFwKHRoaXMuYXBwZW5kKTtcclxuICAgIH0sXHJcbiAgICBjc3MoY24pIHtcclxuICAgICAgaWYgKGNuKSB7XHJcbiAgICAgICAgY24uc3BsaXQoJyAnKVxyXG4gICAgICAgICAgLmpvaW4oJywnKVxyXG4gICAgICAgICAgLnNwbGl0KCcsJylcclxuICAgICAgICAgIC5mb3JFYWNoKGMgPT4gYyAmJiBlbGVtZW50ICYmIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjLnJlcGxhY2UoL1xcLi9nLCAnJykudHJpbSgpKSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG4gICAgdG9nZ2xlKGNuKSB7XHJcbiAgICAgIGlmIChjbikge1xyXG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShjbik7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG4gICAgZ2V0KC4uLmFyZ3MpIHtcclxuICAgICAgaWYgKGVsZW1lbnQpIHtcclxuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHJldHVybiAkRUxNX0VMRU1FTlQoZWxlbWVudC5xdWVyeVNlbGVjdG9yKGFyZ3NbMF0pKTtcclxuICAgICAgICByZXR1cm4gYXJncy5tYXAoYXJnID0+ICRFTE1fRUxFTUVOVChlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoYXJnKSkpO1xyXG4gICAgICB9XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHthcmdzfSBFbGVtZW50IGRvZXMgbm90IGV4aXN0ISBGdW5jdGlvbiAnZ2V0J2ApO1xyXG4gICAgfSxcclxuICAgIGNoaWxkcmVuKGFyZykge1xyXG4gICAgICBpZiAoYXJnKSB7XHJcbiAgICAgICAgY29uc3QgbGlzdCA9IEFycmF5LmZyb20oZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShhcmcpKTtcclxuICAgICAgICByZXR1cm4gbGlzdC5tYXAoY2hpbGQgPT4gJEVMTV9FTEVNRU5UKGNoaWxkKSk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgbGlzdCA9IEFycmF5LmZyb20oZWxlbWVudC5jaGlsZE5vZGVzKTtcclxuICAgICAgcmV0dXJuIGxpc3QubWFwKGNoaWxkID0+ICRFTE1fRUxFTUVOVChjaGlsZCkpO1xyXG4gICAgfSxcclxuICAgIHN0eWxlKHN0bCkge1xyXG4gICAgICBpZiAoZWxlbWVudCkge1xyXG4gICAgICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3RsKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgfVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7c3RsfSBFbGVtZW50IGRvZXMgbm90IGV4aXN0ISBGdW5jdGlvbiAnc3R5bGUnYCk7XHJcbiAgICB9LFxyXG4gICAgZGF0YShrZXksIHZhbHVlKSB7XHJcbiAgICAgIGlmIChlbGVtZW50KSB7XHJcbiAgICAgICAgZWxlbWVudC5kYXRhc2V0W2tleV0gPSB2YWx1ZTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgfVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7a2V5fSAke3ZhbHVlfSBFbGVtZW50IGRvZXMgbm90IGV4aXN0ISBGdW5jdGlvbiAnZGF0YSdgKTtcclxuICAgIH0sXHJcbiAgICBlbGVtZW50LFxyXG4gIH07XHJcbn07XHJcblxyXG5jb25zdCBDcmVhdGVFbGVtZW50ID0gKGFyZykgPT4ge1xyXG4gIGlmIChhcmcgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkgcmV0dXJuICRFTE1fRUxFTUVOVChhcmcpO1xyXG4gIGNvbnN0IGFyciA9IGFyZy5zcGxpdCgnICcpO1xyXG4gIGNvbnN0IHR5cGUgPSBhcnIucmVkdWNlKChhY2MsIGN1cnJlbnQpID0+IHtcclxuICAgIGlmIChyZXNlcnZlZEVsZW1lbnRzLmluY2x1ZGVzKGN1cnJlbnQpKSB7XHJcbiAgICAgIHJldHVybiBjdXJyZW50O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFjYztcclxuICB9LCAnZGl2Jyk7XHJcblxyXG4gIGNvbnN0IGNsYXNzTmFtZXMgPSBhcnIuZmlsdGVyKGN1cnJlbnQgPT4gIXJlc2VydmVkRWxlbWVudHMuaW5jbHVkZXMoY3VycmVudCkpLmpvaW4oKTtcclxuICBjb25zdCBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHR5cGUpO1xyXG4gIHJldHVybiAkRUxNX0VMRU1FTlQoZG9tKS5jc3MoY2xhc3NOYW1lcyk7XHJcbn07XHJcblxyXG5jb25zdCBDcmVhdGVFbGVtZW50QnlPYmplY3QgPSAodHlwZSwgaXRlcmFibGUpID0+IHtcclxuICBjb25zdCBlbGVtZW50ID0gQ3JlYXRlRWxlbWVudCh0eXBlKTtcclxuICBPYmplY3Qua2V5cyhpdGVyYWJsZSkuZm9yRWFjaCgoaXRlbSkgPT4ge1xyXG4gICAgY29uc3QgZnVuYyA9IGVsZW1lbnRbaXRlbV07XHJcbiAgICBpZiAoZnVuYykge1xyXG4gICAgICBjb25zdCB2YWx1ZSA9IGl0ZXJhYmxlW2l0ZW1dO1xyXG4gICAgICBpZiAodmFsdWUgJiYgdmFsdWUubGVuZ3RoKSB7XHJcbiAgICAgICAgZnVuYyh2YWx1ZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gZWxlbWVudDtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCAkRUxNID0ge1xyXG4gIGVsbXM6IHt9LFxyXG4gIGNyZWF0ZSguLi5hcmdzKSB7XHJcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHJldHVybiBDcmVhdGVFbGVtZW50KGFyZ3NbMF0pO1xyXG4gICAgcmV0dXJuIGFyZ3MubWFwKGFyZyA9PiBDcmVhdGVFbGVtZW50KGFyZykpO1xyXG4gIH0sXHJcbiAgYnVpbGQodHlwZSwgaXRlcmFibGUpIHtcclxuICAgIHJldHVybiBDcmVhdGVFbGVtZW50QnlPYmplY3QodHlwZSwgaXRlcmFibGUpO1xyXG4gIH0sXHJcbiAgZ2V0KC4uLmFyZ3MpIHtcclxuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICBjb25zdCBrZXkgPSBOdW1iZXIuaXNJbnRlZ2VyKHBhcnNlSW50KGFyZ3NbMF0sIDEwKSkgPyBwYXJzZUludChhcmdzWzBdLCAxMCkgOiBhcmdzWzBdO1xyXG4gICAgICByZXR1cm4gdGhpcy5lbG1zW2tleV0gfHwgJEVMTV9FTEVNRU5UKEdldEVsZW1lbnQoa2V5KSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXJncy5tYXAoKGFyZykgPT4ge1xyXG4gICAgICBjb25zdCBrZXkgPSBOdW1iZXIuaXNJbnRlZ2VyKHBhcnNlSW50KGFyZywgMTApKSA/IHBhcnNlSW50KGFyZywgMTApIDogYXJnO1xyXG4gICAgICByZXR1cm4gdGhpcy5lbG1zW2tleV0gfHwgJEVMTV9FTEVNRU5UKEdldEVsZW1lbnQoa2V5KSk7XHJcbiAgICB9KTtcclxuICB9LFxyXG4gIHNhdmUoaWQsIGVsZW1lbnQpIHtcclxuICAgIHRoaXMuZWxtc1tpZF0gPSB0aGlzLmVsbXNbaWRdIHx8IHt9O1xyXG4gICAgdGhpcy5lbG1zW2lkXSA9IGVsZW1lbnQ7XHJcbiAgfSxcclxuICBjb3B5KHNlbGVjdG9yKSB7XHJcbiAgICBjb25zdCBjaGlsZCA9IEdldEVsZW1lbnQoc2VsZWN0b3IpO1xyXG4gICAgaWYgKGNoaWxkKSB7XHJcbiAgICAgIHJldHVybiBDcmVhdGVFbGVtZW50KGNoaWxkLmNsb25lTm9kZSh0cnVlKSk7XHJcbiAgICB9XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7c2VsZWN0b3J9IEVsZW1lbnQgZG9lcyBub3QgZXhpc3QhIEZ1bmN0aW9uICdjb3B5J2ApO1xyXG4gIH0sXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgSUNBQ1JPID0gKCkgPT4ge1xyXG4gICRFTE0uZ2V0KCdib2R5JykuY3NzKCdjcm8nKTtcclxuICByZXR1cm4ge1xyXG4gICAgZ2V0RWxlbWVudENvbnRlbnRCeVRhZ0FuZEF0dHIocmVnZXhwLCB0YWcsIGF0dHIpIHtcclxuICAgICAgY29uc3QgcXNhID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0YWcpO1xyXG4gICAgICByZXR1cm4gdGhpcy50b0FycmF5KHFzYSkucmVkdWNlKChhY2MsIGVsZW1lbnQpID0+IHtcclxuICAgICAgICBpZiAobmV3IFJlZ0V4cChyZWdleHApLnRlc3QoZWxlbWVudFthdHRyXSkpIHtcclxuICAgICAgICAgIGFjYy5wdXNoKGVsZW1lbnRbYXR0cl0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYWNjO1xyXG4gICAgICB9LCBbXSk7XHJcbiAgICB9LFxyXG4gICAgcmVtb3ZlRWxlbWVudHMoY2xhc3NOYW1lcykge1xyXG4gICAgICBjbGFzc05hbWVzLmZvckVhY2goKGNsYXNzTmFtZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGVsbSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoY2xhc3NOYW1lKTtcclxuICAgICAgICBpZiAoZWxtIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIGVsbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsbSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIHRvQXJyYXkobGlzdCkgeyByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobGlzdCk7IH0sXHJcbiAgICBsb2FkKC4uLmFyZ3MpIHtcclxuICAgICAgY29uc3QgW3VybCwgb3B0aW9uc10gPSBhcmdzO1xyXG4gICAgICBjb25zdCBvcHMgPSBPYmplY3QuYXNzaWduKHt9LCB7IG1ldGhvZDogJ2dldCcgfSwgb3B0aW9ucyk7XHJcbiAgICAgIHJldHVybiBmZXRjaCh1cmwsIG9wcylcclxuICAgICAgICAudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5qc29uKCkpXHJcbiAgICAgICAgLmNhdGNoKGVyciA9PiBlcnIpO1xyXG4gICAgfSxcclxuICAgIHN0eWxlKHN0eWxlcykge1xyXG4gICAgICBjb25zb2xlLmxvZygnc3R5bGUgaXMgZGVwcmVjYXRlZC4uLiB1c2UgY3NzIGFuZCByZXF1aXJlLicpO1xyXG4gICAgICBjb25zdCBzdHlsZSA9ICRFTE0uY3JlYXRlKCdzdHlsZScpO1xyXG4gICAgICBzdHlsZS5hdHRyKCd0eXBlJywgJ3RleHQvY3NzJyk7XHJcbiAgICAgIHN0eWxlLmFwcGVuZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzdHlsZXMpKTtcclxuICAgICAgJEVMTS5nZXQoJ2hlYWQnKS5hcHBlbmQoc3R5bGUpO1xyXG4gICAgfSxcclxuICAgIGlzTG9nZ2VkSW4oKSB7XHJcbiAgICAgIHJldHVybiAkRUxNLmdldCgnI2hkbkljYVN0YXRlJykuYXR0cigndmFsdWUnKS5sZW5ndGggPiAxO1xyXG4gICAgfSxcclxuICAgIGdhUHVzaCh7IGV2ZW50Q2F0ZWdvcnkgPSAnQS9CJywgZXZlbnRBY3Rpb24sIGV2ZW50TGFiZWwgfSkge1xyXG4gICAgICBpZiAoZ2EpIHtcclxuICAgICAgICBnYSgnc2VuZCcsICdldmVudCcsIGV2ZW50Q2F0ZWdvcnksIGV2ZW50QWN0aW9uLCBldmVudExhYmVsKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIHN0b3JhZ2U6IHtcclxuICAgICAgc2V0KGtleSwgdmFsdWUpIHtcclxuICAgICAgICBTdG9yYWdlLnNldChrZXksIHZhbHVlKTtcclxuICAgICAgfSxcclxuICAgICAgZ2V0KGtleSkge1xyXG4gICAgICAgIHJldHVybiBTdG9yYWdlLmdldChrZXkpO1xyXG4gICAgICB9LFxyXG4gICAgICByZW1vdmUoa2V5KSB7XHJcbiAgICAgICAgU3RvcmFnZS5yZW1vdmUoa2V5KTtcclxuICAgICAgfSxcclxuICAgIH0sXHJcbiAgfTtcclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3V0aWwvbWFpbi5qcyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9hcnJheS9mcm9tXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL2FycmF5L2Zyb20uanNcbi8vIG1vZHVsZSBpZCA9IDQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2lzSXRlcmFibGUyID0gcmVxdWlyZShcIi4uL2NvcmUtanMvaXMtaXRlcmFibGVcIik7XG5cbnZhciBfaXNJdGVyYWJsZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc0l0ZXJhYmxlMik7XG5cbnZhciBfZ2V0SXRlcmF0b3IyID0gcmVxdWlyZShcIi4uL2NvcmUtanMvZ2V0LWl0ZXJhdG9yXCIpO1xuXG52YXIgX2dldEl0ZXJhdG9yMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldEl0ZXJhdG9yMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHtcbiAgICB2YXIgX2FyciA9IFtdO1xuICAgIHZhciBfbiA9IHRydWU7XG4gICAgdmFyIF9kID0gZmFsc2U7XG4gICAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9pID0gKDAsIF9nZXRJdGVyYXRvcjMuZGVmYXVsdCkoYXJyKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfZCA9IHRydWU7XG4gICAgICBfZSA9IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9hcnI7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgIHJldHVybiBhcnI7XG4gICAgfSBlbHNlIGlmICgoMCwgX2lzSXRlcmFibGUzLmRlZmF1bHQpKE9iamVjdChhcnIpKSkge1xuICAgICAgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG4gICAgfVxuICB9O1xufSgpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSA0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmV0dXJuIFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgY29udGVudCArIFwifVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0fSkuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcblx0dmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cdGlmICghY3NzTWFwcGluZykge1xuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0aWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuXHRcdHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcblx0fVxuXG5cdHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuXHR2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xuXG5cdHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1xuLy8gbW9kdWxlIGlkID0gNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cblxudmFyIHN0eWxlc0luRG9tID0ge307XG5cbnZhclx0bWVtb2l6ZSA9IGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbztcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG1lbW87XG5cdH07XG59O1xuXG52YXIgaXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xuXHQvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuXHQvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG5cdC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcblx0Ly8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG5cdC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuXHRyZXR1cm4gd2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2I7XG59KTtcblxudmFyIGdldEVsZW1lbnQgPSAoZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vID0ge307XG5cblx0cmV0dXJuIGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG5cdFx0aWYgKHR5cGVvZiBtZW1vW3NlbGVjdG9yXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0dmFyIHN0eWxlVGFyZ2V0ID0gZm4uY2FsbCh0aGlzLCBzZWxlY3Rvcik7XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuXHRcdFx0aWYgKHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcblx0XHRcdFx0XHQvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG5cdFx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bWVtb1tzZWxlY3Rvcl0gPSBzdHlsZVRhcmdldDtcblx0XHR9XG5cdFx0cmV0dXJuIG1lbW9bc2VsZWN0b3JdXG5cdH07XG59KShmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldClcbn0pO1xuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhclx0c2luZ2xldG9uQ291bnRlciA9IDA7XG52YXJcdHN0eWxlc0luc2VydGVkQXRUb3AgPSBbXTtcblxudmFyXHRmaXhVcmxzID0gcmVxdWlyZShcIi4vdXJsc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XG5cdGlmICh0eXBlb2YgREVCVUcgIT09IFwidW5kZWZpbmVkXCIgJiYgREVCVUcpIHtcblx0XHRpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG5cdH1cblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRvcHRpb25zLmF0dHJzID0gdHlwZW9mIG9wdGlvbnMuYXR0cnMgPT09IFwib2JqZWN0XCIgPyBvcHRpb25zLmF0dHJzIDoge307XG5cblx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG5cdC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2Vcblx0aWYgKCFvcHRpb25zLnNpbmdsZXRvbikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgPGhlYWQ+IGVsZW1lbnRcblx0aWYgKCFvcHRpb25zLmluc2VydEludG8pIG9wdGlvbnMuaW5zZXJ0SW50byA9IFwiaGVhZFwiO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiB0aGUgdGFyZ2V0XG5cdGlmICghb3B0aW9ucy5pbnNlcnRBdCkgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XG5cblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0LCBvcHRpb25zKTtcblxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xuXHRcdH1cblxuXHRcdGlmKG5ld0xpc3QpIHtcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCwgb3B0aW9ucyk7XG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XG5cblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykgZG9tU3R5bGUucGFydHNbal0oKTtcblxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMsIG9wdGlvbnMpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdGlmKGRvbVN0eWxlKSB7XG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyAobGlzdCwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGVzID0gW107XG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XG5cdFx0dmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XG5cdFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XG5cblx0XHRpZighbmV3U3R5bGVzW2lkXSkgc3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcblx0XHRlbHNlIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcblx0fVxuXG5cdHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudCAob3B0aW9ucywgc3R5bGUpIHtcblx0dmFyIHRhcmdldCA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvKVxuXG5cdGlmICghdGFyZ2V0KSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnRJbnRvJyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG5cdH1cblxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZXNJbnNlcnRlZEF0VG9wW3N0eWxlc0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XG5cblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcblx0XHRpZiAoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCB0YXJnZXQuZmlyc3RDaGlsZCk7XG5cdFx0fSBlbHNlIGlmIChsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHRcdH1cblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGUpO1xuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcblx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlKSB7XG5cdFx0dmFyIG5leHRTaWJsaW5nID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8gKyBcIiBcIiArIG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlKTtcblx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBuZXh0U2libGluZyk7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiW1N0eWxlIExvYWRlcl1cXG5cXG4gSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcgKCdvcHRpb25zLmluc2VydEF0JykgZm91bmQuXFxuIE11c3QgYmUgJ3RvcCcsICdib3R0b20nLCBvciBPYmplY3QuXFxuIChodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlciNpbnNlcnRhdClcXG5cIik7XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50IChzdHlsZSkge1xuXHRpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXHRzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcblxuXHR2YXIgaWR4ID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlKTtcblx0aWYoaWR4ID49IDApIHtcblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG5cblx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXG5cdGFkZEF0dHJzKHN0eWxlLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlKTtcblxuXHRyZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG5cblx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHRvcHRpb25zLmF0dHJzLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuXG5cdGFkZEF0dHJzKGxpbmssIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGluayk7XG5cblx0cmV0dXJuIGxpbms7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHJzIChlbCwgYXR0cnMpIHtcblx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdGVsLnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGUsIHVwZGF0ZSwgcmVtb3ZlLCByZXN1bHQ7XG5cblx0Ly8gSWYgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gd2FzIGRlZmluZWQsIHJ1biBpdCBvbiB0aGUgY3NzXG5cdGlmIChvcHRpb25zLnRyYW5zZm9ybSAmJiBvYmouY3NzKSB7XG5cdCAgICByZXN1bHQgPSBvcHRpb25zLnRyYW5zZm9ybShvYmouY3NzKTtcblxuXHQgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgXHQvLyBJZiB0cmFuc2Zvcm0gcmV0dXJucyBhIHZhbHVlLCB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIHJ1bm5pbmcgcnVudGltZSB0cmFuc2Zvcm1hdGlvbnMgb24gdGhlIGNzcy5cblx0ICAgIFx0b2JqLmNzcyA9IHJlc3VsdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICBcdC8vIElmIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCBkb24ndCBhZGQgdGhpcyBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIGNvbmRpdGlvbmFsIGxvYWRpbmcgb2YgY3NzXG5cdCAgICBcdHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgIFx0XHQvLyBub29wXG5cdCAgICBcdH07XG5cdCAgICB9XG5cdH1cblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblxuXHRcdHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcblxuXHR9IGVsc2UgaWYgKFxuXHRcdG9iai5zb3VyY2VNYXAgJiZcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiXG5cdCkge1xuXHRcdHN0eWxlID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXG5cdFx0XHRpZihzdHlsZS5ocmVmKSBVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlLmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXHRcdH07XG5cdH1cblxuXHR1cGRhdGUob2JqKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaikge1xuXHRcdGlmIChuZXdPYmopIHtcblx0XHRcdGlmIChcblx0XHRcdFx0bmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuXHRcdFx0XHRuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuXHRcdFx0XHRuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcblx0fTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xuXG5cdGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGUsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGUuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXG5cdH1cblxuXHRpZihzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpIHtcblx0XHRcdHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuXHRcdH1cblxuXHRcdHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsgKGxpbmssIG9wdGlvbnMsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0Lypcblx0XHRJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcblx0XHRhbmQgdGhlcmUgaXMgbm8gcHVibGljUGF0aCBkZWZpbmVkIHRoZW4gbGV0cyB0dXJuIGNvbnZlcnRUb0Fic29sdXRlVXJsc1xuXHRcdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxuXHRcdGRpcmVjdGx5XG5cdCovXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xuXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscykge1xuXHRcdGNzcyA9IGZpeFVybHMoY3NzKTtcblx0fVxuXG5cdGlmIChzb3VyY2VNYXApIHtcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcblx0fVxuXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xuXG5cdHZhciBvbGRTcmMgPSBsaW5rLmhyZWY7XG5cblx0bGluay5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpIFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXG4vLyBtb2R1bGUgaWQgPSA1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiBlc2xpbnQgbm8taW5uZXItZGVjbGFyYXRpb25zOiBcIm9mZlwiICovXHJcbi8qIGVzbGludCBuby11c2UtYmVmb3JlLWRlZmluZTogXCJvZmZcIiAqL1xyXG5cclxuLy8gPT1Vc2VyU2NyaXB0PT1cclxuLy8gQG5hbWUgICAgICAgICBTdGFydC1wYWdlXHJcbi8vIEBwYXRoICAgICAgICAgLy8uL3NyYy9zdGFydC1wYWdlL3ZhcmlhbnQuanNcclxuLy8gQG5hbWVzcGFjZSAgICBodHRwOi8vdGFtcGVybW9ua2V5Lm5ldC9cclxuLy8gQHZlcnNpb24gICAgICAwLjFcclxuLy8gQG1hdGNoICAgICAgICBodHRwczovL3d3dy5pY2Euc2UvKlxyXG4vLyBAZ3JhbnQgICAgICAgIG5vbmVcclxuLy8gPT0vVXNlclNjcmlwdD09XHJcblxyXG5pbXBvcnQgeyBJQ0FDUk8sICRFTE0gfSBmcm9tICcuLi91dGlsL21haW4nO1xyXG5pbXBvcnQgUmF0aW5ncyBmcm9tICcuLi91dGlsL21vZHVsZXMvcmF0aW5ncyc7XHJcbmltcG9ydCBiYW5uZXJzIGZyb20gJy4vYmFubmVycyc7XHJcbmltcG9ydCBjb3Vwb25zIGZyb20gJy4vY291cG9ucyc7XHJcblxyXG5pbXBvcnQgJy4vc3R5bGUuY3NzJztcclxuXHJcbihmdW5jdGlvbiAoJCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgY29uc3QgTE9HSU5fQUNUSU9OID0ge1xyXG4gICAgU0FWRV9SRUNJUEU6ICdTUEFSQScsXHJcbiAgICBMT0FEX0NPVVBPTjogJ0xBRERBJyxcclxuICB9O1xyXG4gIGNvbnN0IEFDVElPTl9DT09LSUVTID0ge1xyXG4gICAgU0FWRV9SRUNJUEU6ICdjcm9fc3RhcnRwYWdlX2FjdGlvbkNvb2tpZV9zYXZlUmVjaXBlJyxcclxuICAgIExPQURfQ09VUE9OOiAnY3JvX3N0YXJ0cGFnZV9hY3Rpb25Db29raWVfbG9hZENvdXBvbicsXHJcbiAgfTtcclxuICBjb25zdCBsb2FkZWRDb3Vwb25zID0gW107XHJcblxyXG4gIC8vIGlmIChoaikgaGooJ3RyaWdnZXInLCd2YXJpYW50NScpOy8vIGVzbGludC1kaXNhYmxlLWxpbmVcclxuICBjb25zdCB0ZXN0ID0ge1xyXG4gICAgY3JlYXRlKGNsYXNzTmFtZSwgcGFyZW50LCB0ZXh0LCB0eXBlKSB7XHJcbiAgICAgIGNvbnN0IHQgPSB0eXBlIHx8ICdkaXYnO1xyXG4gICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHQpO1xyXG4gICAgICBpZiAodGV4dCAmJiB0eXBlID09PSAnaW1nJykge1xyXG4gICAgICAgIGRpdi5zcmMgPSB0ZXh0O1xyXG4gICAgICB9IGVsc2UgaWYgKHRleHQpIHtcclxuICAgICAgICBkaXYuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCkpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChjbGFzc05hbWUpIGRpdi5jbGFzc05hbWUgPSBjbGFzc05hbWU7XHJcbiAgICAgIGlmIChwYXJlbnQpIHBhcmVudC5hcHBlbmRDaGlsZChkaXYpO1xyXG4gICAgICByZXR1cm4gZGl2O1xyXG4gICAgfSxcclxuICAgIGFkZENvdXBvbihjb3Vwb24pIHtcclxuICAgICAgY29uc3QgY291cG9uSXRlbSA9ICRFTE0uY3JlYXRlKCdjb3Vwb25zLWNvbnRhaW5lcl9faXRlbScpO1xyXG4gICAgICBjb25zdCBpbWcgPSAkRUxNLmNyZWF0ZSgnaW1nJyk7XHJcbiAgICAgIGNvbnN0IHdyYXBwZXIgPSAkRUxNLmNyZWF0ZSgnY291cG9ucy1jb250YWluZXJfX2l0ZW0td3JhcHBlcicpO1xyXG4gICAgICBjb25zdCBpbWFnZVdyYXBwZXIgPSAkRUxNLmNyZWF0ZSgnY291cG9ucy1jb250YWluZXJfX2l0ZW0taW1hZ2Utd3JhcHBlcicpO1xyXG4gICAgICBjb25zdCB0aXRsZSA9ICRFTE0uY3JlYXRlKCdoMycpO1xyXG4gICAgICBjb25zdCBkaXNjb3VudCA9ICRFTE0uY3JlYXRlKCdoMScpO1xyXG4gICAgICBjb25zdCBzdWJ0aXRsZSA9ICRFTE0uY3JlYXRlKCdoNCcpO1xyXG4gICAgICBjb25zdCBtb3JlSW5mbyA9ICRFTE0uY3JlYXRlKCdhJyk7XHJcbiAgICAgIGNvbnN0IGJ1dHRvbiA9ICRFTE0uY3JlYXRlKCdidXR0b24gLmJ1dHRvbiBjb3Vwb24tYnV0dG9uJyk7XHJcblxyXG4gICAgICB0aXRsZS50ZXh0KGNvdXBvbi50aXRsZSk7XHJcbiAgICAgIGRpc2NvdW50LnRleHQoY291cG9uLmRpc2NvdW50KTtcclxuICAgICAgc3VidGl0bGUudGV4dChjb3Vwb24uc3VidGl0bGUpO1xyXG4gICAgICBtb3JlSW5mby50ZXh0KCdNZXIgaW5mbycpO1xyXG4gICAgICBidXR0b24udGV4dCgnTGFkZGEga3Vwb25nJyk7XHJcbiAgICAgIGltZy5pbWFnZShjb3Vwb24uaW1hZ2UpO1xyXG4gICAgICBtb3JlSW5mby5ocmVmKGNvdXBvbi51cmwpO1xyXG5cclxuICAgICAgYnV0dG9uLmNsaWNrKCgpID0+IHtcclxuICAgICAgICBpZiAodGhpcy5pc0xvZ2dlZEluKCkpIHtcclxuICAgICAgICAgIHRoaXMubG9hZENvdXBvbk9uQ2FyZChjb3Vwb24pLnRoZW4oKHJlc3BvbnNlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlT2ZmZXJTdGF0dXMocmVzcG9uc2UsIGNvdXBvbik7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaWNhZGF0YWxheWVyLmFkZCgnSFNFJywge1xyXG4gICAgICAgICAgICBIU0U6IHtcclxuICAgICAgICAgICAgICBhY3Rpb246ICdsb2dpbi1tb3VzZWRvd24nLFxyXG4gICAgICAgICAgICAgIG5hbWU6IGNvdXBvbi5QYWdlTmFtZSxcclxuICAgICAgICAgICAgICBoc2V1cmw6IGNvdXBvbi51cmwsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICBjb25zdCBjb29raWVEYXRhID0ge1xyXG4gICAgICAgICAgICBQYWdlTmFtZTogY291cG9uLlBhZ2VOYW1lLFxyXG4gICAgICAgICAgICByZWNpcGVJZDogY291cG9uLnJlY2lwZUlkLFxyXG4gICAgICAgICAgICB0aXRsZTogY291cG9uLlBhZ2VOYW1lLFxyXG4gICAgICAgICAgICB1cmw6IGNvdXBvbi5QYWdlTmFtZSxcclxuICAgICAgICAgICAgT2ZmZXJJZDogY291cG9uLk9mZmVyLFxyXG4gICAgICAgICAgICBDYW1wYWlnbklkOiBjb3Vwb24uUGFnZU5hbWUsXHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIHRoaXMuc2V0QWN0aW9uQ29va2llKEFDVElPTl9DT09LSUVTLkxPQURfQ09VUE9OLCBjb29raWVEYXRhKTtcclxuICAgICAgICAgIHRoaXMuY3JlYXRlTW9kYWwoTE9HSU5fQUNUSU9OLkxPQURfQ09VUE9OKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWNhZGF0YWxheWVyLmFkZCgnSFNFJywge1xyXG4gICAgICAgIEhTRToge1xyXG4gICAgICAgICAgYWN0aW9uOiAnZGlzcGxheScsXHJcbiAgICAgICAgICB0aXRsZTogY291cG9uLlBhZ2VOYW1lLFxyXG4gICAgICAgICAgaHNldXJsOiBjb3Vwb24udXJsLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0pO1xyXG4gICAgICBjb3Vwb25JdGVtLmF0dHIoJ2lkJywgYGNvdXBvbi0ke2NvdXBvbi5PZmZlcklkfS0ke2NvdXBvbi5yZWNpcGVJZH1gKTtcclxuICAgICAgdGhpcy5sb2FkQ291cG9uRGF0YShjb3Vwb24pLnRoZW4oKGRhdGEpID0+IHtcclxuICAgICAgICBpZiAoZGF0YS5PZmZlci5Mb2FkZWRPbkNhcmQpIHtcclxuICAgICAgICAgIGNvdXBvbkl0ZW0uY3NzKCdvZmZlci1sb2FkZWQnKTtcclxuICAgICAgICAgIGJ1dHRvbi50ZXh0KCdLdXBvbmcgbGFkZGFkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgaW1hZ2VXcmFwcGVyLmFwcGVuZChpbWcpO1xyXG4gICAgICB3cmFwcGVyLmFwcGVuZEFsbCh0aXRsZSwgZGlzY291bnQsIHN1YnRpdGxlLCBtb3JlSW5mbyk7XHJcbiAgICAgIGNvdXBvbkl0ZW0uYXBwZW5kQWxsKGltYWdlV3JhcHBlciwgd3JhcHBlciwgYnV0dG9uKTtcclxuICAgICAgcmV0dXJuIGNvdXBvbkl0ZW07XHJcbiAgICB9LFxyXG4gICAgYWRkQmFubmVyKGJhbm5lcikge1xyXG4gICAgICBjb25zdCBbXHJcbiAgICAgICAgYmFubmVyQ29udGFpbmVyLFxyXG4gICAgICAgIGJhbm5lckNvbnRhaW5lckltZyxcclxuICAgICAgICBpbWcsXHJcbiAgICAgICAgdGV4dENvbnRhaW5lcixcclxuICAgICAgICBsaW5rLFxyXG4gICAgICAgIHRpdGxlLFxyXG4gICAgICAgIHJhdGluZ3MsXHJcbiAgICAgICAgZGlmZmljdWx0eSxcclxuICAgICAgICBjb3Vwb25zV3JhcHBlcixcclxuICAgICAgXSA9ICRFTE0uY3JlYXRlKFxyXG4gICAgICAgICdsaSBiYW5uZXItY29udGFpbmVyJyxcclxuICAgICAgICAnYmFubmVyLWNvbnRhaW5lcl9faW1nJyxcclxuICAgICAgICAnaW1nJyxcclxuICAgICAgICAnYmFubmVyLWNvbnRhaW5lcl9fdGV4dC1jb250YWluZXInLFxyXG4gICAgICAgICdhIHRleHQtY29udGFpbmVyX19saW5rJyxcclxuICAgICAgICAnaDEgdGV4dC1jb250YWluZXJfX3RpdGxlJyxcclxuICAgICAgICAndGV4dC1jb250YWluZXJfX3JhdGluZ3MnLFxyXG4gICAgICAgICdoNCB0ZXh0LWNvbnRhaW5lcl9fZGlmZmljdWx0eScsXHJcbiAgICAgICAgJ2NvdXBvbnMtY29udGFpbmVyJyxcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGNvbnN0IHNhdmVCdXR0b24gPSB0aGlzLmNyZWF0ZVNhdmVSZWNpcGVDVEEoYmFubmVyKTtcclxuXHJcbiAgICAgIGltZy5pbWFnZShiYW5uZXIuaW1hZ2UpO1xyXG4gICAgICBiYW5uZXJDb250YWluZXJJbWcuYXBwZW5kKGltZyk7XHJcbiAgICAgIGJhbm5lckNvbnRhaW5lckltZy5pbWFnZShiYW5uZXIuaW1hZ2UpO1xyXG5cclxuICAgICAgcmF0aW5ncy5odG1sKFJhdGluZ3MoYmFubmVyLnN0YXJzKSk7XHJcbiAgICAgIHRpdGxlLnRleHQoYmFubmVyLnRpdGxlKTtcclxuICAgICAgZGlmZmljdWx0eS50ZXh0KGJhbm5lci5jb29rVGltZSk7XHJcblxyXG4gICAgICBiYW5uZXIuY291cG9ucy5mb3JFYWNoKChjb3Vwb24pID0+IHtcclxuICAgICAgICBjb3Vwb25zV3JhcHBlci5hcHBlbmQodGhpcy5hZGRDb3Vwb24oY291cG9uKSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgbGluay5ocmVmKGJhbm5lci51cmwpO1xyXG4gICAgICBsaW5rLmFwcGVuZEFsbCh0aXRsZSwgcmF0aW5ncywgZGlmZmljdWx0eSk7XHJcbiAgICAgIHRleHRDb250YWluZXIuYXBwZW5kKGxpbmspO1xyXG4gICAgICBiYW5uZXJDb250YWluZXIuYXBwZW5kQWxsKGJhbm5lckNvbnRhaW5lckltZywgdGV4dENvbnRhaW5lciwgc2F2ZUJ1dHRvbiwgY291cG9uc1dyYXBwZXIpO1xyXG4gICAgICByZXR1cm4gYmFubmVyQ29udGFpbmVyO1xyXG4gICAgfSxcclxuICAgIGFkZFN0eWxlKGVsZW1lbnQsIHN0bCkge1xyXG4gICAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHN0bCk7XHJcbiAgICB9LFxyXG4gICAgYWRkQmFubmVycygpIHtcclxuICAgICAgY29uc3QgaGVhZGVyID0gJEVMTS5nZXQoJy5oZWFkZXInKTtcclxuICAgICAgY29uc3QgdWwgPSAkRUxNLmNyZWF0ZSgndWwgY3JvLXNsaWRlcicpO1xyXG4gICAgICBoZWFkZXIuaHRtbCgnICcpO1xyXG4gICAgICBiYW5uZXJzLmZvckVhY2goKGJhbm5lcikgPT4ge1xyXG4gICAgICAgIHVsLmFwcGVuZCh0aGlzLmFkZEJhbm5lcihiYW5uZXIpKTtcclxuICAgICAgfSk7XHJcbiAgICAgIGhlYWRlci5hcHBlbmQodWwpO1xyXG4gICAgICAkKCcuY3JvLXNsaWRlcicpLnNsaWNrKHtcclxuICAgICAgICBhZGFwdGl2ZUhlaWdodDogdHJ1ZSxcclxuICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgYWRkSWNhQ2FyZCgpIHtcclxuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcbiAgICAgIGNvbnN0IGljYUltYWdlQ29udGFpbmVyID0gc2VsZi5jcmVhdGUoJ2ljYS1jYXJkLWNvbnRhaW5lcicpO1xyXG4gICAgICBzZWxmLmNyZWF0ZSgnJywgaWNhSW1hZ2VDb250YWluZXIsICdGw6UgcmFiYXR0IG1lZCBJQ0EtS29ydCcsICdoMScpO1xyXG4gICAgICBjb25zdCB1c3BzID0gc2VsZi5jcmVhdGUoJ3VzcC1saXN0JywgaWNhSW1hZ2VDb250YWluZXIsIG51bGwsICd1bCcpO1xyXG4gICAgICB1c3BzLmlubmVySFRNTCA9IGBcclxuICAgICAgPGxpPjxzdmcgdmlld0JveD1cIjAgMCAzMiAzMlwiIHdpZHRoPVwiMTVweFwiIGhlaWdodD1cIjE1cHhcIj48dXNlIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiIHhsaW5rOmhyZWY9XCIvQXNzZXRzL2ljb25zL3Nwcml0ZS5zdmcjY2hlY2tcIj48L3VzZT48L3N2Zz4gSUNBLWtvcnQgbWVkIGJvbnVzPC9saT5cclxuICAgICAgPGxpPjxzdmcgdmlld0JveD1cIjAgMCAzMiAzMlwiIHdpZHRoPVwiMTVweFwiIGhlaWdodD1cIjE1cHhcIj48dXNlIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiIHhsaW5rOmhyZWY9XCIvQXNzZXRzL2ljb25zL3Nwcml0ZS5zdmcjY2hlY2tcIj48L3VzZT48L3N2Zz4gUGVyc29ubGlnYSBlcmJqdWRhbmRlbjwvbGk+XHJcbiAgICAgIDxsaT48c3ZnIHZpZXdCb3g9XCIwIDAgMzIgMzJcIiB3aWR0aD1cIjE1cHhcIiBoZWlnaHQ9XCIxNXB4XCI+PHVzZSB4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiB4bGluazpocmVmPVwiL0Fzc2V0cy9pY29ucy9zcHJpdGUuc3ZnI2NoZWNrXCI+PC91c2U+PC9zdmc+IEtvcnRwcmlzZXIgdmFyamUgdmVja2E8L2xpPlxyXG4gICAgICBgO1xyXG4gICAgICBzZWxmLmNyZWF0ZSgnJywgaWNhSW1hZ2VDb250YWluZXIsICdodHRwczovL3d3dy5pY2Euc2UvSW1hZ2VWYXVsdEZpbGVzL2lkXzc4NjQ5L2NmXzMvSUNBX0tvcnRfb2NoX0JhbmsucG5nJywgJ2ltZycpO1xyXG4gICAgICBzZWxmLmNyZWF0ZSgnYnV0dG9uJywgaWNhSW1hZ2VDb250YWluZXIsICdTa2FwYSBrb250byBvY2ggYmxpIG1lZGxlbScsICdhJylcclxuICAgICAgICAuaHJlZiA9ICcvYW5zb2thbi8/c3RlcD02MzY5NzY2OTYzNjY2ZjcyNmQnO1xyXG4gICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubWFpbicpLmFwcGVuZENoaWxkKGljYUltYWdlQ29udGFpbmVyKTtcclxuICAgIH0sXHJcbiAgICBkaW5uZXJUb25pZ2h0KCkge1xyXG4gICAgICBjb25zdCBjb250YWluZXIgPSAkRUxNLmdldCgnLnNlYXJjaC1yZWNpcGUtY29udGFpbmVyJyk7XHJcbiAgICAgIHRoaXMucmVtb3ZlRWxlbWVudHMoWycucmVjaXBlLXRyZW5kaW5nLWxpc3QgaDInXSk7XHJcbiAgICAgIGNvbnRhaW5lci5nZXQoJ2gxJykudGV4dCgnVmFkIMOkciBkdSBzdWdlbiBww6U/Jyk7XHJcbiAgICB9LFxyXG4gICAgbWFuaXB1bGF0ZURvbSgpIHtcclxuICAgICAgdGhpcy5yZW1vdmVFbGVtZW50cyhbXHJcbiAgICAgICAgJy5pbWFnZS1zbGlkZXIgbGknLFxyXG4gICAgICAgICcuaW1hZ2Utc2xpZGVyIC5sYXp5LXNwaW5uZXInLFxyXG4gICAgICAgICcuaGVhZGVyLWNvbnRlbnQnLFxyXG4gICAgICAgICcucHVzaC1pdGVtcy1saXN0JyxcclxuICAgICAgICAnLnF1aWNrbGluay1saXN0JyxcclxuICAgICAgICAnLm1haW4gLmxpbmstbGlzdCcsXHJcbiAgICAgICAgJy5yZWNpcGUtY2F0ZWdvcnktbGlzdGluZyAuYmFubmVyLWltYWdlJyxcclxuICAgICAgICAnLnJlY2lwZS1jYXRlZ29yeS1saXN0aW5nID4gLmNvbC0xMiA+IGgyJyxcclxuICAgICAgICAnLnNlYXJjaC1yZWNpcGUtY29udGFpbmVyX19yZWNpcGUtY291bnQnLFxyXG4gICAgICAgICcucmVjaXBlLWNhdGVnb3J5LWxpc3RpbmcgLnJlY2lwZS1saXN0LWl0ZW1zJyxcclxuICAgICAgXSk7XHJcbiAgICAgIHRoaXMuYWRkQmFubmVycygpO1xyXG4gICAgICB0aGlzLmNyZWF0ZU9mZmVycygpO1xyXG4gICAgICB0aGlzLmFkZEljYUNhcmQoKTtcclxuICAgICAgdGhpcy5kaW5uZXJUb25pZ2h0KCk7XHJcbiAgICAgIGNvbnN0IHJldHVyblVybCA9IGVuY29kZVVSSUNvbXBvbmVudCh3aW5kb3cubG9jYXRpb24uaHJlZik7XHJcbiAgICAgIGNvbnN0IGlmcmFtZUNvbnRhaW5lciA9ICQoYDxkaXYgY2xhc3M9XCJjcm8taWZyYW1lLWNvbnRhaW5lclwiPjxzcGFuIGNsYXNzPVwibG9hZGVyXCI+PC9zcGFuPjxpZnJhbWUgc3JjPVwiLy93d3cuaWNhLnNlL2xvZ2dhLWluLz9yZXR1cm51cmw9JHtyZXR1cm5Vcmx9XCIgZnJhbWVib3JkZXI9XCIwXCI+PC9pZnJhbWU+PC9kaXY+YCk7XHJcbiAgICAgICQoJ2JvZHknKS5hcHBlbmQoaWZyYW1lQ29udGFpbmVyKTtcclxuICAgIH0sXHJcbiAgICBjcmVhdGVTYXZlUmVjaXBlQ1RBKGJhbm5lcikge1xyXG4gICAgICBjb25zdCBjb250YWluZXIgPSAkRUxNLmNyZWF0ZSgnYnV0dG9uLXdyYXBwZXInKTtcclxuICAgICAgY29uc3QgY3RhID0gJEVMTS5jcmVhdGUoJ2EgLmJ1dHRvbiBiYW5uZXItYnV0dG9uJyk7XHJcbiAgICAgIGN0YS5odG1sKCc8ZGl2IGNsYXNzPVwibGF5ZXJcIj48c3ZnIHZpZXdCb3g9XCIwIDAgMzIgMzJcIiB3aWR0aD1cIjE1cHhcIiBoZWlnaHQ9XCIxNXB4XCI+PHVzZSB4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiB4bGluazpocmVmPVwiL0Fzc2V0cy9pY29ucy9zcHJpdGUuc3ZnI2NoZWNrXCI+PC91c2U+PC9zdmc+PC9kaXY+TMOkZ2cgcmVjZXB0IGkgaW5rw7Zwc2xpc3RhbicpO1xyXG4gICAgICBjdGEuaHJlZihgI2ApO1xyXG4gICAgICBjdGEuZGF0YSgncmVjaXBlSWQnLCBiYW5uZXIucmVjaXBlSWQpO1xyXG4gICAgICBjdGEuZGF0YSgndHJhY2tpbmcnLCBgeyBcIm5hbWVcIjogXCIke2Jhbm5lci50aXRsZX1cIiwgXCJVUkxcIjogXCIke2Jhbm5lci51cmx9XCIgfWApO1xyXG4gICAgICBjdGEuY3NzKGBqcy1hZGQtdG8tbmV3LXNob3BwaW5nbGlzdCBiYW5uZXItYnV0dG9uLSR7YmFubmVyLnJlY2lwZUlkfWApO1xyXG5cclxuICAgICAgY3RhLmNsaWNrKChlKSA9PiB7XHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIHRoaXMuYWRkUmVjaXBlVG9TaG9wcGluZ0xpc3QoYmFubmVyLnJlY2lwZUlkKTtcclxuICAgICAgICBjdGEudG9nZ2xlKCdhZGRlZCcpO1xyXG4gICAgICAgICRFTE0uZ2V0KCcjanMtdG9nZ2xlLWF2YXRhcicpLmNzcygnY3JvLXN0YXJ0cGFnZS1zaG9wcGluZ2xpc3QtY29hY2htYXJrJyk7XHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBjdGEudG9nZ2xlKCdhZGRlZCcpLCAxNTAwKTtcclxuICAgICAgfSk7XHJcbiAgICAgIGNvbnRhaW5lci5hcHBlbmQoY3RhKTtcclxuICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcclxuICAgIH0sXHJcbiAgICBjcmVhdGVPZmZlcnMoKSB7XHJcbiAgICAgIGNvbnN0IG1haW4gPSAkRUxNLmdldCgnLm1haW4nKTtcclxuICAgICAgY29uc3QgY29udGFpbmVyID0gJEVMTS5jcmVhdGUoJ2RpdiBjb3Vwb24tYmFubmVyJyk7XHJcbiAgICAgIGNvbnRhaW5lci5jbGljaygoKSA9PiB7XHJcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSAnL2VyYmp1ZGFuZGVuL2J1dGlrc2VyYmp1ZGFuZGVuL2FsbGEtZGlnaXRhbGEta3Vwb25nZXIvJztcclxuICAgICAgfSk7XHJcbiAgICAgIGNvbnN0IG9mZmVyQnV0dG9uID0gJEVMTS5jcmVhdGUoJ2EgLmJ1dHRvbiBvZmZlcnMtYnV0dG9uJykudGV4dCgnR8OlIHRpbGwgSUNBcyBrdXBvbmdlcicpLmhyZWYoJy9lcmJqdWRhbmRlbi9idXRpa3NlcmJqdWRhbmRlbi9hbGxhLWRpZ2l0YWxhLWt1cG9uZ2VyLycpO1xyXG4gICAgICBjb25zdCBpbWcgPSAkRUxNLmNyZWF0ZSgnaW1nJykuaW1hZ2UoJ2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9CYW56YWNpL2ljYS9tYXN0ZXIvc3JjL3N0YXJ0LXBhZ2UvQ291cG9uc19pbWFnZS5wbmcnKTtcclxuICAgICAgY29udGFpbmVyLmFwcGVuZEFsbChpbWcsIG9mZmVyQnV0dG9uKTtcclxuICAgICAgbWFpbi5hcHBlbmQoY29udGFpbmVyKTtcclxuICAgIH0sXHJcbiAgICBhZGRSZWNpcGVUb1Nob3BwaW5nTGlzdChyZWNpcGVJZCkge1xyXG4gICAgICAvLyB0cmFja2luZyBza2VyIHZpYSBrbGFzc25hbW5cclxuXHJcbiAgICAgIElDQS5hamF4LnBvc3QoJy9UZW1wbGF0ZXMvUmVjaXBlcy9IYW5kbGVycy9TaG9wcGluZ0xpc3RIYW5kbGVyLmFzaHgnLCB7XHJcbiAgICAgICAgcmVjaXBlSWRzOiBbcmVjaXBlSWRdLFxyXG4gICAgICAgIFNob3BwaW5nTGlzdElkOiAwLFxyXG4gICAgICAgIG51bWJlck9mU2VydmluZ3M6IDAsXHJcbiAgICAgICAgcmVjaXBlczogW10sXHJcbiAgICAgICAgc2hvcHBpbmdMaXN0TmFtZTogY3JlYXRlU2hvcHBpbmdzTGlzdE5hbWUoKSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBmdW5jdGlvbiBjcmVhdGVTaG9wcGluZ3NMaXN0TmFtZSgpIHtcclxuICAgICAgICBjb25zdCBkID0gbmV3IERhdGUoKTtcclxuICAgICAgICBjb25zdCB5ZWFyID0gZC5nZXRGdWxsWWVhcigpO1xyXG4gICAgICAgIGNvbnN0IG1vbnRoID0gZC5nZXRNb250aCgpO1xyXG4gICAgICAgIGNvbnN0IGRheSA9IGQuZ2V0RGF0ZSgpO1xyXG4gICAgICAgIGNvbnN0IG1vbnRocyA9IHsgMTA6ICdub3YnLCAxMTogJ2RlYycgfTsgLy8gdGVzdGV0IGtvbW1lciBlbmRhc3QgbGlnZ2EgdXRlIGkgbm92LCBzZW5hc3QgZGVjXHJcblxyXG4gICAgICAgIHJldHVybiBgQXR0IGhhbmRsYSwgJHtkYXl9ICR7bW9udGhzW21vbnRoXX0gJHt5ZWFyfWA7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBzZXRBY3Rpb25Db29raWUoY29va2llTmFtZSwgY29va2llRGF0YSkge1xyXG4gICAgICAvLyBUT0RPOiBGbHl0dGEgdGlsbCBtYWluLmpzXHJcbiAgICAgIGNvbnN0IGQgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICBkLnNldERhdGUobmV3IERhdGUoKS5nZXREYXRlKCkgKyAxKTsgLy8gZXhwaXJlcyB0b21vcnJvd1xyXG5cclxuICAgICAgSUNBLmxlZ2FjeS5zZXRDb29raWUoY29va2llTmFtZSwgSlNPTi5zdHJpbmdpZnkoY29va2llRGF0YSksIGQpO1xyXG4gICAgfSxcclxuICAgIGdldEFjdGlvbkNvb2tpZShjb29raWVOYW1lKSB7XHJcbiAgICAgIC8vIFRPRE86IEZseXR0YSB0aWxsIG1haW4uanNcclxuICAgICAgY29uc3QgYWN0aW9uQ29va2llID0gSUNBLmxlZ2FjeS5nZXRDb29raWUoY29va2llTmFtZSk7XHJcblxyXG4gICAgICBpZiAoIWFjdGlvbkNvb2tpZSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBJQ0EubGVnYWN5LmtpbGxDb29raWUoY29va2llTmFtZSk7XHJcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKGFjdGlvbkNvb2tpZSk7XHJcbiAgICB9LFxyXG4gICAgY2hlY2tBY3Rpb25Db29raWVzKCkge1xyXG4gICAgICBpZiAoIXRoaXMuaXNMb2dnZWRJbikgcmV0dXJuO1xyXG5cclxuICAgICAgY29uc3QgY291cG9uID0gdGhpcy5nZXRBY3Rpb25Db29raWUoQUNUSU9OX0NPT0tJRVMuTE9BRF9DT1VQT04pO1xyXG4gICAgICBpZiAoY291cG9uKSB7XHJcbiAgICAgICAgdGhpcy5sb2FkQ291cG9uT25DYXJkKGNvdXBvbikudGhlbigocmVzcG9uc2UpID0+IHtcclxuICAgICAgICAgIHRoaXMuY2hhbmdlT2ZmZXJTdGF0dXMocmVzcG9uc2UsIGNvdXBvbik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjaGFuZ2VPZmZlclN0YXR1cyhyZXNwb25zZSwgY291cG9uKSB7XHJcbiAgICAgIGlmIChyZXNwb25zZS5vaykge1xyXG4gICAgICAgICRFTE0uZ2V0KGAjY291cG9uLSR7Y291cG9uLk9mZmVySWR9LSR7Y291cG9uLnJlY2lwZUlkfWApLmNzcygnb2ZmZXItbG9hZGVkJyk7XHJcbiAgICAgICAgJEVMTS5nZXQoYCNjb3Vwb24tJHtjb3Vwb24uT2ZmZXJJZH0tJHtjb3Vwb24ucmVjaXBlSWR9IC5jb3Vwb24tYnV0dG9uYCkudGV4dCgnS3Vwb25nIGxhZGRhZCcpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgLy8gaG90amFyVHJpZ2dlcmVkOiBmYWxzZSxcclxuICAgIGxvYWRlcklzQWN0aXZlOiBmYWxzZSxcclxuICAgIGJ1dHRvbkhhbmRsZXJQb2xsVGltZW91dDogbnVsbCxcclxuICAgIHNob3dMb2FkZXIoKSB7XHJcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9ICQoJy5jcm8taWZyYW1lLWNvbnRhaW5lcicpO1xyXG4gICAgICBjb250YWluZXIuZmluZCgnLmxvYWRlcicpLnNob3coKTtcclxuICAgICAgY29udGFpbmVyLmZpbmQoJ2lmcmFtZScpLmNzcygnb3BhY2l0eScsICcwJyk7XHJcbiAgICAgIHRoaXMubG9hZGVySXNBY3RpdmUgPSB0cnVlO1xyXG4gICAgfSxcclxuICAgIGhpZGVMb2FkZXIoKSB7XHJcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9ICQoJy5jcm8taWZyYW1lLWNvbnRhaW5lcicpO1xyXG4gICAgICBjb250YWluZXIuZmluZCgnLmxvYWRlcicpLmhpZGUoKTtcclxuICAgICAgY29udGFpbmVyLmZpbmQoJ2lmcmFtZScpLmNzcygnb3BhY2l0eScsICcxJyk7XHJcbiAgICAgIHRoaXMubG9hZGVySXNBY3RpdmUgPSBmYWxzZTtcclxuICAgIH0sXHJcbiAgICBhZGRCdXR0b25IYW5kbGVyUG9sbCgpIHtcclxuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcbiAgICAgIGNvbnN0IGlmcmFtZSA9ICQoJy5jcm8taWZyYW1lLWNvbnRhaW5lciBpZnJhbWUnKTtcclxuICAgICAgY29uc3QgZSA9IGlmcmFtZS5jb250ZW50cygpLmZpbmQoJy5yZW1vZGFsLXdyYXBwZXIgI2dyZXktY2FyZC1idG4sIC5yZW1vZGFsLXdyYXBwZXIgLnBpbmstY2FyZC1idG4nKTtcclxuXHJcbiAgICAgIGlmIChlLmxlbmd0aCkge1xyXG4gICAgICAgIGUuY2xpY2soKCkgPT4ge1xyXG4gICAgICAgICAgc2VsZi5zaG93TG9hZGVyKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChzZWxmLmJ1dHRvbkhhbmRsZXJQb2xsVGltZW91dCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2VsZi5idXR0b25IYW5kbGVyUG9sbFRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChcclxuICAgICAgICAgIHNlbGYuYWRkQnV0dG9uSGFuZGxlclBvbGwuYmluZChzZWxmKSxcclxuICAgICAgICAgIDEwMDAsXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIGFkZEV2ZW50TGlzdGVuZXJzKCkge1xyXG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICQoJy5oZWFkZXInKS5vZmYoJ21vdXNlZG93bicpO1xyXG5cclxuICAgICAgJCh3aW5kb3cpLm9uKCdtZXNzYWdlIG9ubWVzc2FnZScsIChlKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgb3JpZ2luID0gYCR7d2luZG93LmxvY2F0aW9uLnByb3RvY29sfS8vJHt3aW5kb3cubG9jYXRpb24uaG9zdH1gO1xyXG4gICAgICAgIGlmIChlLm9yaWdpbmFsRXZlbnQub3JpZ2luID09PSBvcmlnaW4gJiYgL21vYmlsZWJhbmtpZC9pLnRlc3QoZS5vcmlnaW5hbEV2ZW50LmRhdGEpKSB7XHJcbiAgICAgICAgICBzZWxmLnNob3dMb2FkZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIGdldElmcmFtZVN0eWxlcygpIHtcclxuICAgICAgcmV0dXJuIGA8c3R5bGUgdHlwZT1cInRleHQvY3NzXCI+XHJcbiAgICAgICAgQG1lZGlhICAobWF4LXdpZHRoOiA3NjdweCkge1xyXG4gICAgICAgIGgzLmdyZWV0aW5nLCBoMy5jYXJkLWhlYWRpbmcgeyBmb250LXNpemU6IDE4cHg7IH1cclxuICAgICAgICBpbWcuY2FyZC1pY29uIHsgd2lkdGg6IDUwcHg7IH1cclxuICAgICAgICAuc2VsZWN0LWNhcmQtbW9kYWwgeyBib3JkZXI6IDA7IHBhZGRpbmc6IDA7IG1hcmdpbjogMDsgfVxyXG4gICAgICAgIC5yZW1vZGFsLXdyYXBwZXIgeyBwYWRkaW5nOiAwOyB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIDwvc3R5bGU+YDtcclxuICAgIH0sXHJcbiAgICBjcmVhdGVNb2RhbChhY3Rpb24gPSBMT0dJTl9BQ1RJT04uU0FWRV9SRUNJUEUpIHtcclxuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcbiAgICAgIGNvbnN0IG1vZGFsID0gbmV3IGNvcmVDb21wb25lbnRzLm1vZGFsKHtcclxuICAgICAgICB0cGw6ICQoJy5jcm8taWZyYW1lLWNvbnRhaW5lcicpLmdldCgwKSxcclxuICAgICAgICBzaXplOiAnbWQnLFxyXG4gICAgICAgIGNvbnRhaW5lcjogJCgnLm1vZGFsLWNvbnRhaW5lcicpLmdldCgwKSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICBzZWxmLnNob3dMb2FkZXIoKTtcclxuXHJcbiAgICAgICAgY29uc3QgaWZyYW1lID0gJCgnLmNyby1pZnJhbWUtY29udGFpbmVyIGlmcmFtZScpO1xyXG5cclxuICAgICAgICBpZnJhbWUub24oJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoYF4ke3dpbmRvdy5sb2NhdGlvbi5ocmVmfSRgLCAnZ2knKTtcclxuICAgICAgICAgIGlmIChyZWdleC50ZXN0KHRoaXMuY29udGVudFdpbmRvdy5sb2NhdGlvbikpIHtcclxuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCh0cnVlKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAodGhpcy5jb250ZW50V2luZG93LmxvY2F0aW9uLmhyZWYuaW5kZXhPZignbG9nZ2EtaW4nKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgbGV0IGhlYWRlckJhclRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChoaWRlSGVhZGVyQmFyLCAxMCk7XHJcbiAgICAgICAgICAgIGxldCBhcHBlbmRIZWFkZXJUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoYXBwZW5kSGVhZGVyLCAxMCk7XHJcbiAgICAgICAgICAgIGxldCBhZGRTdHlsZXNUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoYWRkU3R5bGVzLCAxMCk7XHJcbiAgICAgICAgICAgIGxldCBhZGRJZnJhbWVUcmFja2luZ1RpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChhZGRJZnJhbWVUcmFja2luZywgMTApO1xyXG4gICAgICAgICAgICBjb25zdCBoaWRlSGVhZGVyQmFyRGVmZXJyZWQgPSAkLkRlZmVycmVkKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGFwcGVuZEhlYWRlckRlZmVycmVkID0gJC5EZWZlcnJlZCgpO1xyXG4gICAgICAgICAgICBjb25zdCBhZGRTdHlsZXNEZWZlcnJlZCA9ICQuRGVmZXJyZWQoKTtcclxuICAgICAgICAgICAgY29uc3QgYWRkSWZyYW1lVHJhY2tpbmdEZWZlcnJlZCA9ICQuRGVmZXJyZWQoKTtcclxuXHJcbiAgICAgICAgICAgICQud2hlbihcclxuICAgICAgICAgICAgICBoaWRlSGVhZGVyQmFyRGVmZXJyZWQsXHJcbiAgICAgICAgICAgICAgYXBwZW5kSGVhZGVyRGVmZXJyZWQsXHJcbiAgICAgICAgICAgICAgYWRkU3R5bGVzRGVmZXJyZWQsXHJcbiAgICAgICAgICAgICAgYWRkSWZyYW1lVHJhY2tpbmdEZWZlcnJlZCxcclxuICAgICAgICAgICAgKS5kb25lKCgpID0+IHtcclxuICAgICAgICAgICAgICBzZWxmLmhpZGVMb2FkZXIoKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBoaWRlSGVhZGVyQmFyKCkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IGUgPSAkKCcuY3JvLWlmcmFtZS1jb250YWluZXIgaWZyYW1lJykuY29udGVudHMoKS5maW5kKCcuaGVhZGVyLWJhcicpO1xyXG4gICAgICAgICAgICAgIGlmIChlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgZS5oaWRlKCk7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGhlYWRlckJhclRpbWVvdXQpO1xyXG4gICAgICAgICAgICAgICAgaGlkZUhlYWRlckJhckRlZmVycmVkLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaGVhZGVyQmFyVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGhpZGVIZWFkZXJCYXIsIDApO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gYXBwZW5kSGVhZGVyKCkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IGUgPSAkKCcuY3JvLWlmcmFtZS1jb250YWluZXIgaWZyYW1lJykuY29udGVudHMoKS5maW5kKCdoMScpO1xyXG4gICAgICAgICAgICAgIGlmIChlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IChhY3Rpb24gPT09IExPR0lOX0FDVElPTi5TQVZFX1JFQ0lQRSlcclxuICAgICAgICAgICAgICAgICAgPyAnIGbDtnIgYXR0IGzDpGdnYSB0aWxsIGkgaW5rw7Zwc2xpc3RhbiBvY2ggc3BhcmEgcmVjZXB0J1xyXG4gICAgICAgICAgICAgICAgICA6ICcgZsO2ciBhdHQgbGFkZGEga3Vwb25nZW4nO1xyXG4gICAgICAgICAgICAgICAgZS5hcHBlbmQobWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICBlLmNzcyh7ICdmb250LWZhbWlseSc6ICdpY2FoYW5kLCBhcmlhbCwgc2Fucy1zZXJpZicsICdmb250LXNpemUnOiAnM3JlbScgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5zY3JlZW4ud2lkdGggPCA3NjgpIHtcclxuICAgICAgICAgICAgICAgICAgZS5jc3MoJ2ZvbnQtc2l6ZScsICcxOHB4Jyk7XHJcbiAgICAgICAgICAgICAgICAgIGUucGFyZW50KCkuY3NzKCdtYXJnaW4nLCAnMCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChhcHBlbmRIZWFkZXJUaW1lb3V0KTtcclxuICAgICAgICAgICAgICAgIGFwcGVuZEhlYWRlckRlZmVycmVkLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYXBwZW5kSGVhZGVyVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGFwcGVuZEhlYWRlciwgMCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBhZGRTdHlsZXMoKSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgZSA9ICQoJy5jcm8taWZyYW1lLWNvbnRhaW5lciBpZnJhbWUnKS5jb250ZW50cygpLmZpbmQoJ2JvZHknKTtcclxuICAgICAgICAgICAgICBpZiAoZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGUuYXBwZW5kKHNlbGYuZ2V0SWZyYW1lU3R5bGVzKCkpO1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChhZGRTdHlsZXNUaW1lb3V0KTtcclxuICAgICAgICAgICAgICAgIGFkZFN0eWxlc0RlZmVycmVkLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYWRkU3R5bGVzVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGFkZFN0eWxlcywgMCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBhZGRJZnJhbWVUcmFja2luZygpIHtcclxuICAgICAgICAgICAgICBjb25zdCBlID0gJCgnLmNyby1pZnJhbWUtY29udGFpbmVyIGlmcmFtZScpLmNvbnRlbnRzKCk7XHJcbiAgICAgICAgICAgICAgaWYgKGUubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudEFjdGlvbiA9IChhY3Rpb24gPT09IExPR0lOX0FDVElPTi5TQVZFX1JFQ0lQRSlcclxuICAgICAgICAgICAgICAgICAgPyAnU3BhcmEgcmVjZXB0IGZyw6VuIHN0YXJ0c2lkYW4nXHJcbiAgICAgICAgICAgICAgICAgIDogJ0xhZGRhIGt1cG9uZyBmcsOlbiBzdGFydHNpZGEnO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZvcnRzw6R0dCAoTW9iaWx0IEJhbmtJZClcclxuICAgICAgICAgICAgICAgIGUuZmluZCgnI3N1Ym1pdC1sb2dpbi1tb2JpbGUtYmFuay1pZCcpLm9uKCdjbGljaycsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgZ2EoJ3NlbmQnLCAnZXZlbnQnLCAnQS9CJywgZXZlbnRBY3Rpb24sICdMb2dnYSBpbiAtIE1vYmlsdCBCYW5rSWQnKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEJlaMO2dmVyIGR1IGhqw6RscCAoTW9iaWx0IEJhbmtJZClcclxuICAgICAgICAgICAgICAgIGUuZmluZCgnLmxvZ2luLXN1cHBvcnQtYmFuay1pZC1saW5rJykub24oJ2NsaWNrJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICBnYSgnc2VuZCcsICdldmVudCcsICdBL0InLCBldmVudEFjdGlvbiwgJ0JlaMO2dmVyIGR1IGhqw6RscCcpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU2thcGEga29udG8gKE1vYmlsdCBCYW5rSWQpXHJcbiAgICAgICAgICAgICAgICBlLmZpbmQoJy5nZXQtbW9iaWxlLWJhbmstaWQtbGluaycpLm9uKCdjbGljaycsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgZ2EoJ3NlbmQnLCAnZXZlbnQnLCAnQS9CJywgZXZlbnRBY3Rpb24sICdTa2FwYSBrb250byAtIE1vYmlsdCBCYW5rSWQnKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIExvZ2dhIGluIChMw7ZzZW5vcmQpXHJcbiAgICAgICAgICAgICAgICBlLmZpbmQoJyNsb2ctaW4tc3VibWl0Jykub24oJ2NsaWNrJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICBnYSgnc2VuZCcsICdldmVudCcsICdBL0InLCBldmVudEFjdGlvbiwgJ0xvZ2dhIGluIC0gTMO2c2Vub3JkJyk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBHbMO2bXQgbMO2c2Vub3JkIChMw7ZzZW5vcmQpXHJcbiAgICAgICAgICAgICAgICBlLmZpbmQoJy5sb2dpbi1zdXBwb3J0LXBhc3N3b3JkLWxpbmsnKS5vbignY2xpY2snLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgIGdhKCdzZW5kJywgJ2V2ZW50JywgJ0EvQicsIGV2ZW50QWN0aW9uLCAnR2zDtm10IGzDtnNlbm9yZCcpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU2thcGEga29udG8gKEzDtnNlbm9yZClcclxuICAgICAgICAgICAgICAgIGUuZmluZCgnLmNyZWF0ZS1hY2NvdW50LWxpbmsnKS5vbignY2xpY2snLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgIGdhKCdzZW5kJywgJ2V2ZW50JywgJ0EvQicsIGV2ZW50QWN0aW9uLCAnU2thcGEga29udG8gLSBMw7ZzZW5vcmQnKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoYWRkSWZyYW1lVHJhY2tpbmdUaW1lb3V0KTtcclxuICAgICAgICAgICAgICAgIGFkZElmcmFtZVRyYWNraW5nRGVmZXJyZWQucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBhZGRJZnJhbWVUcmFja2luZ1RpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChhZGRJZnJhbWVUcmFja2luZywgMCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgJCgnLmNyby1pZnJhbWUtY29udGFpbmVyIGlmcmFtZScpLmNvbnRlbnRzKCkuZmluZCgnZm9ybScpLm9uKCdzdWJtaXQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghJCh0aGlzKS5maW5kKCdpbnB1dC5lcnJvcicpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgIHNlbGYuc2hvd0xvYWRlcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAkKCcuY3JvLWlmcmFtZS1jb250YWluZXIgaWZyYW1lJykuY29udGVudHMoKS5maW5kKCcjc3VibWl0LWxvZ2luLW1vYmlsZS1iYW5rLWlkJykub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoISQodGhpcykuZmluZCgnaW5wdXQuZXJyb3InKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICBzZWxmLmJ1dHRvbkhhbmRsZXJQb2xsVGltZW91dCA9IHNldFRpbWVvdXQoXHJcbiAgICAgICAgICAgICAgICBzZWxmLmFkZEJ1dHRvbkhhbmRsZXJQb2xsLmJpbmQoc2VsZiksXHJcbiAgICAgICAgICAgICAgICAxMDAwLFxyXG4gICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICQoJy5jcm8taWZyYW1lLWNvbnRhaW5lciBpZnJhbWUnKS5jb250ZW50cygpLmZpbmQoJ2FbaHJlZio9XCJ3d3cuaWNhLnNlXCJdJykuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICQodGhpcykuYXR0cignaHJlZicsICQodGhpcykuYXR0cignaHJlZicpLnJlcGxhY2UoJ2h0dHA6Ly8nLCAnaHR0cHM6Ly8nKSk7XHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuY2xpY2soZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9ICQodGhpcykuYXR0cignaHJlZicpO1xyXG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIHRyaWdnYSBob3RqYXIgaGVhdG1hcCBmw7Zyc3RhIGfDpW5nZW4gbW9kYWxlbiDDtnBwbmF0c1xyXG4gICAgICAgIC8vIGlmICh0eXBlb2YgaGogPT09ICdmdW5jdGlvbicgJiYgIXNlbGYuaG90amFyVHJpZ2dlcmVkKSB7XHJcbiAgICAgICAgLy8gICAgIGhqKCd0cmlnZ2VyJywgJ3ZhcmlhbnQnKTtcclxuICAgICAgICAvLyAgICAgc2VsZi5ob3RqYXJUcmlnZ2VyZWQgPSB0cnVlO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgfSwgNTApO1xyXG4gICAgfSxcclxuICAgIGxvYWRDb3Vwb25EYXRhKGNvdXBvbikge1xyXG4gICAgICByZXR1cm4gbG9hZGVkQ291cG9uc1tjb3Vwb24uT2ZmZXJJZF1cclxuICAgICAgICA/IFByb21pc2UucmVzb2x2ZShsb2FkZWRDb3Vwb25zW2NvdXBvbi5PZmZlcklkXSlcclxuICAgICAgICA6IHdpbmRvdy5mZXRjaChgL2FwaS9qc29uaHNlLyR7Y291cG9uLmlkfWAsIHsgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicgfSlcclxuICAgICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmpzb24oKSlcclxuICAgICAgICAgIC50aGVuKChqc29uKSA9PiB7XHJcbiAgICAgICAgICAgIGxvYWRlZENvdXBvbnNbY291cG9uLk9mZmVySWRdID0ganNvbjtcclxuICAgICAgICAgICAgcmV0dXJuIGpzb247XHJcbiAgICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICBsb2FkQ291cG9uT25DYXJkKGNvdXBvbikge1xyXG4gICAgICBjb25zdCBvcHRzID0ge1xyXG4gICAgICAgIE9mZmVySWQ6IGNvdXBvbi5PZmZlcklkLFxyXG4gICAgICAgIENhbXBhaWduSWQ6IGNvdXBvbi5DYW1wYWlnbklkLFxyXG4gICAgICAgIFN0b3JlSWQ6IDAsXHJcbiAgICAgICAgU3RvcmVHcm91cElkOiAwLFxyXG4gICAgICB9O1xyXG5cclxuICAgICAgcmV0dXJuIHdpbmRvdy5mZXRjaChcclxuICAgICAgICAnL2FwaS9qc29uaHNlL0NsYWltb2ZmZXInLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nLFxyXG4gICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgIEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KG9wdHMpLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICkudGhlbigocmVzcG9uc2UpID0+IHtcclxuICAgICAgICBpZiAocmVzcG9uc2Uub2spIHtcclxuICAgICAgICAgIGljYWRhdGFsYXllci5hZGQoJ0hTRScsIHtcclxuICAgICAgICAgICAgSFNFOiB7XHJcbiAgICAgICAgICAgICAgYWN0aW9uOiAnY291cG9uLWxvYWRlZCcsXHJcbiAgICAgICAgICAgICAgbmFtZTogY291cG9uLlBhZ2VOYW1lLFxyXG4gICAgICAgICAgICAgIG9mZmVyOiBjb3Vwb24udGl0bGUsXHJcbiAgICAgICAgICAgICAgaHNldXJsOiBjb3Vwb24udXJsLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXNwb25zZTtcclxuICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgcmVzZXRQYXJhbGxheFNjcm9sbGluZygpIHtcclxuICAgICAgSUNBLmljYUNhbGxiYWNrcy4kcGFyYWxsYXhDb250YWluZXJzID0gJCgnLnBhcmFsbGF4Jyk7XHJcbiAgICB9LFxyXG4gIH07XHJcblxyXG4gICQoZG9jdW1lbnQpLnJlYWR5KCgpID0+IHtcclxuICAgIGNvbnN0IElDID0gSUNBQ1JPKCk7XHJcbiAgICBpZiAoL15odHRwczpcXC9cXC93d3cuaWNhLnNlXFwvJC8udGVzdCh3aW5kb3cubG9jYXRpb24pKSB7XHJcbiAgICAgIE9iamVjdC5hc3NpZ24odGVzdCwgSUMpO1xyXG4gICAgICB0ZXN0LmNoZWNrQWN0aW9uQ29va2llcygpO1xyXG4gICAgICB0ZXN0Lm1hbmlwdWxhdGVEb20oKTtcclxuICAgICAgdGVzdC5hZGRFdmVudExpc3RlbmVycygpO1xyXG4gICAgICB0ZXN0LnJlc2V0UGFyYWxsYXhTY3JvbGxpbmcoKTtcclxuICAgIH1cclxuICAgIGlmICgvXmh0dHBzOlxcL1xcL3d3dy5pY2Euc2VcXC9lcmJqdWRhbmRlblxcL2J1dGlrc2VyYmp1ZGFuZGVuXFwvYWxsYS1kaWdpdGFsYS1rdXBvbmdlclxcLyQvLnRlc3Qod2luZG93LmxvY2F0aW9uKSkge1xyXG4gICAgICBjb3Vwb25zLm1hbmlwdWxhdGVEb20oSUMsICgpID0+IHtcclxuICAgICAgICB0ZXN0LmNyZWF0ZU1vZGFsKExPR0lOX0FDVElPTi5MT0FEX0NPVVBPTik7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KShqUXVlcnkpO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc3RhcnQtcGFnZS92YXJpYW50LmpzIiwicmVxdWlyZSgnLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnByb21pc2UnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3LnByb21pc2UuZmluYWxseScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcucHJvbWlzZS50cnknKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9fY29yZScpLlByb21pc2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vcHJvbWlzZS5qc1xuLy8gbW9kdWxlIGlkID0gNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuLy8gdHJ1ZSAgLT4gU3RyaW5nI2F0XG4vLyBmYWxzZSAtPiBTdHJpbmcjY29kZVBvaW50QXRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRPX1NUUklORykge1xuICByZXR1cm4gZnVuY3Rpb24gKHRoYXQsIHBvcykge1xuICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpO1xuICAgIHZhciBpID0gdG9JbnRlZ2VyKHBvcyk7XG4gICAgdmFyIGwgPSBzLmxlbmd0aDtcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAoaSA8IDAgfHwgaSA+PSBsKSByZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgYSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsIHx8IChiID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgYiA+IDB4ZGZmZlxuICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcbiAgICAgIDogVE9fU1RSSU5HID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zdHJpbmctYXQuanNcbi8vIG1vZHVsZSBpZCA9IDU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnZGl2JyksICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBTKSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICghUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1wcmltaXRpdmUuanNcbi8vIG1vZHVsZSBpZCA9IDU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faGlkZScpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3JlZGVmaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSA1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGRlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19oaWRlJykoSXRlcmF0b3JQcm90b3R5cGUsIHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpIHtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7IG5leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBkUHMgPSByZXF1aXJlKCcuL19vYmplY3QtZHBzJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG52YXIgRW1wdHkgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdpZnJhbWUnKTtcbiAgdmFyIGkgPSBlbnVtQnVnS2V5cy5sZW5ndGg7XG4gIHZhciBsdCA9ICc8JztcbiAgdmFyIGd0ID0gJz4nO1xuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICByZXF1aXJlKCcuL19odG1sJykuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0Oic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2NyaXB0LXVybFxuICAvLyBjcmVhdGVEaWN0ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuT2JqZWN0O1xuICAvLyBodG1sLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUobHQgKyAnc2NyaXB0JyArIGd0ICsgJ2RvY3VtZW50LkY9T2JqZWN0JyArIGx0ICsgJy9zY3JpcHQnICsgZ3QpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICBjcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjtcbiAgd2hpbGUgKGktLSkgZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5KCk7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1jcmVhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyA9IGdldEtleXMoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgUDtcbiAgd2hpbGUgKGxlbmd0aCA+IGkpIGRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XG4gIHJldHVybiBPO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHBzLmpzXG4vLyBtb2R1bGUgaWQgPSA2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGFycmF5SW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JT2JqZWN0KG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSBpZiAoa2V5ICE9IElFX1BST1RPKSBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qc1xuLy8gbW9kdWxlIGlkID0gNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pIHtcbiAgICAgIGlmIChPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanNcbi8vIG1vZHVsZSBpZCA9IDYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWFic29sdXRlLWluZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjIuOSAvIDE1LjIuMy4yIE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiAoTykge1xuICBPID0gdG9PYmplY3QoTyk7XG4gIGlmIChoYXMoTywgSUVfUFJPVE8pKSByZXR1cm4gT1tJRV9QUk9UT107XG4gIGlmICh0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG8gOiBudWxsO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ3BvLmpzXG4vLyBtb2R1bGUgaWQgPSA2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpO1xudmFyIHN0ZXAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5cbi8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKClcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUua2V5cygpXG4vLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpXG4vLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgTyA9IHRoaXMuX3Q7XG4gIHZhciBraW5kID0gdGhpcy5faztcbiAgdmFyIGluZGV4ID0gdGhpcy5faSsrO1xuICBpZiAoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpIHtcbiAgICB0aGlzLl90ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzdGVwKDEpO1xuICB9XG4gIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHN0ZXAoMCwgaW5kZXgpO1xuICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xuICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanNcbi8vIG1vZHVsZSBpZCA9IDY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRvbmUsIHZhbHVlKSB7XG4gIHJldHVybiB7IHZhbHVlOiB2YWx1ZSwgZG9uZTogISFkb25lIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItc3RlcC5qc1xuLy8gbW9kdWxlIGlkID0gNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG52YXIgdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXQ7XG52YXIgbWljcm90YXNrID0gcmVxdWlyZSgnLi9fbWljcm90YXNrJykoKTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSA9IHJlcXVpcmUoJy4vX25ldy1wcm9taXNlLWNhcGFiaWxpdHknKTtcbnZhciBwZXJmb3JtID0gcmVxdWlyZSgnLi9fcGVyZm9ybScpO1xudmFyIHByb21pc2VSZXNvbHZlID0gcmVxdWlyZSgnLi9fcHJvbWlzZS1yZXNvbHZlJyk7XG52YXIgUFJPTUlTRSA9ICdQcm9taXNlJztcbnZhciBUeXBlRXJyb3IgPSBnbG9iYWwuVHlwZUVycm9yO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciAkUHJvbWlzZSA9IGdsb2JhbFtQUk9NSVNFXTtcbnZhciBpc05vZGUgPSBjbGFzc29mKHByb2Nlc3MpID09ICdwcm9jZXNzJztcbnZhciBlbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBJbnRlcm5hbCwgbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5LCBPd25Qcm9taXNlQ2FwYWJpbGl0eSwgV3JhcHBlcjtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlLmY7XG5cbnZhciBVU0VfTkFUSVZFID0gISFmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgLy8gY29ycmVjdCBzdWJjbGFzc2luZyB3aXRoIEBAc3BlY2llcyBzdXBwb3J0XG4gICAgdmFyIHByb21pc2UgPSAkUHJvbWlzZS5yZXNvbHZlKDEpO1xuICAgIHZhciBGYWtlUHJvbWlzZSA9IChwcm9taXNlLmNvbnN0cnVjdG9yID0ge30pW3JlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyldID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgICAgIGV4ZWMoZW1wdHksIGVtcHR5KTtcbiAgICB9O1xuICAgIC8vIHVuaGFuZGxlZCByZWplY3Rpb25zIHRyYWNraW5nIHN1cHBvcnQsIE5vZGVKUyBQcm9taXNlIHdpdGhvdXQgaXQgZmFpbHMgQEBzcGVjaWVzIHRlc3RcbiAgICByZXR1cm4gKGlzTm9kZSB8fCB0eXBlb2YgUHJvbWlzZVJlamVjdGlvbkV2ZW50ID09ICdmdW5jdGlvbicpICYmIHByb21pc2UudGhlbihlbXB0eSkgaW5zdGFuY2VvZiBGYWtlUHJvbWlzZTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG59KCk7XG5cbi8vIGhlbHBlcnNcbnZhciBpc1RoZW5hYmxlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmIHR5cGVvZiAodGhlbiA9IGl0LnRoZW4pID09ICdmdW5jdGlvbicgPyB0aGVuIDogZmFsc2U7XG59O1xudmFyIG5vdGlmeSA9IGZ1bmN0aW9uIChwcm9taXNlLCBpc1JlamVjdCkge1xuICBpZiAocHJvbWlzZS5fbikgcmV0dXJuO1xuICBwcm9taXNlLl9uID0gdHJ1ZTtcbiAgdmFyIGNoYWluID0gcHJvbWlzZS5fYztcbiAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92O1xuICAgIHZhciBvayA9IHByb21pc2UuX3MgPT0gMTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHJ1biA9IGZ1bmN0aW9uIChyZWFjdGlvbikge1xuICAgICAgdmFyIGhhbmRsZXIgPSBvayA/IHJlYWN0aW9uLm9rIDogcmVhY3Rpb24uZmFpbDtcbiAgICAgIHZhciByZXNvbHZlID0gcmVhY3Rpb24ucmVzb2x2ZTtcbiAgICAgIHZhciByZWplY3QgPSByZWFjdGlvbi5yZWplY3Q7XG4gICAgICB2YXIgZG9tYWluID0gcmVhY3Rpb24uZG9tYWluO1xuICAgICAgdmFyIHJlc3VsdCwgdGhlbjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgaWYgKCFvaykge1xuICAgICAgICAgICAgaWYgKHByb21pc2UuX2ggPT0gMikgb25IYW5kbGVVbmhhbmRsZWQocHJvbWlzZSk7XG4gICAgICAgICAgICBwcm9taXNlLl9oID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhhbmRsZXIgPT09IHRydWUpIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGRvbWFpbikgZG9tYWluLmVudGVyKCk7XG4gICAgICAgICAgICByZXN1bHQgPSBoYW5kbGVyKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChkb21haW4pIGRvbWFpbi5leGl0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2UpIHtcbiAgICAgICAgICAgIHJlamVjdChUeXBlRXJyb3IoJ1Byb21pc2UtY2hhaW4gY3ljbGUnKSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGVuID0gaXNUaGVuYWJsZShyZXN1bHQpKSB7XG4gICAgICAgICAgICB0aGVuLmNhbGwocmVzdWx0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSByZWplY3QodmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB3aGlsZSAoY2hhaW4ubGVuZ3RoID4gaSkgcnVuKGNoYWluW2krK10pOyAvLyB2YXJpYWJsZSBsZW5ndGggLSBjYW4ndCB1c2UgZm9yRWFjaFxuICAgIHByb21pc2UuX2MgPSBbXTtcbiAgICBwcm9taXNlLl9uID0gZmFsc2U7XG4gICAgaWYgKGlzUmVqZWN0ICYmICFwcm9taXNlLl9oKSBvblVuaGFuZGxlZChwcm9taXNlKTtcbiAgfSk7XG59O1xudmFyIG9uVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgdGFzay5jYWxsKGdsb2JhbCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3Y7XG4gICAgdmFyIHVuaGFuZGxlZCA9IGlzVW5oYW5kbGVkKHByb21pc2UpO1xuICAgIHZhciByZXN1bHQsIGhhbmRsZXIsIGNvbnNvbGU7XG4gICAgaWYgKHVuaGFuZGxlZCkge1xuICAgICAgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpc05vZGUpIHtcbiAgICAgICAgICBwcm9jZXNzLmVtaXQoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChoYW5kbGVyID0gZ2xvYmFsLm9udW5oYW5kbGVkcmVqZWN0aW9uKSB7XG4gICAgICAgICAgaGFuZGxlcih7IHByb21pc2U6IHByb21pc2UsIHJlYXNvbjogdmFsdWUgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoKGNvbnNvbGUgPSBnbG9iYWwuY29uc29sZSkgJiYgY29uc29sZS5lcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbicsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyBCcm93c2VycyBzaG91bGQgbm90IHRyaWdnZXIgYHJlamVjdGlvbkhhbmRsZWRgIGV2ZW50IGlmIGl0IHdhcyBoYW5kbGVkIGhlcmUsIE5vZGVKUyAtIHNob3VsZFxuICAgICAgcHJvbWlzZS5faCA9IGlzTm9kZSB8fCBpc1VuaGFuZGxlZChwcm9taXNlKSA/IDIgOiAxO1xuICAgIH0gcHJvbWlzZS5fYSA9IHVuZGVmaW5lZDtcbiAgICBpZiAodW5oYW5kbGVkICYmIHJlc3VsdC5lKSB0aHJvdyByZXN1bHQudjtcbiAgfSk7XG59O1xudmFyIGlzVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgaWYgKHByb21pc2UuX2ggPT0gMSkgcmV0dXJuIGZhbHNlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9hIHx8IHByb21pc2UuX2M7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlYWN0aW9uO1xuICB3aGlsZSAoY2hhaW4ubGVuZ3RoID4gaSkge1xuICAgIHJlYWN0aW9uID0gY2hhaW5baSsrXTtcbiAgICBpZiAocmVhY3Rpb24uZmFpbCB8fCAhaXNVbmhhbmRsZWQocmVhY3Rpb24ucHJvbWlzZSkpIHJldHVybiBmYWxzZTtcbiAgfSByZXR1cm4gdHJ1ZTtcbn07XG52YXIgb25IYW5kbGVVbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhhbmRsZXI7XG4gICAgaWYgKGlzTm9kZSkge1xuICAgICAgcHJvY2Vzcy5lbWl0KCdyZWplY3Rpb25IYW5kbGVkJywgcHJvbWlzZSk7XG4gICAgfSBlbHNlIGlmIChoYW5kbGVyID0gZ2xvYmFsLm9ucmVqZWN0aW9uaGFuZGxlZCkge1xuICAgICAgaGFuZGxlcih7IHByb21pc2U6IHByb21pc2UsIHJlYXNvbjogcHJvbWlzZS5fdiB9KTtcbiAgICB9XG4gIH0pO1xufTtcbnZhciAkcmVqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHZhciBwcm9taXNlID0gdGhpcztcbiAgaWYgKHByb21pc2UuX2QpIHJldHVybjtcbiAgcHJvbWlzZS5fZCA9IHRydWU7XG4gIHByb21pc2UgPSBwcm9taXNlLl93IHx8IHByb21pc2U7IC8vIHVud3JhcFxuICBwcm9taXNlLl92ID0gdmFsdWU7XG4gIHByb21pc2UuX3MgPSAyO1xuICBpZiAoIXByb21pc2UuX2EpIHByb21pc2UuX2EgPSBwcm9taXNlLl9jLnNsaWNlKCk7XG4gIG5vdGlmeShwcm9taXNlLCB0cnVlKTtcbn07XG52YXIgJHJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIHByb21pc2UgPSB0aGlzO1xuICB2YXIgdGhlbjtcbiAgaWYgKHByb21pc2UuX2QpIHJldHVybjtcbiAgcHJvbWlzZS5fZCA9IHRydWU7XG4gIHByb21pc2UgPSBwcm9taXNlLl93IHx8IHByb21pc2U7IC8vIHVud3JhcFxuICB0cnkge1xuICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkgdGhyb3cgVHlwZUVycm9yKFwiUHJvbWlzZSBjYW4ndCBiZSByZXNvbHZlZCBpdHNlbGZcIik7XG4gICAgaWYgKHRoZW4gPSBpc1RoZW5hYmxlKHZhbHVlKSkge1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSB7IF93OiBwcm9taXNlLCBfZDogZmFsc2UgfTsgLy8gd3JhcFxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoZW4uY2FsbCh2YWx1ZSwgY3R4KCRyZXNvbHZlLCB3cmFwcGVyLCAxKSwgY3R4KCRyZWplY3QsIHdyYXBwZXIsIDEpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICRyZWplY3QuY2FsbCh3cmFwcGVyLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgICAgIHByb21pc2UuX3MgPSAxO1xuICAgICAgbm90aWZ5KHByb21pc2UsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAkcmVqZWN0LmNhbGwoeyBfdzogcHJvbWlzZSwgX2Q6IGZhbHNlIH0sIGUpOyAvLyB3cmFwXG4gIH1cbn07XG5cbi8vIGNvbnN0cnVjdG9yIHBvbHlmaWxsXG5pZiAoIVVTRV9OQVRJVkUpIHtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgJFByb21pc2UgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkUHJvbWlzZSwgUFJPTUlTRSwgJ19oJyk7XG4gICAgYUZ1bmN0aW9uKGV4ZWN1dG9yKTtcbiAgICBJbnRlcm5hbC5jYWxsKHRoaXMpO1xuICAgIHRyeSB7XG4gICAgICBleGVjdXRvcihjdHgoJHJlc29sdmUsIHRoaXMsIDEpLCBjdHgoJHJlamVjdCwgdGhpcywgMSkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgJHJlamVjdC5jYWxsKHRoaXMsIGVycik7XG4gICAgfVxuICB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgSW50ZXJuYWwgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgdGhpcy5fYyA9IFtdOyAgICAgICAgICAgICAvLyA8LSBhd2FpdGluZyByZWFjdGlvbnNcbiAgICB0aGlzLl9hID0gdW5kZWZpbmVkOyAgICAgIC8vIDwtIGNoZWNrZWQgaW4gaXNVbmhhbmRsZWQgcmVhY3Rpb25zXG4gICAgdGhpcy5fcyA9IDA7ICAgICAgICAgICAgICAvLyA8LSBzdGF0ZVxuICAgIHRoaXMuX2QgPSBmYWxzZTsgICAgICAgICAgLy8gPC0gZG9uZVxuICAgIHRoaXMuX3YgPSB1bmRlZmluZWQ7ICAgICAgLy8gPC0gdmFsdWVcbiAgICB0aGlzLl9oID0gMDsgICAgICAgICAgICAgIC8vIDwtIHJlamVjdGlvbiBzdGF0ZSwgMCAtIGRlZmF1bHQsIDEgLSBoYW5kbGVkLCAyIC0gdW5oYW5kbGVkXG4gICAgdGhpcy5fbiA9IGZhbHNlOyAgICAgICAgICAvLyA8LSBub3RpZnlcbiAgfTtcbiAgSW50ZXJuYWwucHJvdG90eXBlID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJykoJFByb21pc2UucHJvdG90eXBlLCB7XG4gICAgLy8gMjUuNC41LjMgUHJvbWlzZS5wcm90b3R5cGUudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZClcbiAgICB0aGVuOiBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICB2YXIgcmVhY3Rpb24gPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgJFByb21pc2UpKTtcbiAgICAgIHJlYWN0aW9uLm9rID0gdHlwZW9mIG9uRnVsZmlsbGVkID09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IHRydWU7XG4gICAgICByZWFjdGlvbi5mYWlsID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT0gJ2Z1bmN0aW9uJyAmJiBvblJlamVjdGVkO1xuICAgICAgcmVhY3Rpb24uZG9tYWluID0gaXNOb2RlID8gcHJvY2Vzcy5kb21haW4gOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9jLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYgKHRoaXMuX2EpIHRoaXMuX2EucHVzaChyZWFjdGlvbik7XG4gICAgICBpZiAodGhpcy5fcykgbm90aWZ5KHRoaXMsIGZhbHNlKTtcbiAgICAgIHJldHVybiByZWFjdGlvbi5wcm9taXNlO1xuICAgIH0sXG4gICAgLy8gMjUuNC41LjEgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2gob25SZWplY3RlZClcbiAgICAnY2F0Y2gnOiBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgfSk7XG4gIE93blByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9taXNlID0gbmV3IEludGVybmFsKCk7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB0aGlzLnJlc29sdmUgPSBjdHgoJHJlc29sdmUsIHByb21pc2UsIDEpO1xuICAgIHRoaXMucmVqZWN0ID0gY3R4KCRyZWplY3QsIHByb21pc2UsIDEpO1xuICB9O1xuICBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoQykge1xuICAgIHJldHVybiBDID09PSAkUHJvbWlzZSB8fCBDID09PSBXcmFwcGVyXG4gICAgICA/IG5ldyBPd25Qcm9taXNlQ2FwYWJpbGl0eShDKVxuICAgICAgOiBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gIH07XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHsgUHJvbWlzZTogJFByb21pc2UgfSk7XG5yZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpKCRQcm9taXNlLCBQUk9NSVNFKTtcbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoUFJPTUlTRSk7XG5XcmFwcGVyID0gcmVxdWlyZSgnLi9fY29yZScpW1BST01JU0VdO1xuXG4vLyBzdGF0aWNzXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC41IFByb21pc2UucmVqZWN0KHIpXG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpIHtcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHRoaXMpO1xuICAgIHZhciAkJHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgICQkcmVqZWN0KHIpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTElCUkFSWSB8fCAhVVNFX05BVElWRSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjYgUHJvbWlzZS5yZXNvbHZlKHgpXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCkge1xuICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZShMSUJSQVJZICYmIHRoaXMgPT09IFdyYXBwZXIgPyAkUHJvbWlzZSA6IHRoaXMsIHgpO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIShVU0VfTkFUSVZFICYmIHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24gKGl0ZXIpIHtcbiAgJFByb21pc2UuYWxsKGl0ZXIpWydjYXRjaCddKGVtcHR5KTtcbn0pKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuMSBQcm9taXNlLmFsbChpdGVyYWJsZSlcbiAgYWxsOiBmdW5jdGlvbiBhbGwoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgICB2YXIgcmVzb2x2ZSA9IGNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciByZW1haW5pbmcgPSAxO1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICB2YXIgJGluZGV4ID0gaW5kZXgrKztcbiAgICAgICAgdmFyIGFscmVhZHlDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFsdWVzLnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgcmVtYWluaW5nKys7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIGlmIChhbHJlYWR5Q2FsbGVkKSByZXR1cm47XG4gICAgICAgICAgYWxyZWFkeUNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgdmFsdWVzWyRpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmUpIHJlamVjdChyZXN1bHQudik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfSxcbiAgLy8gMjUuNC40LjQgUHJvbWlzZS5yYWNlKGl0ZXJhYmxlKVxuICByYWNlOiBmdW5jdGlvbiByYWNlKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oY2FwYWJpbGl0eS5yZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lKSByZWplY3QocmVzdWx0LnYpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnByb21pc2UuanNcbi8vIG1vZHVsZSBpZCA9IDY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBDb25zdHJ1Y3RvciwgbmFtZSwgZm9yYmlkZGVuRmllbGQpIHtcbiAgaWYgKCEoaXQgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikgfHwgKGZvcmJpZGRlbkZpZWxkICE9PSB1bmRlZmluZWQgJiYgZm9yYmlkZGVuRmllbGQgaW4gaXQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKG5hbWUgKyAnOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLWluc3RhbmNlLmpzXG4vLyBtb2R1bGUgaWQgPSA3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4vX2l0ZXItY2FsbCcpO1xudmFyIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBnZXRJdGVyRm4gPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xudmFyIEJSRUFLID0ge307XG52YXIgUkVUVVJOID0ge307XG52YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCBlbnRyaWVzLCBmbiwgdGhhdCwgSVRFUkFUT1IpIHtcbiAgdmFyIGl0ZXJGbiA9IElURVJBVE9SID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXRlcmFibGU7IH0gOiBnZXRJdGVyRm4oaXRlcmFibGUpO1xuICB2YXIgZiA9IGN0eChmbiwgdGhhdCwgZW50cmllcyA/IDIgOiAxKTtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxlbmd0aCwgc3RlcCwgaXRlcmF0b3IsIHJlc3VsdDtcbiAgaWYgKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ZXJhYmxlICsgJyBpcyBub3QgaXRlcmFibGUhJyk7XG4gIC8vIGZhc3QgY2FzZSBmb3IgYXJyYXlzIHdpdGggZGVmYXVsdCBpdGVyYXRvclxuICBpZiAoaXNBcnJheUl0ZXIoaXRlckZuKSkgZm9yIChsZW5ndGggPSB0b0xlbmd0aChpdGVyYWJsZS5sZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgIHJlc3VsdCA9IGVudHJpZXMgPyBmKGFuT2JqZWN0KHN0ZXAgPSBpdGVyYWJsZVtpbmRleF0pWzBdLCBzdGVwWzFdKSA6IGYoaXRlcmFibGVbaW5kZXhdKTtcbiAgICBpZiAocmVzdWx0ID09PSBCUkVBSyB8fCByZXN1bHQgPT09IFJFVFVSTikgcmV0dXJuIHJlc3VsdDtcbiAgfSBlbHNlIGZvciAoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChpdGVyYWJsZSk7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTspIHtcbiAgICByZXN1bHQgPSBjYWxsKGl0ZXJhdG9yLCBmLCBzdGVwLnZhbHVlLCBlbnRyaWVzKTtcbiAgICBpZiAocmVzdWx0ID09PSBCUkVBSyB8fCByZXN1bHQgPT09IFJFVFVSTikgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcbmV4cG9ydHMuQlJFQUsgPSBCUkVBSztcbmV4cG9ydHMuUkVUVVJOID0gUkVUVVJOO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Zvci1vZi5qc1xuLy8gbW9kdWxlIGlkID0gNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gZmFzdCBhcHBseSwgaHR0cDovL2pzcGVyZi5sbmtpdC5jb20vZmFzdC1hcHBseS81XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgYXJncywgdGhhdCkge1xuICB2YXIgdW4gPSB0aGF0ID09PSB1bmRlZmluZWQ7XG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiB1biA/IGZuKClcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCk7XG4gICAgY2FzZSAxOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgY2FzZSA0OiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgfSByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJncyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2ludm9rZS5qc1xuLy8gbW9kdWxlIGlkID0gNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIG1hY3JvdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXQ7XG52YXIgT2JzZXJ2ZXIgPSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgUHJvbWlzZSA9IGdsb2JhbC5Qcm9taXNlO1xudmFyIGlzTm9kZSA9IHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBoZWFkLCBsYXN0LCBub3RpZnk7XG5cbiAgdmFyIGZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXJlbnQsIGZuO1xuICAgIGlmIChpc05vZGUgJiYgKHBhcmVudCA9IHByb2Nlc3MuZG9tYWluKSkgcGFyZW50LmV4aXQoKTtcbiAgICB3aGlsZSAoaGVhZCkge1xuICAgICAgZm4gPSBoZWFkLmZuO1xuICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZuKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChoZWFkKSBub3RpZnkoKTtcbiAgICAgICAgZWxzZSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gbGFzdCA9IHVuZGVmaW5lZDtcbiAgICBpZiAocGFyZW50KSBwYXJlbnQuZW50ZXIoKTtcbiAgfTtcblxuICAvLyBOb2RlLmpzXG4gIGlmIChpc05vZGUpIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgICB9O1xuICAvLyBicm93c2VycyB3aXRoIE11dGF0aW9uT2JzZXJ2ZXJcbiAgfSBlbHNlIGlmIChPYnNlcnZlcikge1xuICAgIHZhciB0b2dnbGUgPSB0cnVlO1xuICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIG5ldyBPYnNlcnZlcihmbHVzaCkub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgbm9kZS5kYXRhID0gdG9nZ2xlID0gIXRvZ2dsZTtcbiAgICB9O1xuICAvLyBlbnZpcm9ubWVudHMgd2l0aCBtYXliZSBub24tY29tcGxldGVseSBjb3JyZWN0LCBidXQgZXhpc3RlbnQgUHJvbWlzZVxuICB9IGVsc2UgaWYgKFByb21pc2UgJiYgUHJvbWlzZS5yZXNvbHZlKSB7XG4gICAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9taXNlLnRoZW4oZmx1c2gpO1xuICAgIH07XG4gIC8vIGZvciBvdGhlciBlbnZpcm9ubWVudHMgLSBtYWNyb3Rhc2sgYmFzZWQgb246XG4gIC8vIC0gc2V0SW1tZWRpYXRlXG4gIC8vIC0gTWVzc2FnZUNoYW5uZWxcbiAgLy8gLSB3aW5kb3cucG9zdE1lc3NhZ1xuICAvLyAtIG9ucmVhZHlzdGF0ZWNoYW5nZVxuICAvLyAtIHNldFRpbWVvdXRcbiAgfSBlbHNlIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBzdHJhbmdlIElFICsgd2VicGFjayBkZXYgc2VydmVyIGJ1ZyAtIHVzZSAuY2FsbChnbG9iYWwpXG4gICAgICBtYWNyb3Rhc2suY2FsbChnbG9iYWwsIGZsdXNoKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgIHZhciB0YXNrID0geyBmbjogZm4sIG5leHQ6IHVuZGVmaW5lZCB9O1xuICAgIGlmIChsYXN0KSBsYXN0Lm5leHQgPSB0YXNrO1xuICAgIGlmICghaGVhZCkge1xuICAgICAgaGVhZCA9IHRhc2s7XG4gICAgICBub3RpZnkoKTtcbiAgICB9IGxhc3QgPSB0YXNrO1xuICB9O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19taWNyb3Rhc2suanNcbi8vIG1vZHVsZSBpZCA9IDczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzcmMsIHNhZmUpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGlmIChzYWZlICYmIHRhcmdldFtrZXldKSB0YXJnZXRba2V5XSA9IHNyY1trZXldO1xuICAgIGVsc2UgaGlkZSh0YXJnZXQsIGtleSwgc3JjW2tleV0pO1xuICB9IHJldHVybiB0YXJnZXQ7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3JlZGVmaW5lLWFsbC5qc1xuLy8gbW9kdWxlIGlkID0gNzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgU1BFQ0lFUyA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSkge1xuICB2YXIgQyA9IHR5cGVvZiBjb3JlW0tFWV0gPT0gJ2Z1bmN0aW9uJyA/IGNvcmVbS0VZXSA6IGdsb2JhbFtLRVldO1xuICBpZiAoREVTQ1JJUFRPUlMgJiYgQyAmJiAhQ1tTUEVDSUVTXSkgZFAuZihDLCBTUEVDSUVTLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfVxuICB9KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXNwZWNpZXMuanNcbi8vIG1vZHVsZSBpZCA9IDc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXByb21pc2UtZmluYWxseVxuJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKTtcbnZhciBwcm9taXNlUmVzb2x2ZSA9IHJlcXVpcmUoJy4vX3Byb21pc2UtcmVzb2x2ZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuUiwgJ1Byb21pc2UnLCB7ICdmaW5hbGx5JzogZnVuY3Rpb24gKG9uRmluYWxseSkge1xuICB2YXIgQyA9IHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCBjb3JlLlByb21pc2UgfHwgZ2xvYmFsLlByb21pc2UpO1xuICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiBvbkZpbmFsbHkgPT0gJ2Z1bmN0aW9uJztcbiAgcmV0dXJuIHRoaXMudGhlbihcbiAgICBpc0Z1bmN0aW9uID8gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZShDLCBvbkZpbmFsbHkoKSkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiB4OyB9KTtcbiAgICB9IDogb25GaW5hbGx5LFxuICAgIGlzRnVuY3Rpb24gPyBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKEMsIG9uRmluYWxseSgpKS50aGVuKGZ1bmN0aW9uICgpIHsgdGhyb3cgZTsgfSk7XG4gICAgfSA6IG9uRmluYWxseVxuICApO1xufSB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5wcm9taXNlLmZpbmFsbHkuanNcbi8vIG1vZHVsZSBpZCA9IDc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXByb21pc2UtdHJ5XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gcmVxdWlyZSgnLi9fbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xudmFyIHBlcmZvcm0gPSByZXF1aXJlKCcuL19wZXJmb3JtJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUHJvbWlzZScsIHsgJ3RyeSc6IGZ1bmN0aW9uIChjYWxsYmFja2ZuKSB7XG4gIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5LmYodGhpcyk7XG4gIHZhciByZXN1bHQgPSBwZXJmb3JtKGNhbGxiYWNrZm4pO1xuICAocmVzdWx0LmUgPyBwcm9taXNlQ2FwYWJpbGl0eS5yZWplY3QgOiBwcm9taXNlQ2FwYWJpbGl0eS5yZXNvbHZlKShyZXN1bHQudik7XG4gIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eS5wcm9taXNlO1xufSB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5wcm9taXNlLnRyeS5qc1xuLy8gbW9kdWxlIGlkID0gNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJyk7XG52YXIgJEpTT04gPSBjb3JlLkpTT04gfHwgKGNvcmUuSlNPTiA9IHsgc3RyaW5naWZ5OiBKU09OLnN0cmluZ2lmeSB9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3RyaW5naWZ5KGl0KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgcmV0dXJuICRKU09OLnN0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJndW1lbnRzKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vanNvbi9zdHJpbmdpZnkuanNcbi8vIG1vZHVsZSBpZCA9IDc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5hc3NpZ247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2Fzc2lnbi5qc1xuLy8gbW9kdWxlIGlkID0gNzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMS4zLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GLCAnT2JqZWN0JywgeyBhc3NpZ246IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKSB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzXG4vLyBtb2R1bGUgaWQgPSA4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyAxOS4xLjIuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlLCAuLi4pXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciAkYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG5tb2R1bGUuZXhwb3J0cyA9ICEkYXNzaWduIHx8IHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICB2YXIgQSA9IHt9O1xuICB2YXIgQiA9IHt9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgdmFyIFMgPSBTeW1ib2woKTtcbiAgdmFyIEsgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW1NdID0gNztcbiAgSy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoaykgeyBCW2tdID0gazsgfSk7XG4gIHJldHVybiAkYXNzaWduKHt9LCBBKVtTXSAhPSA3IHx8IE9iamVjdC5rZXlzKCRhc3NpZ24oe30sIEIpKS5qb2luKCcnKSAhPSBLO1xufSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgVCA9IHRvT2JqZWN0KHRhcmdldCk7XG4gIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMTtcbiAgdmFyIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIHZhciBpc0VudW0gPSBwSUUuZjtcbiAgd2hpbGUgKGFMZW4gPiBpbmRleCkge1xuICAgIHZhciBTID0gSU9iamVjdChhcmd1bWVudHNbaW5kZXgrK10pO1xuICAgIHZhciBrZXlzID0gZ2V0U3ltYm9scyA/IGdldEtleXMoUykuY29uY2F0KGdldFN5bWJvbHMoUykpIDogZ2V0S2V5cyhTKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGogPSAwO1xuICAgIHZhciBrZXk7XG4gICAgd2hpbGUgKGxlbmd0aCA+IGopIGlmIChpc0VudW0uY2FsbChTLCBrZXkgPSBrZXlzW2orK10pKSBUW2tleV0gPSBTW2tleV07XG4gIH0gcmV0dXJuIFQ7XG59IDogJGFzc2lnbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtYXNzaWduLmpzXG4vLyBtb2R1bGUgaWQgPSA4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BzLmpzXG4vLyBtb2R1bGUgaWQgPSA4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzLmYgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtcGllLmpzXG4vLyBtb2R1bGUgaWQgPSA4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vbnVtYmVyL2lzLWludGVnZXJcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvbnVtYmVyL2lzLWludGVnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm51bWJlci5pcy1pbnRlZ2VyJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5OdW1iZXIuaXNJbnRlZ2VyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL251bWJlci9pcy1pbnRlZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4xLjIuMyBOdW1iZXIuaXNJbnRlZ2VyKG51bWJlcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywgeyBpc0ludGVnZXI6IHJlcXVpcmUoJy4vX2lzLWludGVnZXInKSB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5udW1iZXIuaXMtaW50ZWdlci5qc1xuLy8gbW9kdWxlIGlkID0gODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjAuMS4yLjMgTnVtYmVyLmlzSW50ZWdlcihudW1iZXIpXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzSW50ZWdlcihpdCkge1xuICByZXR1cm4gIWlzT2JqZWN0KGl0KSAmJiBpc0Zpbml0ZShpdCkgJiYgZmxvb3IoaXQpID09PSBpdDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtaW50ZWdlci5qc1xuLy8gbW9kdWxlIGlkID0gODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9rZXlzXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSA4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3Qua2V5cycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LmtleXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2tleXMuanNcbi8vIG1vZHVsZSBpZCA9IDg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMi4xNCBPYmplY3Qua2V5cyhPKVxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2tleXMnLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBrZXlzKGl0KSB7XG4gICAgcmV0dXJuICRrZXlzKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3Qua2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gOTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gbW9zdCBPYmplY3QgbWV0aG9kcyBieSBFUzYgc2hvdWxkIGFjY2VwdCBwcmltaXRpdmVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZLCBleGVjKSB7XG4gIHZhciBmbiA9IChjb3JlLk9iamVjdCB8fCB7fSlbS0VZXSB8fCBPYmplY3RbS0VZXTtcbiAgdmFyIGV4cCA9IHt9O1xuICBleHBbS0VZXSA9IGV4ZWMoZm4pO1xuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uICgpIHsgZm4oMSk7IH0pLCAnT2JqZWN0JywgZXhwKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXNhcC5qc1xuLy8gbW9kdWxlIGlkID0gOTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5hcnJheS5mcm9tJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5BcnJheS5mcm9tO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL2FycmF5L2Zyb20uanNcbi8vIG1vZHVsZSBpZCA9IDkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJyk7XG52YXIgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2NyZWF0ZS1wcm9wZXJ0eScpO1xudmFyIGdldEl0ZXJGbiA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24gKGl0ZXIpIHsgQXJyYXkuZnJvbShpdGVyKTsgfSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4yLjEgQXJyYXkuZnJvbShhcnJheUxpa2UsIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICBmcm9tOiBmdW5jdGlvbiBmcm9tKGFycmF5TGlrZSAvKiAsIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkICovKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdChhcnJheUxpa2UpO1xuICAgIHZhciBDID0gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBBcnJheTtcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIG1hcGZuID0gYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGl0ZXJGbiA9IGdldEl0ZXJGbihPKTtcbiAgICB2YXIgbGVuZ3RoLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yO1xuICAgIGlmIChtYXBwaW5nKSBtYXBmbiA9IGN0eChtYXBmbiwgYUxlbiA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQsIDIpO1xuICAgIC8vIGlmIG9iamVjdCBpc24ndCBpdGVyYWJsZSBvciBpdCdzIGFycmF5IHdpdGggZGVmYXVsdCBpdGVyYXRvciAtIHVzZSBzaW1wbGUgY2FzZVxuICAgIGlmIChpdGVyRm4gIT0gdW5kZWZpbmVkICYmICEoQyA9PSBBcnJheSAmJiBpc0FycmF5SXRlcihpdGVyRm4pKSkge1xuICAgICAgZm9yIChpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKE8pLCByZXN1bHQgPSBuZXcgQygpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7IGluZGV4KyspIHtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IGNhbGwoaXRlcmF0b3IsIG1hcGZuLCBbc3RlcC52YWx1ZSwgaW5kZXhdLCB0cnVlKSA6IHN0ZXAudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgICBmb3IgKHJlc3VsdCA9IG5ldyBDKGxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBtYXBmbihPW2luZGV4XSwgaW5kZXgpIDogT1tpbmRleF0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQubGVuZ3RoID0gaW5kZXg7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuZnJvbS5qc1xuLy8gbW9kdWxlIGlkID0gOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgaW5kZXgsIHZhbHVlKSB7XG4gIGlmIChpbmRleCBpbiBvYmplY3QpICRkZWZpbmVQcm9wZXJ0eS5mKG9iamVjdCwgaW5kZXgsIGNyZWF0ZURlc2MoMCwgdmFsdWUpKTtcbiAgZWxzZSBvYmplY3RbaW5kZXhdID0gdmFsdWU7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NyZWF0ZS1wcm9wZXJ0eS5qc1xuLy8gbW9kdWxlIGlkID0gOTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZnJvbSA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL2FycmF5L2Zyb21cIik7XG5cbnZhciBfZnJvbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mcm9tKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgYXJyMltpXSA9IGFycltpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyMjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKDAsIF9mcm9tMi5kZWZhdWx0KShhcnIpO1xuICB9XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy90b0NvbnN1bWFibGVBcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL2lzLWl0ZXJhYmxlXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL2lzLWl0ZXJhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSA5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL2NvcmUuaXMtaXRlcmFibGUnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9pcy1pdGVyYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmlzSXRlcmFibGUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8gPSBPYmplY3QoaXQpO1xuICByZXR1cm4gT1tJVEVSQVRPUl0gIT09IHVuZGVmaW5lZFxuICAgIHx8ICdAQGl0ZXJhdG9yJyBpbiBPXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgIHx8IEl0ZXJhdG9ycy5oYXNPd25Qcm9wZXJ0eShjbGFzc29mKE8pKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmlzLWl0ZXJhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSA5OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vZ2V0LWl0ZXJhdG9yXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL2dldC1pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gOTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvcicpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL2dldC1pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMTAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGdldCA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvciA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgaXRlckZuID0gZ2V0KGl0KTtcbiAgaWYgKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgaXRlcmFibGUhJyk7XG4gIHJldHVybiBhbk9iamVjdChpdGVyRm4uY2FsbChpdCkpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKHN0YXJzKSB7XHJcbiAgY29uc3QgYXJyID0gWycwJywgJzI2JywgJzUyJywgJzc4JywgJzEwNCddO1xyXG4gIGNvbnN0IHN0cnMgPSBhcnIubWFwKCh4LCBpbmRleCkgPT4gKFxyXG4gICAgYDxnIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgke3h9IDApXCIgY2xhc3M9XCIke2luZGV4IDwgc3RhcnMgPyAnYWN0aXZlJyA6ICcnfVwiPlxyXG4gICAgICA8cGF0aCBkPVwiTTIzLjIgMTAuMzAzcS4xOTQuNTA5LS4wNzMuOTctMS4xODggMi4xODItNS4wNjcgNS40NzkgMS4wMTggNC4xOTQgMS4yMTIgNi43MTUuMDQ5LjY3OS0uNTMzIDEuMDY3LS4zMTUuMTk0LS42My4xOTQtLjI0MiAwLS41MzMtLjEyMS0uNDEyLS4yNDItMS4zMzMtLjY3OS0zLjI3My0xLjYyNC00LjYwNi0yLjQ3My0xLjMzMy44NDktNC42MDYgMi40NzMtLjkyMS40MzYtMS4zMzMuNjc5LS42MDYuMzE1LTEuMTY0LS4wNzMtLjU4Mi0uMzg4LS41MzMtMS4wNjcuMTk0LTIuNTIxIDEuMjEyLTYuNzE1LTMuODc5LTMuMjk3LTUuMDY3LTUuNDc5LS4yNjctLjQ2MS0uMDczLS45Ny4xNy0uNTA5LjYzLS42NzkgMS4zNTgtLjYwNiA2Ljg2MS0uOCAxLjk4OC01Ljc3IDMuMjQ4LTcuMDMuMzg4LS4zMzkuODI0LS4zMzkuNDYxIDAgLjguMzM5IDEuMjg1IDEuMjYxIDMuMjczIDcuMDMgNS41MDMuMTk0IDYuODYxLjguNDYxLjE5NC42My42Nzl6XCI+PC9wYXRoPlxyXG4gICAgICA8L2c+YCkpO1xyXG4gIHJldHVybiBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIi0wLjEyMDk5NjI2NjYwMzQ2OTg1IDEuNDU1MDAwMTYyMTI0NjMzOCAxMjcuMzk0MDAxMjE1Njk2MzMgMjUuMzQ2MDA0Njk0NzAwMjRcIj5cclxuICA8bGluZWFyR3JhZGllbnQgaWQ9XCJoYWxmXCIgeDE9XCIwXCIgeDI9XCIxMDAlXCIgeTE9XCIwXCIgeTI9XCIwXCI+XHJcbiAgPHN0b3Agb2Zmc2V0PVwiNTAlXCIgc3RvcC1jb2xvcj1cImN1cnJlbnRDb2xvclwiPjwvc3RvcD5cclxuICA8c3RvcCBvZmZzZXQ9XCI1MCVcIiBzdG9wLWNvbG9yPVwiI2Q1ZDdkYVwiPjwvc3RvcD5cclxuICA8L2xpbmVhckdyYWRpZW50PlxyXG4gICR7c3Rycy5qb2luKCcnKX1cclxuICA8L3N2Zz5gO1xyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy91dGlsL21vZHVsZXMvcmF0aW5ncy5qcyIsImV4cG9ydCBkZWZhdWx0IFtcclxuICB7XHJcbiAgICByZWNpcGVJZDogNzE4MzgyLFxyXG4gICAgdGl0bGU6ICdMYXNhZ25lIG1lZCBoYWxsb3VtaSwgc3BlbmF0IG9jaCBwdW1wYWvDpHJub3InLFxyXG4gICAgc3RhcnM6IDQsXHJcbiAgICBjb29rVGltZTogJzYwIE1JTiB8IE1FREVMJyxcclxuICAgIGltYWdlOiAnaHR0cHM6Ly93d3cuaWNhLnNlL2ltYWdldmF1bHRmaWxlcy9pZF8xMDY3MzQvY2ZfMjU5L2xhc2FnbmUtbWVkLWhhbGxvdW1pLXNwZW5hdC1vY2gtcHVtcGFrYXJub3ItNzE4MzgyLnBuZycsXHJcbiAgICB1cmw6ICdodHRwczovL3d3dy5pY2Euc2UvcmVjZXB0L2xhc2FnbmUtbWVkLWhhbGxvdW1pLXNwZW5hdC1vY2gtcHVtcGFrYXJub3ItNzE4MzgyLycsXHJcbiAgICBjb3Vwb25zOiBbXHJcbiAgICAgIHtcclxuICAgICAgICBpZDogNDU4Mjc4LFxyXG4gICAgICAgIHJlY2lwZUlkOiA3MTgzODIsXHJcbiAgICAgICAgdGl0bGU6ICdCw7ZucGFzdGEvIGxhc2FnbmVwbGF0dG9yJyxcclxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vd3d3LmljYS5zZS9IYW5kbGVycy9JbWFnZS5hc2h4P3c9MTUwJmg9MTUwJm09cCZiZ3I9ZmZmJnU9aHR0cDovL2V4dGJpbGQuaWNhLnNlLy9QaWN0dXJlV2ViLzgwLzEwMzAvMTRfMTAwMDU1NTMwOS5qcGcnLFxyXG4gICAgICAgIGRpc2NvdW50OiAnMjAlIHJhYmF0dCcsXHJcbiAgICAgICAgc3VidGl0bGU6ICdSaXNlbnRhIDEyMC0yMDAgZycsXHJcbiAgICAgICAgdXJsOiAnL2thbXBhbmovaHNlLzQ1ODI3OCcsXHJcbiAgICAgICAgUGFnZU5hbWU6ICdMU1IgMTAzMCBCw7ZucGFzdGEvbGFzYWduZXBsYXR0b3InLFxyXG4gICAgICAgIE9mZmVySWQ6IDEwMDA1NTUzMDksXHJcbiAgICAgICAgQ2FtcGFpZ25JZDogMTAzMCxcclxuICAgICAgfSxcclxuICAgICAge1xyXG4gICAgICAgIGlkOiA0NTgyNzYsXHJcbiAgICAgICAgcmVjaXBlSWQ6IDcxODM4MixcclxuICAgICAgICB0aXRsZTogJ0J1bGpvbmdrdWJlcicsXHJcbiAgICAgICAgaW1hZ2U6ICdodHRwczovL3d3dy5pY2Euc2UvSGFuZGxlcnMvSW1hZ2UuYXNoeD93PTE1MCZoPTE1MCZtPXAmYmdyPWZmZiZ1PWh0dHA6Ly9leHRiaWxkLmljYS5zZS8vUGljdHVyZVdlYi84MC8xMDI4LzE0XzEwMDA1NTUzMDcuanBnJyxcclxuICAgICAgICBkaXNjb3VudDogJzI1JSByYWJhdHQnLFxyXG4gICAgICAgIHN1YnRpdGxlOiAnS25vcnIgNi1wYWNrJyxcclxuICAgICAgICB1cmw6ICcva2FtcGFuai9oc2UvNDU4Mjc2JyxcclxuICAgICAgICBQYWdlTmFtZTogJ0xTUiAxMDI4IEJ1bGpvbmcnLFxyXG4gICAgICAgIE9mZmVySWQ6IDEwMDA1NTUzMDcsXHJcbiAgICAgICAgQ2FtcGFpZ25JZDogMTAyOCxcclxuICAgICAgfSxcclxuICAgIF0sXHJcbiAgfSxcclxuICB7XHJcbiAgICByZWNpcGVJZDogNzIyODAzLFxyXG4gICAgdGl0bGU6ICdQYXN0YSBtZWQgZmFsYWZlbCBvY2ggw6RydHBlc3RvJyxcclxuICAgIHN0YXJzOiAzLFxyXG4gICAgY29va1RpbWU6ICc0NSBNSU4gfCBNRURFTCcsXHJcbiAgICBpbWFnZTogJ2h0dHBzOi8vd3d3LmljYS5zZS9pbWFnZXZhdWx0ZmlsZXMvaWRfMTY4ODUxL2NmXzI1OS9wYXN0YS1tZWQtZmFsYWZlbC1hcnRwZXN0by03MjI4MDMtNzAweDY1NC5qcGcnLFxyXG4gICAgdXJsOiAnaHR0cHM6Ly93d3cuaWNhLnNlL3JlY2VwdC9wYXN0YS1tZWQtZmFsYWZlbC1vY2gtYXJ0cGVzdG8tNzIyODAzLycsXHJcbiAgICBjb3Vwb25zOiBbXHJcbiAgICAgIHtcclxuICAgICAgICBpZDogNDU4MjgwLFxyXG4gICAgICAgIHJlY2lwZUlkOiA3MjI4MDMsXHJcbiAgICAgICAgdGl0bGU6ICdGYWxhZmVsJyxcclxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vd3d3LmljYS5zZS9IYW5kbGVycy9JbWFnZS5hc2h4P3c9MTUwJmg9MTUwJm09cCZiZ3I9ZmZmJnU9aHR0cDovL2V4dGJpbGQuaWNhLnNlLy9QaWN0dXJlV2ViLzgwLzEwMzEvMTRfMTAwMDU1NTMxMC5qcGcnLFxyXG4gICAgICAgIGRpc2NvdW50OiAnNSBrciByYWJhdHQnLFxyXG4gICAgICAgIHN1YnRpdGxlOiAnRmluZHVzIDQ1MCBnJyxcclxuICAgICAgICB1cmw6ICcva2FtcGFuai9oc2UvNDU4MjgwJyxcclxuICAgICAgICBQYWdlTmFtZTogJ0xTUiAxMDMxIEZhbGFmZWwnLFxyXG4gICAgICAgIE9mZmVySWQ6IDEwMDA1NTUzMTAsXHJcbiAgICAgICAgQ2FtcGFpZ25JZDogMTAzMSxcclxuICAgICAgfSxcclxuICAgICAge1xyXG4gICAgICAgIGlkOiA0NTgyNzcsXHJcbiAgICAgICAgcmVjaXBlSWQ6IDcyMjgwMyxcclxuICAgICAgICB0aXRsZTogJ2lNYXQnLFxyXG4gICAgICAgIGltYWdlOiAnaHR0cHM6Ly93d3cuaWNhLnNlL0hhbmRsZXJzL0ltYWdlLmFzaHg/dz0xNTAmaD0xNTAmbT1wJmJncj1mZmYmdT1odHRwOi8vZXh0YmlsZC5pY2Euc2UvL1BpY3R1cmVXZWIvODAvMTAyOS8xNF8xMDAwNTU1MzA4LmpwZycsXHJcbiAgICAgICAgZGlzY291bnQ6ICcxNSUgcmFiYXR0JyxcclxuICAgICAgICBzdWJ0aXRsZTogJ09hdGx5IDI1MCBnJyxcclxuICAgICAgICB1cmw6ICcva2FtcGFuai9oc2UvNDU4Mjc3JyxcclxuICAgICAgICBQYWdlTmFtZTogJ0xTUiAxMDI5IGlNYXQnLFxyXG4gICAgICAgIE9mZmVySWQ6IDEwMDA1NTUzMDgsXHJcbiAgICAgICAgQ2FtcGFpZ25JZDogMTAyOSxcclxuICAgICAgfSxcclxuICAgIF0sXHJcbiAgfSxcclxuICB7XHJcbiAgICByZWNpcGVJZDogNzIyODY3LFxyXG4gICAgdGl0bGU6ICdGcnlzdCBjaGVlc2VjYWtlIG1lZCBzYWZmcmFuJyxcclxuICAgIHN0YXJzOiA0LFxyXG4gICAgY29va1RpbWU6ICcxLTQgVElNIHwgTUVERUwnLFxyXG4gICAgaW1hZ2U6ICdodHRwczovL3d3dy5pY2Euc2UvaW1hZ2V2YXVsdGZpbGVzL2lkXzE3MDgwMC9jZl8yNTkvZnJ5c3QtY2hlZXNlY2FrZS1tZWQtc2FmZnJhbi03MjI4NjctbGl0ZW4uanBnJyxcclxuICAgIHVybDogJ2h0dHBzOi8vd3d3LmljYS5zZS9yZWNlcHQvZnJ5c3QtY2hlZXNlY2FrZS1tZWQtc2FmZnJhbi03MjI4NjcvJyxcclxuICAgIGNvdXBvbnM6IFtcclxuICAgICAge1xyXG4gICAgICAgIGlkOiA0NTgyODIsXHJcbiAgICAgICAgcmVjaXBlSWQ6IDcyMjg2NyxcclxuICAgICAgICB0aXRsZTogJ0bDpHJza29zdCcsXHJcbiAgICAgICAgaW1hZ2U6ICdodHRwczovL3d3dy5pY2Euc2UvSGFuZGxlcnMvSW1hZ2UuYXNoeD93PTE1MCZoPTE1MCZtPXAmYmdyPWZmZiZ1PWh0dHA6Ly9leHRiaWxkLmljYS5zZS8vUGljdHVyZVdlYi84MC8xMDMzLzE0XzEwMDA1NTUzMTIuanBnJyxcclxuICAgICAgICBkaXNjb3VudDogJzMga3IgcmFiYXR0JyxcclxuICAgICAgICBzdWJ0aXRsZTogJ1BoaWxhZGVscGhpYSAxNzUtMzAwIGcnLFxyXG4gICAgICAgIHVybDogJy9rYW1wYW5qL2hzZS80NTgyODInLFxyXG4gICAgICAgIFBhZ2VOYW1lOiAnTFNSIDEwMzMgRsOkcnNrb3N0IFBoaWxhZGVscGlhJyxcclxuICAgICAgICBPZmZlcklkOiAxMDAwNTU1MzEyLFxyXG4gICAgICAgIENhbXBhaWduSWQ6IDEwMzMsXHJcbiAgICAgIH0sXHJcbiAgICAgIHtcclxuICAgICAgICBpZDogNDU4Mjc0LFxyXG4gICAgICAgIHJlY2lwZUlkOiA3MjI4NjcsXHJcbiAgICAgICAgdGl0bGU6ICdNYXJnYXJpbicsXHJcbiAgICAgICAgaW1hZ2U6ICdodHRwczovL3d3dy5pY2Euc2UvSGFuZGxlcnMvSW1hZ2UuYXNoeD93PTE1MCZoPTE1MCZtPXAmYmdyPWZmZiZ1PWh0dHA6Ly9leHRiaWxkLmljYS5zZS8vUGljdHVyZVdlYi84MC8xMDI2LzE0XzEwMDA1NTUzMDUuanBnJyxcclxuICAgICAgICBkaXNjb3VudDogJzUga3IgcmFiYXR0JyxcclxuICAgICAgICBzdWJ0aXRsZTogJ01pbGRhIDEga2cnLFxyXG4gICAgICAgIHVybDogJy9rYW1wYW5qL2hzZS80NTgyNzQnLFxyXG4gICAgICAgIFBhZ2VOYW1lOiAnTFNSIDEwMjYgTWFyZ2FyaW4nLFxyXG4gICAgICAgIE9mZmVySWQ6IDEwMDA1NTUzMDUsXHJcbiAgICAgICAgQ2FtcGFpZ25JZDogMTAyNixcclxuICAgICAgfSxcclxuICAgIF0sXHJcbiAgfSxcclxuICB7XHJcbiAgICByZWNpcGVJZDogNzE5Mzc0LFxyXG4gICAgdGl0bGU6ICdUb3JzayBpIHVnbiBtZWQgZGlsbC0gb2NoIGNpdHJvbnPDpXMnLFxyXG4gICAgc3RhcnM6IDQsXHJcbiAgICBjb29rVGltZTogJzMwIE1JTiB8IE1FREVMJyxcclxuICAgIGltYWdlOiAnaHR0cHM6Ly93d3cuaWNhLnNlL2ltYWdldmF1bHRmaWxlcy9pZF8xMjI3MjcvY2ZfMjU5L3RvcnNrLWktdWduLW1lZC1kaWxsLW9jaC1jaXRyb25zYXMtdjM4LTIwMTUtNzE5Mzc0LmpwZycsXHJcbiAgICB1cmw6ICdodHRwczovL3d3dy5pY2Euc2UvcmVjZXB0L3RvcnNrLWktdWduLW1lZC1kaWxsLW9jaC1jaXRyb25zYXMtNzE5Mzc0LycsXHJcbiAgICBjb3Vwb25zOiBbXHJcbiAgICAgIHtcclxuICAgICAgICBpZDogNDU4Mjg4LFxyXG4gICAgICAgIHJlY2lwZUlkOiA3MTkzNzQsXHJcbiAgICAgICAgdGl0bGU6ICdUb3Jza2ZpbMOpJyxcclxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vd3d3LmljYS5zZS9IYW5kbGVycy9JbWFnZS5hc2h4P3c9MTUwJmg9MTUwJm09cCZiZ3I9ZmZmJnU9aHR0cDovL2V4dGJpbGQuaWNhLnNlLy9QaWN0dXJlV2ViLzgwLzEwMzgvMTRfMTAwMDU1NTMxNy5qcGcnLFxyXG4gICAgICAgIGRpc2NvdW50OiAnMjUlIHJhYmF0dCcsXHJcbiAgICAgICAgc3VidGl0bGU6ICdJQ0EgNjAwIGcnLFxyXG4gICAgICAgIHVybDogJy9rYW1wYW5qL2hzZS80NTgyODgnLFxyXG4gICAgICAgIFBhZ2VOYW1lOiAnTFNSIDEwMzggVG9yc2tmaWzDqScsXHJcbiAgICAgICAgT2ZmZXJJZDogMTAwMDU1NTMxNyxcclxuICAgICAgICBDYW1wYWlnbklkOiAxMDM4LFxyXG4gICAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAgaWQ6IDQ1ODI3NCxcclxuICAgICAgICByZWNpcGVJZDogNzE5Mzc0LFxyXG4gICAgICAgIHRpdGxlOiAnTWFyZ2FyaW4nLFxyXG4gICAgICAgIGltYWdlOiAnaHR0cHM6Ly93d3cuaWNhLnNlL0hhbmRsZXJzL0ltYWdlLmFzaHg/dz0xNTAmaD0xNTAmbT1wJmJncj1mZmYmdT1odHRwOi8vZXh0YmlsZC5pY2Euc2UvL1BpY3R1cmVXZWIvODAvMTAyNi8xNF8xMDAwNTU1MzA1LmpwZycsXHJcbiAgICAgICAgZGlzY291bnQ6ICc1IGtyIHJhYmF0dCcsXHJcbiAgICAgICAgc3VidGl0bGU6ICdNaWxkYSAxIGtnJyxcclxuICAgICAgICB1cmw6ICcva2FtcGFuai9oc2UvNDU4Mjc0JyxcclxuICAgICAgICBQYWdlTmFtZTogJ0xTUiAxMDI2IE1hcmdhcmluJyxcclxuICAgICAgICBPZmZlcklkOiAxMDAwNTU1MzA1LFxyXG4gICAgICAgIENhbXBhaWduSWQ6IDEwMjYsXHJcbiAgICAgIH0sXHJcbiAgICBdLFxyXG4gIH0sXHJcbiAge1xyXG4gICAgcmVjaXBlSWQ6IDcyMTMxMCxcclxuICAgIHRpdGxlOiAnR2x1dGVuZnJpIHNhZmZyYW5za2FrYScsXHJcbiAgICBzdGFyczogNCxcclxuICAgIGNvb2tUaW1lOiAnMS00IFRJTSB8IE1FREVMJyxcclxuICAgIGltYWdlOiAnaHR0cHM6Ly93d3cuaWNhLnNlL2ltYWdldmF1bHRmaWxlcy9pZF8xNTAzOTcvY2ZfMjU5L2dsdXRlbmZyaS1zYWZmcmFuc2tha2EtNzIxMzEwLWxpdGVuLmpwZycsXHJcbiAgICB1cmw6ICdodHRwczovL3d3dy5pY2Euc2UvcmVjZXB0L2dsdXRlbmZyaS1zYWZmcmFuc2tha2EtNzIxMzEwLycsXHJcbiAgICBjb3Vwb25zOiBbXHJcbiAgICAgIHtcclxuICAgICAgICBpZDogNDU4Mjk4LFxyXG4gICAgICAgIHJlY2lwZUlkOiA3MjEzMTAsXHJcbiAgICAgICAgdGl0bGU6ICdNYW5kZWxtYXNzYScsXHJcbiAgICAgICAgaW1hZ2U6ICdodHRwczovL3d3dy5pY2Euc2UvSGFuZGxlcnMvSW1hZ2UuYXNoeD93PTE1MCZoPTE1MCZtPXAmYmdyPWZmZiZ1PWh0dHA6Ly9leHRiaWxkLmljYS5zZS8vUGljdHVyZVdlYi84MC8xMDQ0LzE0XzEwMDA1NTUzMjMuanBnJyxcclxuICAgICAgICBkaXNjb3VudDogJzI1ICUgcmFiYXR0JyxcclxuICAgICAgICBzdWJ0aXRsZTogJ0lDQSAyMDAgZycsXHJcbiAgICAgICAgdXJsOiAnL2thbXBhbmovaHNlLzQ1ODI5OCcsXHJcbiAgICAgICAgUGFnZU5hbWU6ICdMU1IgMTA0NCBNYW5kZWxtYXNzYScsXHJcbiAgICAgICAgT2ZmZXJJZDogMTAwMDU1NTMyMyxcclxuICAgICAgICBDYW1wYWlnbklkOiAxMDQ0LFxyXG4gICAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAgaWQ6IDQ1ODI3NCxcclxuICAgICAgICByZWNpcGVJZDogNzIxMzEwLFxyXG4gICAgICAgIHRpdGxlOiAnTWFyZ2FyaW4nLFxyXG4gICAgICAgIGltYWdlOiAnaHR0cHM6Ly93d3cuaWNhLnNlL0hhbmRsZXJzL0ltYWdlLmFzaHg/dz0xNTAmaD0xNTAmbT1wJmJncj1mZmYmdT1odHRwOi8vZXh0YmlsZC5pY2Euc2UvL1BpY3R1cmVXZWIvODAvMTAyNi8xNF8xMDAwNTU1MzA1LmpwZycsXHJcbiAgICAgICAgZGlzY291bnQ6ICc1IGtyIHJhYmF0dCcsXHJcbiAgICAgICAgc3VidGl0bGU6ICdNaWxkYSAxIGtnJyxcclxuICAgICAgICB1cmw6ICcva2FtcGFuai9oc2UvNDU4Mjc0JyxcclxuICAgICAgICBQYWdlTmFtZTogJ0xTUiAxMDI2IE1hcmdhcmluJyxcclxuICAgICAgICBPZmZlcklkOiAxMDAwNTU1MzA1LFxyXG4gICAgICAgIENhbXBhaWduSWQ6IDEwMjYsXHJcbiAgICAgIH0sXHJcbiAgICBdLFxyXG4gIH0sXHJcbiAge1xyXG4gICAgcmVjaXBlSWQ6IDcyMjkyMixcclxuICAgIHRpdGxlOiAnTW96YXJ0a3Vsb3InLFxyXG4gICAgc3RhcnM6IDUsXHJcbiAgICBjb29rVGltZTogJzMwIE1JTiB8IE1FREVMJyxcclxuICAgIGltYWdlOiAnaHR0cHM6Ly93d3cuaWNhLnNlL2ltYWdldmF1bHRmaWxlcy9pZF8xNzI0OTkvY2ZfMjU5L21vemFydGt1bG9yLTcyMjkyMi01ODB4NTgwLmpwZycsXHJcbiAgICB1cmw6ICdodHRwczovL3d3dy5pY2Euc2UvcmVjZXB0L21vemFydGt1bG9yLTcyMjkyMi8nLFxyXG4gICAgY291cG9uczogW1xyXG4gICAgICB7XHJcbiAgICAgICAgaWQ6IDQ1ODI5OCxcclxuICAgICAgICByZWNpcGVJZDogNzIyOTIyLFxyXG4gICAgICAgIHRpdGxlOiAnTWFuZGVsbWFzc2EnLFxyXG4gICAgICAgIGltYWdlOiAnaHR0cHM6Ly93d3cuaWNhLnNlL0hhbmRsZXJzL0ltYWdlLmFzaHg/dz0xNTAmaD0xNTAmbT1wJmJncj1mZmYmdT1odHRwOi8vZXh0YmlsZC5pY2Euc2UvL1BpY3R1cmVXZWIvODAvMTA0NC8xNF8xMDAwNTU1MzIzLmpwZycsXHJcbiAgICAgICAgZGlzY291bnQ6ICcyNSAlIHJhYmF0dCcsXHJcbiAgICAgICAgc3VidGl0bGU6ICdJQ0EgMjAwIGcnLFxyXG4gICAgICAgIHVybDogJy9rYW1wYW5qL2hzZS80NTgyOTgnLFxyXG4gICAgICAgIFBhZ2VOYW1lOiAnTFNSIDEwNDQgTWFuZGVsbWFzc2EnLFxyXG4gICAgICAgIE9mZmVySWQ6IDEwMDA1NTUzMjMsXHJcbiAgICAgICAgQ2FtcGFpZ25JZDogMTA0NCxcclxuICAgICAgfSxcclxuICAgICAge1xyXG4gICAgICAgIGlkOiA0NTgyOTcsXHJcbiAgICAgICAgcmVjaXBlSWQ6IDcyMjkyMixcclxuICAgICAgICB0aXRsZTogJ0Jha25vdWdhdCcsXHJcbiAgICAgICAgaW1hZ2U6ICdodHRwczovL3d3dy5pY2Euc2UvSGFuZGxlcnMvSW1hZ2UuYXNoeD93PTE1MCZoPTE1MCZtPXAmYmdyPWZmZiZ1PWh0dHA6Ly9leHRiaWxkLmljYS5zZS8vUGljdHVyZVdlYi84MC8xMDQzLzE0XzEwMDA1NTUzMjIuanBnJyxcclxuICAgICAgICBkaXNjb3VudDogJzUga3IgcmFiYXR0JyxcclxuICAgICAgICBzdWJ0aXRsZTogJ0lDQSAyNTAgZycsXHJcbiAgICAgICAgdXJsOiAnL2thbXBhbmovaHNlLzQ1ODI5NycsXHJcbiAgICAgICAgUGFnZU5hbWU6ICdMU1IgMTA0MyBCYWtub3VnYXQnLFxyXG4gICAgICAgIE9mZmVySWQ6IDEwMDA1NTUzMjIsXHJcbiAgICAgICAgQ2FtcGFpZ25JZDogMTA0MyxcclxuICAgICAgfSxcclxuICAgIF0sXHJcbiAgfSxcclxuXTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3N0YXJ0LXBhZ2UvYmFubmVycy5qcyIsImltcG9ydCB7ICRFTE0gfSBmcm9tICcuLi91dGlsL21haW4nO1xyXG5pbXBvcnQgJy4vY291cG9ucy1zdHlsZS5jc3MnO1xyXG5cclxuY29uc3QgY291cG9ucyA9IHtcclxuICBwcmludEJhbm5lcihjb250ZW50LCB7XHJcbiAgICB0aXRsZSxcclxuICAgIGRpc2NvdW50LFxyXG4gICAgcHJlYW1ibGUsXHJcbiAgICB1cmwsXHJcbiAgICBpbWcsXHJcbiAgICBpc1VzZWQsXHJcbiAgICBpZCxcclxuICAgIGRhdGEsXHJcbiAgfSkge1xyXG4gICAgY29uc3QgaXNVc2VkQ2xhc3MgPSBpc1VzZWQgPyAnIGlzLXVzZWQnIDogJyc7XHJcbiAgICBjb25zdCBbXHJcbiAgICAgIGJhbm5lckVsZW1lbnQsXHJcbiAgICAgIGJhbm5lclJvdyxcclxuICAgICAgYmFubmVyQ29sdW1uMSxcclxuICAgICAgYmFubmVyQ29sdW1uMixcclxuICAgICAgYmFubmVyQ29sdW1uMyxcclxuICAgICAgaW1nRWxlbWVudCxcclxuICAgICAgdGl0bGVFbGVtZW50LFxyXG4gICAgICBkaXNjb3VudEVsZW1lbnQsXHJcbiAgICAgIHByZWFtYmxlRWxlbWVudCxcclxuICAgICAgaW1nSG9sZGVyLFxyXG4gICAgICByZWFkTW9yZSxcclxuICAgICAgZG93bkxvYWQsXHJcbiAgICBdID0gJEVMTS5jcmVhdGUoXHJcbiAgICAgIGBiYW5uZXJgLFxyXG4gICAgICAnYmFubmVyLXJvdycsXHJcbiAgICAgICdiYW5uZXItY29sdW1uJyxcclxuICAgICAgJ2Jhbm5lci1jb2x1bW4gZ3Jvdy1vbmUnLFxyXG4gICAgICAnYmFubmVyLWNvbHVtbicsXHJcbiAgICAgICdiYW5uZXItY29sdW1uX19pbWFnZScsXHJcbiAgICAgIGBoMWAsXHJcbiAgICAgIGBzcGFuYCxcclxuICAgICAgYHBgLFxyXG4gICAgICBgaW1nYCxcclxuICAgICAgJ2EnLFxyXG4gICAgICBgYnV0dG9uIC5idXR0b24gZG93bmxvYWQgJHtpc1VzZWRDbGFzc31gLFxyXG4gICAgKTtcclxuICAgIGNvbnN0IGJ1dHRvblRleHQgPSBpc1VzZWQgPyAnS3Vwb25nIGxhZGRhZCcgOiAnTGFkZGEga3Vwb25nJztcclxuXHJcbiAgICBpbWdIb2xkZXIuaW1hZ2UoaW1nKTtcclxuICAgIGltZ0VsZW1lbnQuYXBwZW5kKGltZ0hvbGRlcik7XHJcblxyXG4gICAgcmVhZE1vcmUuaHJlZihgL2thbXBhbmovaHNlLyR7aWR9YCkudGV4dCgnTMOkcyBtZXInKTtcclxuICAgIGRvd25Mb2FkLmhyZWYodXJsKS50ZXh0KGJ1dHRvblRleHQpO1xyXG5cclxuICAgIHRpdGxlRWxlbWVudC5odG1sKHRpdGxlKTtcclxuICAgIGRpc2NvdW50RWxlbWVudC5odG1sKGRpc2NvdW50KTtcclxuICAgIHByZWFtYmxlRWxlbWVudC5odG1sKHByZWFtYmxlKTtcclxuXHJcbiAgICBiYW5uZXJDb2x1bW4xLmFwcGVuZChpbWdFbGVtZW50KTtcclxuICAgIGJhbm5lckNvbHVtbjIuYXBwZW5kQWxsKHRpdGxlRWxlbWVudCwgZGlzY291bnRFbGVtZW50LCBwcmVhbWJsZUVsZW1lbnQsIHJlYWRNb3JlKTtcclxuICAgIGJhbm5lckNvbHVtbjMuYXBwZW5kKGRvd25Mb2FkKTtcclxuXHJcbiAgICBiYW5uZXJSb3cuYXBwZW5kQWxsKGJhbm5lckNvbHVtbjEsIGJhbm5lckNvbHVtbjIsIGJhbm5lckNvbHVtbjMpO1xyXG4gICAgYmFubmVyRWxlbWVudC5hcHBlbmQoYmFubmVyUm93KTtcclxuICAgIGNvbnRlbnQuYXBwZW5kKGJhbm5lckVsZW1lbnQpO1xyXG5cclxuICAgIGRvd25Mb2FkLmNsaWNrKGV2ZW50ID0+IHRoaXMub25DbGljayhldmVudCwgZGF0YSkpO1xyXG4gICAgJEVMTS5zYXZlKGlkLCBiYW5uZXJFbGVtZW50KTtcclxuXHJcbiAgICBpY2FkYXRhbGF5ZXIuYWRkKCdIU0UnLCB7XHJcbiAgICAgIEhTRToge1xyXG4gICAgICAgIGFjdGlvbjogJ2Rpc3BsYXknLFxyXG4gICAgICAgIHRpdGxlOiBkYXRhLlBhZ2VOYW1lLFxyXG4gICAgICAgIGhzZXVybDogYC9rYW1wYW5qL2hzZS8ke2lkfWAsXHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuICB9LFxyXG4gIGFzeW5jIGxvYWRDb3Vwb25PbkNhcmQoZGF0YSkge1xyXG4gICAgYXdhaXQgdGhpcy5sb2FkKGAvYXBpL2pzb25oc2UvQ2xhaW1vZmZlcmAsIHtcclxuICAgICAgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicsXHJcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgfSxcclxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXHJcbiAgICB9KTtcclxuICB9LFxyXG4gIGNoZWNrQWN0aW9uQ29va2llKCkge1xyXG4gICAgY29uc3QgY291cG9uID0gdGhpcy5zdG9yYWdlLmdldCgnY291cG9uJyk7XHJcbiAgICBpZiAoY291cG9uICYmIHRoaXMuaXNMb2dnZWRJbigpKSB7XHJcbiAgICAgIHRoaXMuc3RvcmFnZS5yZW1vdmUoJ2NvdXBvbicpO1xyXG4gICAgICB0aGlzLmxvYWRDb3Vwb25PbkNhcmQoY291cG9uKTtcclxuICAgIH1cclxuICB9LFxyXG4gIGRlYWN0aXZhdGVDb3Vwb24oaWQpIHtcclxuICAgICRFTE0uZ2V0KGlkKS5nZXQoJ2J1dHRvbicpLmNzcygnaXMtdXNlZCcpO1xyXG4gIH0sXHJcbiAgYXN5bmMgb25DbGljayhldmVudCwgZGF0YSkge1xyXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgIGlmICh0aGlzLmlzTG9nZ2VkSW4oKSkge1xyXG4gICAgICB0aGlzLmRlYWN0aXZhdGVDb3Vwb24oZGF0YS5pZCk7XHJcbiAgICAgIGF3YWl0IHRoaXMubG9hZENvdXBvbk9uQ2FyZChkYXRhKTtcclxuICAgICAgaWNhZGF0YWxheWVyLmFkZCgnSFNFJywge1xyXG4gICAgICAgIEhTRToge1xyXG4gICAgICAgICAgYWN0aW9uOiAnY291cG9uLWxvYWRlZCcsXHJcbiAgICAgICAgICBuYW1lOiBkYXRhLlBhZ2VOYW1lLFxyXG4gICAgICAgICAgb2ZmZXI6IGRhdGEuUHJvZHVjdE5hbWUsXHJcbiAgICAgICAgICBoc2V1cmw6IGAva2FtcGFuai9oc2UvJHtkYXRhLmlkfWAsXHJcbiAgICAgICAgfSxcclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpY2FkYXRhbGF5ZXIuYWRkKCdIU0UnLCB7XHJcbiAgICAgICAgSFNFOiB7XHJcbiAgICAgICAgICBhY3Rpb246ICdsb2dpbi1tb3VzZWRvd24nLFxyXG4gICAgICAgICAgbmFtZTogZGF0YS5QYWdlTmFtZSxcclxuICAgICAgICAgIGhzZXVybDogYC9rYW1wYW5qL2hzZS8ke2RhdGEuaWR9YCxcclxuICAgICAgICB9LFxyXG4gICAgICB9KTtcclxuICAgICAgdGhpcy5zdG9yYWdlLnNldCgnY291cG9uJywgZGF0YSk7XHJcbiAgICAgIHRoaXMuY3JlYXRlTW9kYWwoKTtcclxuICAgIH1cclxuICB9LFxyXG4gIGxvYWRCYW5uZXJzKGlkcywgY29udGVudCkge1xyXG4gICAgaWRzLmZvckVhY2goKGlkKSA9PiB7XHJcbiAgICAgIHRoaXMubG9hZChgaHR0cHM6Ly93d3cuaWNhLnNlL2FwaS9qc29uaHNlLyR7aWR9YCwgeyBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyB9KVxyXG4gICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xyXG4gICAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgICBQYWdlTmFtZSxcclxuICAgICAgICAgICAgSGVhZGVyLFxyXG4gICAgICAgICAgICBPZmZlcixcclxuICAgICAgICAgICAgQ2FtcGFpZ25JZCxcclxuICAgICAgICAgICAgU3RvcmVHcm91cElkLFxyXG4gICAgICAgICAgICBTdG9yZUlkLFxyXG4gICAgICAgICAgfSA9IHJlc3BvbnNlO1xyXG4gICAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgICBQcm9kdWN0TmFtZSxcclxuICAgICAgICAgICAgTG9hZGVkT25DYXJkLFxyXG4gICAgICAgICAgICBPZmZlckNvbmRpdGlvbixcclxuICAgICAgICAgICAgQnJhbmQsXHJcbiAgICAgICAgICAgIFNpemVPclF1YW50aXR5LFxyXG4gICAgICAgICAgICBPZmZlcklkLFxyXG4gICAgICAgICAgfSA9IE9mZmVyO1xyXG5cclxuICAgICAgICAgIGNvbnN0IGRhdGEgPSB7XHJcbiAgICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgICBDYW1wYWlnbklkLFxyXG4gICAgICAgICAgICBQcm9kdWN0TmFtZSxcclxuICAgICAgICAgICAgUGFnZU5hbWUsXHJcbiAgICAgICAgICAgIE9mZmVySWQsXHJcbiAgICAgICAgICAgIFN0b3JlSWQsXHJcbiAgICAgICAgICAgIFN0b3JlR3JvdXBJZCxcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgICB0aGlzLnByaW50QmFubmVyKGNvbnRlbnQsIHtcclxuICAgICAgICAgICAgZGF0YSxcclxuICAgICAgICAgICAgaWQsXHJcbiAgICAgICAgICAgIGlzVXNlZDogTG9hZGVkT25DYXJkLFxyXG4gICAgICAgICAgICB0aXRsZTogSGVhZGVyLFxyXG4gICAgICAgICAgICBkaXNjb3VudDogT2ZmZXJDb25kaXRpb24uQ29uZGl0aW9uc1swXSxcclxuICAgICAgICAgICAgcHJlYW1ibGU6IGAke0JyYW5kfSAke1NpemVPclF1YW50aXR5LlRleHR9YCxcclxuICAgICAgICAgICAgdXJsOiAnJyxcclxuICAgICAgICAgICAgaW1nOiBPZmZlci5JbWFnZS5JbWFnZVVybCxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfSxcclxuICBhZGRJZnJhbWUoKSB7XHJcbiAgICBjb25zdCByZXR1cm5VcmwgPSBlbmNvZGVVUklDb21wb25lbnQod2luZG93LmxvY2F0aW9uLmhyZWYpO1xyXG4gICAgY29uc3QgaWZyYW1lID0gJEVMTS5jcmVhdGUoJ2Nyby1pZnJhbWUtY29udGFpbmVyJyk7XHJcbiAgICBjb25zdCBpZnJhbWVDb250YWluZXIgPSBgPHNwYW4gY2xhc3M9XCJsb2FkZXJcIj48L3NwYW4+PGlmcmFtZSBzcmM9XCIvL3d3dy5pY2Euc2UvbG9nZ2EtaW4vP3JldHVybnVybD0ke3JldHVyblVybH1cIiBmcmFtZWJvcmRlcj1cIjBcIj48L2lmcmFtZT5gO1xyXG4gICAgaWZyYW1lLmh0bWwoaWZyYW1lQ29udGFpbmVyKTtcclxuICAgICRFTE0uZ2V0KCdib2R5JykuYXBwZW5kKGlmcmFtZSk7XHJcbiAgfSxcclxuICBtYW5pcHVsYXRlRG9tKElDQUNSTywgY3JlYXRlTW9kYWwpIHtcclxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgSUNBQ1JPLCB7IGNyZWF0ZU1vZGFsIH0pO1xyXG4gICAgY29uc3QgY29udGVudCA9ICRFTE0uZ2V0KCcjY29udGVudCcpO1xyXG4gICAgY29uc3QgcmVnZXhwID0gL3d3dy5pY2Euc2VcXC9rYW1wYW5qXFwvaHNlL2c7XHJcbiAgICBjb25zdCBiYW5uZXJzID0gdGhpcy5nZXRFbGVtZW50Q29udGVudEJ5VGFnQW5kQXR0cihyZWdleHAsICdhJywgJ2hyZWYnKTtcclxuICAgIGNvbnN0IGlkcyA9IGJhbm5lcnMubWFwKGJhbm5lciA9PiBiYW5uZXIubWF0Y2goL1xcZCskLylbMF0pO1xyXG4gICAgdGhpcy5hZGRJZnJhbWUoKTtcclxuICAgIGNvbnRlbnQuaHRtbCgnICcpO1xyXG4gICAgdGhpcy5sb2FkQmFubmVycyhpZHMsIGNvbnRlbnQpO1xyXG4gICAgdGhpcy5jaGVja0FjdGlvbkNvb2tpZSgpO1xyXG4gIH0sXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjb3Vwb25zO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc3RhcnQtcGFnZS9jb3Vwb25zLmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVnZW5lcmF0b3ItcnVudGltZVwiKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEwOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBUaGlzIG1ldGhvZCBvZiBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QgbmVlZHMgdG8gYmVcbi8vIGtlcHQgaWRlbnRpY2FsIHRvIHRoZSB3YXkgaXQgaXMgb2J0YWluZWQgaW4gcnVudGltZS5qc1xudmFyIGcgPSAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzIH0pKCkgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xuXG4vLyBVc2UgYGdldE93blByb3BlcnR5TmFtZXNgIGJlY2F1c2Ugbm90IGFsbCBicm93c2VycyBzdXBwb3J0IGNhbGxpbmdcbi8vIGBoYXNPd25Qcm9wZXJ0eWAgb24gdGhlIGdsb2JhbCBgc2VsZmAgb2JqZWN0IGluIGEgd29ya2VyLiBTZWUgIzE4My5cbnZhciBoYWRSdW50aW1lID0gZy5yZWdlbmVyYXRvclJ1bnRpbWUgJiZcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZykuaW5kZXhPZihcInJlZ2VuZXJhdG9yUnVudGltZVwiKSA+PSAwO1xuXG4vLyBTYXZlIHRoZSBvbGQgcmVnZW5lcmF0b3JSdW50aW1lIGluIGNhc2UgaXQgbmVlZHMgdG8gYmUgcmVzdG9yZWQgbGF0ZXIuXG52YXIgb2xkUnVudGltZSA9IGhhZFJ1bnRpbWUgJiYgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG5cbi8vIEZvcmNlIHJlZXZhbHV0YXRpb24gb2YgcnVudGltZS5qcy5cbmcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3J1bnRpbWVcIik7XG5cbmlmIChoYWRSdW50aW1lKSB7XG4gIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHJ1bnRpbWUuXG4gIGcucmVnZW5lcmF0b3JSdW50aW1lID0gb2xkUnVudGltZTtcbn0gZWxzZSB7XG4gIC8vIFJlbW92ZSB0aGUgZ2xvYmFsIHByb3BlcnR5IGFkZGVkIGJ5IHJ1bnRpbWUuanMuXG4gIHRyeSB7XG4gICAgZGVsZXRlIGcucmVnZW5lcmF0b3JSdW50aW1lO1xuICB9IGNhdGNoKGUpIHtcbiAgICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLW1vZHVsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvbWFzdGVyL0xJQ0VOU0UgZmlsZS4gQW5cbiAqIGFkZGl0aW9uYWwgZ3JhbnQgb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpblxuICogdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbiEoZnVuY3Rpb24oZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgdmFyIGluTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIjtcbiAgdmFyIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lO1xuICBpZiAocnVudGltZSkge1xuICAgIGlmIChpbk1vZHVsZSkge1xuICAgICAgLy8gSWYgcmVnZW5lcmF0b3JSdW50aW1lIGlzIGRlZmluZWQgZ2xvYmFsbHkgYW5kIHdlJ3JlIGluIGEgbW9kdWxlLFxuICAgICAgLy8gbWFrZSB0aGUgZXhwb3J0cyBvYmplY3QgaWRlbnRpY2FsIHRvIHJlZ2VuZXJhdG9yUnVudGltZS5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gcnVudGltZTtcbiAgICB9XG4gICAgLy8gRG9uJ3QgYm90aGVyIGV2YWx1YXRpbmcgdGhlIHJlc3Qgb2YgdGhpcyBmaWxlIGlmIHRoZSBydW50aW1lIHdhc1xuICAgIC8vIGFscmVhZHkgZGVmaW5lZCBnbG9iYWxseS5cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBEZWZpbmUgdGhlIHJ1bnRpbWUgZ2xvYmFsbHkgKGFzIGV4cGVjdGVkIGJ5IGdlbmVyYXRlZCBjb2RlKSBhcyBlaXRoZXJcbiAgLy8gbW9kdWxlLmV4cG9ydHMgKGlmIHdlJ3JlIGluIGEgbW9kdWxlKSBvciBhIG5ldywgZW1wdHkgb2JqZWN0LlxuICBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZSA9IGluTW9kdWxlID8gbW9kdWxlLmV4cG9ydHMgOiB7fTtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBydW50aW1lLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZVt0b1N0cmluZ1RhZ1N5bWJvbF0gPVxuICAgIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIHJ1bnRpbWUubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBydW50aW1lLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi4gSWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQsIGhvd2V2ZXIsIHRoZVxuICAgICAgICAgIC8vIHJlc3VsdCBmb3IgdGhpcyBpdGVyYXRpb24gd2lsbCBiZSByZWplY3RlZCB3aXRoIHRoZSBzYW1lXG4gICAgICAgICAgLy8gcmVhc29uLiBOb3RlIHRoYXQgcmVqZWN0aW9ucyBvZiB5aWVsZGVkIFByb21pc2VzIGFyZSBub3RcbiAgICAgICAgICAvLyB0aHJvd24gYmFjayBpbnRvIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIGFzIGlzIHRoZSBjYXNlXG4gICAgICAgICAgLy8gd2hlbiBhbiBhd2FpdGVkIFByb21pc2UgaXMgcmVqZWN0ZWQuIFRoaXMgZGlmZmVyZW5jZSBpblxuICAgICAgICAgIC8vIGJlaGF2aW9yIGJldHdlZW4geWllbGQgYW5kIGF3YWl0IGlzIGltcG9ydGFudCwgYmVjYXVzZSBpdFxuICAgICAgICAgIC8vIGFsbG93cyB0aGUgY29uc3VtZXIgdG8gZGVjaWRlIHdoYXQgdG8gZG8gd2l0aCB0aGUgeWllbGRlZFxuICAgICAgICAgIC8vIHJlamVjdGlvbiAoc3dhbGxvdyBpdCBhbmQgY29udGludWUsIG1hbnVhbGx5IC50aHJvdyBpdCBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgZ2VuZXJhdG9yLCBhYmFuZG9uIGl0ZXJhdGlvbiwgd2hhdGV2ZXIpLiBXaXRoXG4gICAgICAgICAgLy8gYXdhaXQsIGJ5IGNvbnRyYXN0LCB0aGVyZSBpcyBubyBvcHBvcnR1bml0eSB0byBleGFtaW5lIHRoZVxuICAgICAgICAgIC8vIHJlamVjdGlvbiByZWFzb24gb3V0c2lkZSB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBzbyB0aGVcbiAgICAgICAgICAvLyBvbmx5IG9wdGlvbiBpcyB0byB0aHJvdyBpdCBmcm9tIHRoZSBhd2FpdCBleHByZXNzaW9uLCBhbmRcbiAgICAgICAgICAvLyBsZXQgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiBoYW5kbGUgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgQXN5bmNJdGVyYXRvci5wcm90b3R5cGVbYXN5bmNJdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIHJ1bnRpbWUuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIHJ1bnRpbWUuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KVxuICAgICk7XG5cbiAgICByZXR1cm4gcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICBpZiAoISBpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIEdwW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yXCI7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgcnVudGltZS5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIHJ1bnRpbWUudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG59KShcbiAgLy8gSW4gc2xvcHB5IG1vZGUsIHVuYm91bmQgYHRoaXNgIHJlZmVycyB0byB0aGUgZ2xvYmFsIG9iamVjdCwgZmFsbGJhY2sgdG9cbiAgLy8gRnVuY3Rpb24gY29uc3RydWN0b3IgaWYgd2UncmUgaW4gZ2xvYmFsIHN0cmljdCBtb2RlLiBUaGF0IGlzIHNhZGx5IGEgZm9ybVxuICAvLyBvZiBpbmRpcmVjdCBldmFsIHdoaWNoIHZpb2xhdGVzIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5LlxuICAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzIH0pKCkgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpXG4pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfcHJvbWlzZSA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL3Byb21pc2VcIik7XG5cbnZhciBfcHJvbWlzZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9taXNlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGdlbiA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIG5ldyBfcHJvbWlzZTIuZGVmYXVsdChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBmdW5jdGlvbiBzdGVwKGtleSwgYXJnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIF9wcm9taXNlMi5kZWZhdWx0LnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBzdGVwKFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgc3RlcChcInRocm93XCIsIGVycik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0ZXAoXCJuZXh0XCIpO1xuICAgIH0pO1xuICB9O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMTEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2NvdXBvbnMtc3R5bGUuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2NvdXBvbnMtc3R5bGUuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2NvdXBvbnMtc3R5bGUuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9zdGFydC1wYWdlL2NvdXBvbnMtc3R5bGUuY3NzXG4vLyBtb2R1bGUgaWQgPSAxMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh1bmRlZmluZWQpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLmNybyAuZ3Jvdy1vbmUgeyBmbGV4LWdyb3c6IDE7IH1cXHJcXG4uY3JvIC5iYW5uZXIgeyBkaXNwbGF5OmZsZXg7IGJhY2tncm91bmQtY29sb3I6ICNGOEVCRjM7IG1hcmdpbi1ib3R0b206IDEwcHg7IH1cXHJcXG4uY3JvIC5iYW5uZXIuaXMtdXNlZCB7IGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjQ3LDI0NywyNDcsMSk7IH1cXHJcXG4uY3JvIC5iYW5uZXItcm93IHtcXHJcXG5kaXNwbGF5OmZsZXg7XFxyXFxud2lkdGg6MTAwJTtcXHJcXG5hbGlnbi1pdGVtczogY2VudGVyO1xcclxcbmJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcclxcbm1hcmdpbjogMTBweCAxNXB4O1xcclxcbnBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG59XFxyXFxuLmNybyAuYmFubmVyLXJvdzo6YWZ0ZXIge1xcclxcbmJhY2tncm91bmQ6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBEOTRiV3dnZG1WeWMybHZiajBpTVM0d0lpQmxibU52WkdsdVp6MGlkWFJtTFRnaVB6NEtQQ0V0TFNCSFpXNWxjbUYwYjNJNklFRmtiMkpsSUVsc2JIVnpkSEpoZEc5eUlESXhMakF1TVN3Z1UxWkhJRVY0Y0c5eWRDQlFiSFZuTFVsdUlDNGdVMVpISUZabGNuTnBiMjQ2SURZdU1EQWdRblZwYkdRZ01Da2dJQzB0UGdvOGMzWm5JSFpsY25OcGIyNDlJakV1TVNJZ2FXUTlJa3hoZVdWeVh6RWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SWdlRzFzYm5NNmVHeHBibXM5SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpFNU9Ua3ZlR3hwYm1zaUlIZzlJakJ3ZUNJZ2VUMGlNSEI0SWdvSklIWnBaWGRDYjNnOUlqQWdNQ0F4TUNBeU1DSWdjM1I1YkdVOUltVnVZV0pzWlMxaVlXTnJaM0p2ZFc1a09tNWxkeUF3SURBZ01UQWdNakE3SWlCNGJXdzZjM0JoWTJVOUluQnlaWE5sY25abElqNEtQSE4wZVd4bElIUjVjR1U5SW5SbGVIUXZZM056SWo0S0NTNXpkREI3Wm1sc2JEb2pSamhGUWtZek8zMEtQQzl6ZEhsc1pUNEtQSEJoZEdnZ1kyeGhjM005SW5OME1DSWdaRDBpVFRJdU5EazNNREl4TERrdU9UZzRPREEzWXpBc05DNHhOREl4TlRFc015NHpOVGM0TkRrc055NDFNREF3TURFc055NDFMRGN1TlRBd01EQXhkaTB4TlFvSlF6VXVPRFUwT0Rjc01pNDBPRGc0TURjc01pNDBPVGN3TWpFc05TNDRORFkyTlRZc01pNDBPVGN3TWpFc09TNDVPRGc0TURkNklpOCtDand2YzNablBnbz1cXFwiKSBzcGFjZTtcXHJcXG5iYWNrZ3JvdW5kLXNpemU6IDEzcHggMjZweDtcXHJcXG5ib3R0b206IDA7XFxyXFxuY29udGVudDogJyc7XFxyXFxuZGlzcGxheTogYmxvY2s7XFxyXFxuaGVpZ2h0OiAxMDAlO1xcclxcbnBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG5yaWdodDogMDtcXHJcXG50b3A6IDA7XFxyXFxud2lkdGg6IDEzcHg7XFxyXFxufVxcclxcbi5jcm8gLmJhbm5lciAuYmFubmVyLWNvbHVtbjpmaXJzdC1jaGlsZCB7IG1hcmdpbi1sZWZ0OiAxMHB4OyB9XFxyXFxuLmNybyAuYmFubmVyIC5iYW5uZXItY29sdW1uOmxhc3QtY2hpbGQgeyAgbWFyZ2luLXJpZ2h0OiAxMHB4OyB9XFxyXFxuLmNybyAuYmFubmVyIC5iYW5uZXItY29sdW1uIHsgcGFkZGluZzogMTBweDsgfVxcclxcbi5jcm8gLmJhbm5lciAuYmFubmVyLWNvbHVtbiAuZG93bmxvYWQge1xcclxcbiAgZm9udC1zaXplOiAxMnB4O1xcclxcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXHJcXG4gIGJhY2tncm91bmQ6ICNGOEVCRjM7XFxyXFxuICBmb250LXdlaWdodDogYm9sZDtcXHJcXG4gIGNvbG9yOiByZ2JhKDE2MCw0MSwxMTMsMSk7XFxyXFxuICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcclxcbiAgbWFyZ2luOiAxMHB4IDEwcHggMTBweCAwO1xcclxcbiAgYm9yZGVyLXJhZGl1czogNnJlbTtcXHJcXG4gIHdpZHRoOiAxMDBweDtcXHJcXG4gIGxpbmUtaGVpZ2h0OiAxLjRyZW07XFxyXFxuICBwYWRkaW5nLWJvdHRvbTogMTBweDtcXHJcXG59XFxyXFxuLmNybyAuYmFubmVyIC5iYW5uZXItY29sdW1uIC5kb3dubG9hZC5pcy11c2VkIHtcXHJcXG4gIGJhY2tncm91bmQ6ICNEREU5QkY7XFxyXFxuICBjb2xvcjogIzhEQjcyQztcXHJcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcbiAgdHJhbnNpdGlvbjogd2lkdGggLjJzIGVhc2UsIGNvbG9yIC4ycyAyNTBtcyBlYXNlLCBiYWNrZ3JvdW5kIC4ycyBlYXNlXFxyXFxufVxcclxcbi5jcm8gLmJhbm5lciAuYmFubmVyLWNvbHVtbiBoMSB7IGZvbnQtc2l6ZTogMS42cmVtOyB3b3JkLWJyZWFrOiBicmVhay1hbGw7fVxcclxcbi5jcm8gLmJhbm5lciAuYmFubmVyLWNvbHVtbiBzcGFuIHtcXHJcXG4gIGNvbG9yOiAjRUIxRjA3O1xcclxcbiAgZm9udC1mYW1pbHk6IGljYXJ1YnJpaztcXHJcXG4gIGZvbnQtc2l6ZTogMi4ycmVtO1xcclxcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxyXFxufVxcclxcbi5jcm8gLmJhbm5lciAuYmFubmVyLWNvbHVtbiBwIHtcXHJcXG4gIGNvbG9yOiAjODA4MjgzO1xcclxcbiAgZm9udC1zaXplOiAxLjNyZW07XFxyXFxuICBtYXJnaW46IDA7XFxyXFxufVxcclxcbi8qcmdiYSgxNDEsMTgzLDQ0LDEpKi9cXHJcXG4uY3JvIC5iYW5uZXIgLmJhbm5lci1jb2x1bW4gaDEuaXMtdXNlZCxcXHJcXG4uY3JvIC5iYW5uZXIgLmJhbm5lci1jb2x1bW4gc3Bhbi5pcy11c2VkLFxcclxcbi5jcm8gLmJhbm5lciAuYmFubmVyLWNvbHVtbiBwLmlzLXVzZWQgeyBjb2xvcjogI0Q1RDdEQTsgfVxcclxcbi5jcm8gLmJhbm5lciAuYmFubmVyLWNvbHVtbiAuYmFubmVyLWNvbHVtbl9fbW9yZS1pbmZvIHsgZm9udC1zaXplOiAyMHB4OyB9XFxyXFxuLmNybyAuYmFubmVyLWNvbHVtbl9faW1hZ2Uge1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXHJcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG4gIHdpZHRoOiAxNTBweDtcXHJcXG4gIGhlaWdodDogMTUwcHg7XFxyXFxufVxcclxcbi5jcm8gLmJhbm5lci1jb2x1bW5fX2ltYWdlIGltZyB7XFxyXFxuICBtYXgtd2lkdGg6IDEwMCU7XFxyXFxuICBtYXgtaGVpZ2h0OiAxMDAlO1xcclxcbiAgd2lkdGg6IGF1dG87XFxyXFxuICBoZWlnaHQ6IGF1dG87XFxyXFxufVxcclxcbi5jcm8gLmJhbm5lci1jb2x1bW5fX2ltYWdlIGltZy5pcy11c2VkIHtcXHJcXG4gIG9wYWNpdHk6IC4zO1xcclxcbn1cXHJcXG5AbWVkaWEgb25seSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDc4MHB4KXtcXHJcXG4gIC5jcm8gLmJhbm5lci1jb2x1bW5fX2ltYWdlIHtcXHJcXG4gICAgd2lkdGg6IDY1cHg7XFxyXFxuICAgIGhlaWdodDogNjVweDtcXHJcXG4gIH1cXHJcXG4gICNwYWdlIHtcXHJcXG4gICAgcGFkZGluZzogMCA1cHggNXB4O1xcclxcbiAgfVxcclxcbiAgLmNybyAuYmFubmVyIC5iYW5uZXItY29sdW1uOmZpcnN0LWNoaWxkIHsgcGFkZGluZzogMTBweDsgbWFyZ2luLWxlZnQ6IDA7IH1cXHJcXG4gIC5jcm8gLmJhbm5lciAuYmFubmVyLWNvbHVtbjpsYXN0LWNoaWxkIHsgcGFkZGluZzogMTBweCAxMHB4IDEwcHggMDsgbWFyZ2luLXJpZ2h0OiAwOyB9XFxyXFxuICAuY3JvIC5iYW5uZXIgLmJhbm5lci1jb2x1bW4geyBwYWRkaW5nOiAxMHB4IDA7IH1cXHJcXG59XFxyXFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlciEuL3NyYy9zdGFydC1wYWdlL2NvdXBvbnMtc3R5bGUuY3NzXG4vLyBtb2R1bGUgaWQgPSAxMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vKipcbiAqIFdoZW4gc291cmNlIG1hcHMgYXJlIGVuYWJsZWQsIGBzdHlsZS1sb2FkZXJgIHVzZXMgYSBsaW5rIGVsZW1lbnQgd2l0aCBhIGRhdGEtdXJpIHRvXG4gKiBlbWJlZCB0aGUgY3NzIG9uIHRoZSBwYWdlLiBUaGlzIGJyZWFrcyBhbGwgcmVsYXRpdmUgdXJscyBiZWNhdXNlIG5vdyB0aGV5IGFyZSByZWxhdGl2ZSB0byBhXG4gKiBidW5kbGUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBwYWdlLlxuICpcbiAqIE9uZSBzb2x1dGlvbiBpcyB0byBvbmx5IHVzZSBmdWxsIHVybHMsIGJ1dCB0aGF0IG1heSBiZSBpbXBvc3NpYmxlLlxuICpcbiAqIEluc3RlYWQsIHRoaXMgZnVuY3Rpb24gXCJmaXhlc1wiIHRoZSByZWxhdGl2ZSB1cmxzIHRvIGJlIGFic29sdXRlIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBwYWdlIGxvY2F0aW9uLlxuICpcbiAqIEEgcnVkaW1lbnRhcnkgdGVzdCBzdWl0ZSBpcyBsb2NhdGVkIGF0IGB0ZXN0L2ZpeFVybHMuanNgIGFuZCBjYW4gYmUgcnVuIHZpYSB0aGUgYG5wbSB0ZXN0YCBjb21tYW5kLlxuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3MpIHtcbiAgLy8gZ2V0IGN1cnJlbnQgbG9jYXRpb25cbiAgdmFyIGxvY2F0aW9uID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubG9jYXRpb247XG5cbiAgaWYgKCFsb2NhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImZpeFVybHMgcmVxdWlyZXMgd2luZG93LmxvY2F0aW9uXCIpO1xuICB9XG5cblx0Ly8gYmxhbmsgb3IgbnVsbD9cblx0aWYgKCFjc3MgfHwgdHlwZW9mIGNzcyAhPT0gXCJzdHJpbmdcIikge1xuXHQgIHJldHVybiBjc3M7XG4gIH1cblxuICB2YXIgYmFzZVVybCA9IGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgbG9jYXRpb24uaG9zdDtcbiAgdmFyIGN1cnJlbnREaXIgPSBiYXNlVXJsICsgbG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvXFwvW15cXC9dKiQvLCBcIi9cIik7XG5cblx0Ly8gY29udmVydCBlYWNoIHVybCguLi4pXG5cdC8qXG5cdFRoaXMgcmVndWxhciBleHByZXNzaW9uIGlzIGp1c3QgYSB3YXkgdG8gcmVjdXJzaXZlbHkgbWF0Y2ggYnJhY2tldHMgd2l0aGluXG5cdGEgc3RyaW5nLlxuXG5cdCAvdXJsXFxzKlxcKCAgPSBNYXRjaCBvbiB0aGUgd29yZCBcInVybFwiIHdpdGggYW55IHdoaXRlc3BhY2UgYWZ0ZXIgaXQgYW5kIHRoZW4gYSBwYXJlbnNcblx0ICAgKCAgPSBTdGFydCBhIGNhcHR1cmluZyBncm91cFxuXHQgICAgICg/OiAgPSBTdGFydCBhIG5vbi1jYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAgICAgW14pKF0gID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICg/OiAgPSBTdGFydCBhbm90aGVyIG5vbi1jYXB0dXJpbmcgZ3JvdXBzXG5cdCAgICAgICAgICAgICAgICAgW14pKF0rICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgICAgICBbXikoXSogID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgXFwpICA9IE1hdGNoIGEgZW5kIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICApICA9IEVuZCBHcm91cFxuICAgICAgICAgICAgICAqXFwpID0gTWF0Y2ggYW55dGhpbmcgYW5kIHRoZW4gYSBjbG9zZSBwYXJlbnNcbiAgICAgICAgICApICA9IENsb3NlIG5vbi1jYXB0dXJpbmcgZ3JvdXBcbiAgICAgICAgICAqICA9IE1hdGNoIGFueXRoaW5nXG4gICAgICAgKSAgPSBDbG9zZSBjYXB0dXJpbmcgZ3JvdXBcblx0IFxcKSAgPSBNYXRjaCBhIGNsb3NlIHBhcmVuc1xuXG5cdCAvZ2kgID0gR2V0IGFsbCBtYXRjaGVzLCBub3QgdGhlIGZpcnN0LiAgQmUgY2FzZSBpbnNlbnNpdGl2ZS5cblx0ICovXG5cdHZhciBmaXhlZENzcyA9IGNzcy5yZXBsYWNlKC91cmxcXHMqXFwoKCg/OlteKShdfFxcKCg/OlteKShdK3xcXChbXikoXSpcXCkpKlxcKSkqKVxcKS9naSwgZnVuY3Rpb24oZnVsbE1hdGNoLCBvcmlnVXJsKSB7XG5cdFx0Ly8gc3RyaXAgcXVvdGVzIChpZiB0aGV5IGV4aXN0KVxuXHRcdHZhciB1bnF1b3RlZE9yaWdVcmwgPSBvcmlnVXJsXG5cdFx0XHQudHJpbSgpXG5cdFx0XHQucmVwbGFjZSgvXlwiKC4qKVwiJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KVxuXHRcdFx0LnJlcGxhY2UoL14nKC4qKSckLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pO1xuXG5cdFx0Ly8gYWxyZWFkeSBhIGZ1bGwgdXJsPyBubyBjaGFuZ2Vcblx0XHRpZiAoL14oI3xkYXRhOnxodHRwOlxcL1xcL3xodHRwczpcXC9cXC98ZmlsZTpcXC9cXC9cXC8pL2kudGVzdCh1bnF1b3RlZE9yaWdVcmwpKSB7XG5cdFx0ICByZXR1cm4gZnVsbE1hdGNoO1xuXHRcdH1cblxuXHRcdC8vIGNvbnZlcnQgdGhlIHVybCB0byBhIGZ1bGwgdXJsXG5cdFx0dmFyIG5ld1VybDtcblxuXHRcdGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi8vXCIpID09PSAwKSB7XG5cdFx0ICBcdC8vVE9ETzogc2hvdWxkIHdlIGFkZCBwcm90b2NvbD9cblx0XHRcdG5ld1VybCA9IHVucXVvdGVkT3JpZ1VybDtcblx0XHR9IGVsc2UgaWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiL1wiKSA9PT0gMCkge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJhc2UgdXJsXG5cdFx0XHRuZXdVcmwgPSBiYXNlVXJsICsgdW5xdW90ZWRPcmlnVXJsOyAvLyBhbHJlYWR5IHN0YXJ0cyB3aXRoICcvJ1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byBjdXJyZW50IGRpcmVjdG9yeVxuXHRcdFx0bmV3VXJsID0gY3VycmVudERpciArIHVucXVvdGVkT3JpZ1VybC5yZXBsYWNlKC9eXFwuXFwvLywgXCJcIik7IC8vIFN0cmlwIGxlYWRpbmcgJy4vJ1xuXHRcdH1cblxuXHRcdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgdXJsKC4uLilcblx0XHRyZXR1cm4gXCJ1cmwoXCIgKyBKU09OLnN0cmluZ2lmeShuZXdVcmwpICsgXCIpXCI7XG5cdH0pO1xuXG5cdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgY3NzXG5cdHJldHVybiBmaXhlZENzcztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL3VybHMuanNcbi8vIG1vZHVsZSBpZCA9IDExNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9zdHlsZS5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge1wiaG1yXCI6dHJ1ZX1cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vc3R5bGUuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL3N0eWxlLmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvc3RhcnQtcGFnZS9zdHlsZS5jc3Ncbi8vIG1vZHVsZSBpZCA9IDExNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHVuZGVmaW5lZCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIvKi5jcm8gaGVhZGVyIC5pbWFnZS1zbGlkZXIge1xcclxcbiAgcG9zaXRpb246IGFic29sdXRlICFpbXBvcnRhbnQ7XFxyXFxufSovXFxyXFxuXFxyXFxuLypcXHJcXG5iYWNrZ3JvdW5kLXBvc2l0aW9uOiAtMzM4cHggLTE4ODVweDsgcHJldlxcclxcblxcclxcblxcclxcbmJhY2tncm91bmQtcG9zaXRpb246IC00MzhweCAtMTg4NXB4O1xcclxcbiAqL1xcclxcblxcclxcbi5jcm8gI2hlYWRlciB7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcXHJcXG59XFxyXFxuXFxyXFxuLnNsaWNrLXNsaWRlLCAuc2xpY2stdHJhY2s6Zm9jdXMge1xcclxcbiAgb3V0bGluZTogbm9uZTtcXHJcXG59XFxyXFxuLnN0YXJ0LXBhZ2UtaWNhc2UgI2hlYWRlciB7XFxyXFxuICBoZWlnaHQ6IDEwMCU7XFxyXFxufVxcclxcbi5jb3Vwb24tYmFubmVyIHtcXHJcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG4gIG1hcmdpbi1ib3R0b206IDMwcHg7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjRjVFOUYwO1xcclxcbn1cXHJcXG4uY291cG9uLWJhbm5lciBpbWcge1xcclxcbiAgbWFyZ2luOiAxMHB4IDAgMDtcXHJcXG59XFxyXFxuXFxyXFxuLmNybyAuc2VhcmNoLXJlY2lwZS1jb250YWluZXIgaW1nIHtcXHJcXG4gIG1hcmdpbi1ib3R0b206IDIwcHg7XFxyXFxufVxcclxcbi5jcm8gLnNlYXJjaC1yZWNpcGUtY29udGFpbmVyIGgxLCAuY291cG9uLWJhbm5lciBoMSB7XFxyXFxuICBmb250LXNpemU6IDIuOHJlbTtcXHJcXG59XFxyXFxuLmNybyAuc2VhcmNoLXJlY2lwZS1jb250YWluZXJfX2FsbC1yZWNpcGVzIHtcXHJcXG4gIGZvbnQtc2l6ZTogMS41cmVtO1xcclxcbn1cXHJcXG4uY3JvIC5wbCAuY29udGFpbmVyLWJhY2tkcm9wIHtcXHJcXG4gIHBhZGRpbmc6IDIwcHggMTBweCAzMHB4O1xcclxcbn1cXHJcXG5cXHJcXG4uc2xpY2stcHJldjpiZWZvcmUsIC5zbGljay1uZXh0OmJlZm9yZSB7IGNvbnRlbnQ6ICcnIH1cXHJcXG4uc2xpY2stcHJldiB7XFxyXFxuICB0b3A6IDE3MHB4O1xcclxcbiAgbGVmdDogLTEwcHg7XFxyXFxuICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtMzM4cHggLTE4ODVweDtcXHJcXG4gIHdpZHRoOiA0MHB4ICFpbXBvcnRhbnQ7XFxyXFxuICBoZWlnaHQ6IDQwcHggIWltcG9ydGFudDtcXHJcXG59XFxyXFxuLnNsaWNrLW5leHQge1xcclxcbiAgdG9wOiAxNzBweDtcXHJcXG4gIHJpZ2h0OiA1cHg7XFxyXFxuICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtNDM4cHggLTE4ODVweDtcXHJcXG4gIHdpZHRoOiA0MHB4ICFpbXBvcnRhbnQ7XFxyXFxuICBoZWlnaHQ6IDQwcHggIWltcG9ydGFudDtcXHJcXG59XFxyXFxuXFxyXFxuLmNybyAuc2xpY2stcHJldjpob3ZlcixcXHJcXG4uY3JvIC5zbGljay1wcmV2OmZvY3VzLFxcclxcbi5jcm8gLnNsaWNrLXByZXY6YWN0aXZlIHtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcclxcbiAgYmFja2dyb3VuZC1wb3NpdGlvbjogLTMzOHB4IC0xODg1cHg7XFxyXFxufVxcclxcbi5jcm8gLnNsaWNrLW5leHQ6aG92ZXIsXFxyXFxuLmNybyAuc2xpY2stbmV4dDpmb2N1cyxcXHJcXG4uY3JvIC5zbGljay1uZXh0OmFjdGl2ZSB7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXHJcXG4gIGJhY2tncm91bmQtcG9zaXRpb246IC00MzhweCAtMTg4NXB4O1xcclxcbn1cXHJcXG4uY3JvIC5zbGljay1hcnJvdyB7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXHJcXG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnL1RlbXBsYXRlcy9HZW5lcmFsL1ZpZXdzL0ltYWdlcy9SV0Qvc3ByaXRlcy9nZW5lcmFsX3Nwcml0ZTEucG5nPzEnKTtcXHJcXG4gIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxyXFxufVxcclxcbmJ1dHRvbjpmb2N1cywgYnV0dG9uOmFjdGl2ZSB7b3V0bGluZTowO31cXHJcXG4uc2xpY2staW5pdGlhbGl6ZWQgLnNsaWNrLXNsaWRlciB7XFxyXFxuICBvdXRsaW5lOiBub25lO1xcclxcbn1cXHJcXG4uY3JvIC5iYW5uZXItY29udGFpbmVyIHtcXHJcXG4gIHdpZHRoOiAxMDAlO1xcclxcbiAgaGVpZ2h0OiAxMDAlO1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XFxyXFxuICB6LWluZGV4OiAyMCAhaW1wb3J0YW50O1xcclxcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcclxcbn1cXHJcXG5cXHJcXG4uY3JvIC5iYW5uZXItY29udGFpbmVyX19pbWcge1xcclxcbiAgd2lkdGg6IGluaGVyaXQ7XFxyXFxuICBoZWlnaHQ6IDMyMHB4O1xcclxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgdG9wOiAwO1xcclxcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IGJsYWNrO1xcclxcbn1cXHJcXG5cXHJcXG4uY3JvIC5iYW5uZXItY29udGFpbmVyX19pbWcgaW1nIHsgaGVpZ2h0OiBhdXRvOyB3aWR0aDogMTAwJTsgb3BhY2l0eTogLjg7IH1cXHJcXG5cXHJcXG4uY3JvIC5iYW5uZXItY29udGFpbmVyX190ZXh0LWNvbnRhaW5lciB7XFxyXFxuICBtYXgtd2lkdGg6IDEwMCU7XFxyXFxuICBtYXJnaW46IDcwcHggMzVweCAxMHB4O1xcclxcbiAgdGV4dC1zaGFkb3c6IDAgMCA1cHggcmdiYSgwLCAwLCAwLCAwLjQpO1xcclxcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcclxcbn1cXHJcXG5cXHJcXG4uY3JvIC50ZXh0LWNvbnRhaW5lcl9fdGl0bGUge1xcclxcbiAgZm9udC1zaXplOiAzNnB4O1xcclxcbiAgY29sb3I6IHdoaXRlO1xcclxcbiAgZm9udC1mYW1pbHk6IGljYXJ1YnJpaztcXHJcXG4gIGZvbnQtd2VpZ2h0OiA2MDA7XFxyXFxuICBsaW5lLWhlaWdodDogM3JlbTtcXHJcXG4gIHdoaXRlLXNwYWNlOiBub3JtYWw7XFxyXFxufVxcclxcblxcclxcbi5jcm8gLnRleHQtY29udGFpbmVyX19yYXRpbmdzIHN2ZyAuYWN0aXZlIHtcXHJcXG4gIGZpbGw6ICNFQjFGMDc7XFxyXFxufVxcclxcblxcclxcbi5jcm8gLnRleHQtY29udGFpbmVyX19yYXRpbmdzIHN2ZyB7XFxyXFxuICAvKmRpc3BsYXk6IGlubGluZS1ibG9jazsqL1xcclxcbiAgZGlzcGxheTogYmxvY2s7XFxyXFxuICBmaWxsOiAjRDVEN0RBO1xcclxcbiAgaGVpZ2h0OiAxOHB4O1xcclxcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXHJcXG4gIHdpZHRoOiA5MXB4O1xcclxcbiAgLXdlYmtpdC1maWx0ZXI6IGRyb3Atc2hhZG93KCAxcHggMXB4IDJweCByZ2JhKDAsMCwwLDAuNCkgKTtcXHJcXG4gIGZpbHRlcjogZHJvcC1zaGFkb3coIDFweCAxcHggMnB4IHJnYmEoMCwwLDAsMC40KSApO1xcclxcbn1cXHJcXG5cXHJcXG4uY3JvIC50ZXh0LWNvbnRhaW5lcl9fZGlmZmljdWx0eSB7XFxyXFxuICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xcclxcbiAgZm9udDogMTZweCBpY2F0ZXh0O1xcclxcbiAgZm9udC13ZWlnaHQ6IDkwMDtcXHJcXG4gIG1hcmdpbi10b3A6IDZweDtcXHJcXG4gIGNvbG9yOiB3aGl0ZTtcXHJcXG59XFxyXFxuXFxyXFxuLmNybyAuY291cG9ucy1jb250YWluZXIge1xcclxcbiAgd2lkdGg6IDEwMCU7XFxyXFxuICB6LWluZGV4OiA5OTk7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgZmxleC1kaXJlY3Rpb246IHJvdztcXHJcXG4gIHBhZGRpbmc6IDVweDtcXHJcXG4gIC8qbWFyZ2luLWJvdHRvbTogMjBweDsqL1xcclxcbn1cXHJcXG5cXHJcXG4uY3JvIC5jb3Vwb25zLWNvbnRhaW5lcl9faXRlbSB7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcXHJcXG4gIHdpZHRoOiA1MCU7XFxyXFxuICBtYXJnaW46IDAgNHB4O1xcclxcbiAgcGFkZGluZzogMTBweDtcXHJcXG4gIGJvcmRlcjogOHB4IHNvbGlkIHJnYmEoMjE3LDIwLDk5LDAuMSk7XFxyXFxuICBib3JkZXItYm90dG9tLXdpZHRoOiAxN3B4O1xcclxcbiAgYm9yZGVyLXJhZGl1czogNnB4O1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxyXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxuICBqdXN0aWZ5LWNvbnRlbnQ6ZmxleC1zdGFydDtcXHJcXG59XFxyXFxuXFxyXFxuLmNybyAucmVjaXBlLXRyZW5kaW5nLWxpc3QgaDIge1xcclxcbiAgZm9udC1zaXplOiAxLjhyZW07XFxyXFxufVxcclxcblxcclxcbi5jcm8gLmNvdXBvbnMtY29udGFpbmVyX19pdGVtOmFmdGVyIHtcXHJcXG4gIGJhY2tncm91bmQ6IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBEOTRiV3dnZG1WeWMybHZiajBpTVM0d0lpQmxibU52WkdsdVp6MGlkWFJtTFRnaVB6NDhjM1puSUhabGNuTnBiMjQ5SWpFdU1TSWdhV1E5SWt4aGVXVnlYekVpSUhodGJHNXpQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh5TURBd0wzTjJaeUlnZUcxc2JuTTZlR3hwYm1zOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6RTVPVGt2ZUd4cGJtc2lJSGc5SWpCd2VDSWdlVDBpTUhCNElpQjJhV1YzUW05NFBTSXdJREFnTWpBZ01UQWlJSE4wZVd4bFBTSmxibUZpYkdVdFltRmphMmR5YjNWdVpEcHVaWGNnTUNBd0lESXdJREV3T3lJZ2VHMXNPbk53WVdObFBTSndjbVZ6WlhKMlpTSStQSE4wZVd4bElIUjVjR1U5SW5SbGVIUXZZM056SWo0dWMzUXdlMlpwYkd3NkkyWm1aanQ5UEM5emRIbHNaVDQ4Y0dGMGFDQmpiR0Z6Y3owaWMzUXdJaUJrUFNKTk1UQXNNaTQxWXkwMExqRXNNQzAzTGpVc015NDBMVGN1TlN3M0xqVm9NVFZETVRjdU5TdzFMamtzTVRRdU1pd3lMalVzTVRBc01pNDFlaUl2UGp3dmMzWm5QZz09KSBzcGFjZTtcXHJcXG4gIGJhY2tncm91bmQtc2l6ZTogMjZweCAxM3B4O1xcclxcbiAgY29udGVudDogJyc7XFxyXFxuICBkaXNwbGF5OiBibG9jaztcXHJcXG4gIHdpZHRoOiAxNDAlO1xcclxcbiAgaGVpZ2h0OiAxM3B4O1xcclxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgYm90dG9tOiAtMTdweDtcXHJcXG4gIGxlZnQ6IC0zMHB4O1xcclxcbn1cXHJcXG5cXHJcXG4uY3JvIC5jb3Vwb25zLWNvbnRhaW5lcl9faXRlbS13cmFwcGVyIHtcXHJcXG4gIGFsaWduLXNlbGY6IGZsZXgtc3RhcnQ7XFxyXFxuICBtYXJnaW4tYm90dG9tOiA2MHB4O1xcclxcbn1cXHJcXG5cXHJcXG4uY291cG9ucy1jb250YWluZXJfX2l0ZW0taW1hZ2Utd3JhcHBlciB7XFxyXFxuICBhbGlnbi1zZWxmOiBmbGV4LXN0YXJ0O1xcclxcbn1cXHJcXG4uY3JvIC5jb3Vwb25zLWNvbnRhaW5lcl9faXRlbSBpbWcge1xcclxcbiAgd2lkdGg6IDYwJSAhaW1wb3J0YW50O1xcclxcbiAgaGVpZ2h0OiBhdXRvICFpbXBvcnRhbnQ7XFxyXFxuICBtYXJnaW46IDAgYXV0byAxMHB4ICFpbXBvcnRhbnQ7XFxyXFxufVxcclxcblxcclxcbi5jcm8gLmNvdXBvbnMtY29udGFpbmVyIC5jb3Vwb25zLWNvbnRhaW5lcl9faXRlbSBoMyB7XFxyXFxuICBmb250LXNpemU6IDE2cHg7XFxyXFxuICBsaW5lLWhlaWdodDogMWVtO1xcclxcbiAgbWFyZ2luLWJvdHRvbTogNnB4O1xcclxcbn1cXHJcXG5cXHJcXG4uY3JvIC5jb3Vwb25zLWNvbnRhaW5lciAuY291cG9ucy1jb250YWluZXJfX2l0ZW0gaDEge1xcclxcbiAgZm9udC1zaXplOiAyMnB4O1xcclxcbiAgZm9udC13ZWlnaHQ6IDcwMDtcXHJcXG4gIGNvbG9yOiAjRUIxRjA3O1xcclxcbiAgbGluZS1oZWlnaHQ6IDEuNXJlbTtcXHJcXG59XFxyXFxuXFxyXFxuLmNybyAuY291cG9ucy1jb250YWluZXIgLmNvdXBvbnMtY29udGFpbmVyX19pdGVtIGg0IHtcXHJcXG4gIGNvbG9yOiAjODA4MjgzO1xcclxcbiAgZm9udC1zaXplOiAxLjNyZW07XFxyXFxuICBsaW5lLWhlaWdodDogMS40O1xcclxcbiAgZm9udC1mYW1pbHk6IGljYXRleHQ7XFxyXFxuICBmb250LXdlaWdodDogbm9ybWFsO1xcclxcbn1cXHJcXG5cXHJcXG4uY3JvIC5jb3Vwb25zLWNvbnRhaW5lciAuY291cG9ucy1jb250YWluZXJfX2l0ZW0gYSB7XFxyXFxuICBmb250LXNpemU6IDE0cHg7XFxyXFxuICBsaW5lLWhlaWdodDogMTVweDtcXHJcXG4gIG1hcmdpbi1ib3R0b206IDVweDtcXHJcXG59XFxyXFxuXFxyXFxuLmNybyAuY291cG9ucy1jb250YWluZXIgLmNvdXBvbnMtY29udGFpbmVyX19pdGVtIC5jb3Vwb24tYnV0dG9uIHtcXHJcXG4gIGZvbnQtc2l6ZTogMTJweDtcXHJcXG4gIGxpbmUtaGVpZ2h0OiAyLjJyZW07XFxyXFxuICBtaW4td2lkdGg6IGF1dG87XFxyXFxuICBhbGlnbi1zZWxmOiBjZW50ZXI7XFxyXFxuICB3aWR0aDogOTAlO1xcclxcbiAgYmFja2dyb3VuZDogI0Y4RUJGMztcXHJcXG4gIGNvbG9yOiAjQTAyOTcxO1xcclxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgYm90dG9tOiAxNXB4O1xcclxcbn1cXHJcXG5cXHJcXG4uY3JvIC5jb3Vwb25zLWNvbnRhaW5lciAuY291cG9ucy1jb250YWluZXJfX2l0ZW0ub2ZmZXItbG9hZGVkIC5jb3Vwb24tYnV0dG9uIHtcXHJcXG4gIGJhY2tncm91bmQ6ICNEREU5QkY7XFxyXFxuICBjb2xvcjogIzhEQjcyQztcXHJcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcbiAgdHJhbnNpdGlvbjogd2lkdGggLjJzIGVhc2UsIGNvbG9yIC4ycyAyNTBtcyBlYXNlLCBiYWNrZ3JvdW5kIC4ycyBlYXNlO1xcclxcbn1cXHJcXG5cXHJcXG4uY3JvIC5jb3Vwb25zLWNvbnRhaW5lciAuY291cG9ucy1jb250YWluZXJfX2l0ZW0gLmNvdXBvbnMtaW1hZ2Uge1xcclxcbiAgd2lkdGg6IDEwMCU7XFxyXFxuICBoZWlnaHQ6IDYwcHg7XFxyXFxuICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcclxcbiAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xcclxcbiAgYmFja2dyb3VuZC1wb3NpdGlvbjogY2VudGVyO1xcclxcbn1cXHJcXG5cXHJcXG4uY3JvIC5iYW5uZXItd3JhcHBlciAuYmFubmVyLWltYWdlIGltZyB7XFxyXFxuICB3aWR0aDogMTAwJTtcXHJcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG4gIG1hcmdpbi1sZWZ0OiAwICFpbXBvcnRhbnQ7XFxyXFxuICBoZWlnaHQ6IGF1dG8gIWltcG9ydGFudDtcXHJcXG4gIG1hcmdpbi10b3A6IDAgIWltcG9ydGFudDtcXHJcXG4gIG1pbi13aWR0aDogMzc1cHg7XFxyXFxufVxcclxcblxcclxcbi5jcm8gLmJ1dHRvbi13cmFwcGVyIHtcXHJcXG4gIG1hcmdpbjogMTBweCAwIDMwcHggMzVweDtcXHJcXG59XFxyXFxuXFxyXFxuLmNybyAuYmFubmVyLWJ1dHRvbiB7XFxyXFxuICB3aWR0aDogNjAlO1xcclxcbiAgZGlzcGxheTogYmxvY2s7XFxyXFxuICBvdmVyZmxvdzogaGlkZGVuO1xcclxcbn1cXHJcXG4uY3JvIC5iYW5uZXItYnV0dG9uIC5sYXllciB7XFxyXFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICB0b3A6IC0zMHB4O1xcclxcbiAgcmlnaHQ6IDIwJTtcXHJcXG4gIHRyYW5zaXRpb246IGFsbCAwLjVzIGVhc2U7XFxyXFxufVxcclxcbi5jcm8gLmJhbm5lci1idXR0b24uc2F2ZWQge1xcclxcbiAgYmFja2dyb3VuZDogI0RERTlCRjtcXHJcXG4gIGNvbG9yOiAjOERCNzJDO1xcclxcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxyXFxuICB0cmFuc2l0aW9uOiB3aWR0aCAuMnMgZWFzZSwgY29sb3IgLjJzIDI1MG1zIGVhc2UsIGJhY2tncm91bmQgLjJzIGVhc2U7XFxyXFxuICBmb250LXdlaWdodDogNDAwO1xcclxcbn1cXHJcXG5cXHJcXG4uY3JvIC5iYW5uZXItYnV0dG9uLmFkZGVkIC5sYXllcntcXHJcXG4gIHRvcDogMDtcXHJcXG59XFxyXFxuXFxyXFxuLmNybyAub2ZmZXJzLWJ1dHRvbiB7XFxyXFxuICB3aWR0aDogOTAlO1xcclxcbiAgbWFyZ2luLWJvdHRvbTogMjBweDtcXHJcXG59XFxyXFxuXFxyXFxuLmNybyAucmF0aW5nLXN0YXItY29udGFpbmVyIHtcXHJcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gIHotaW5kZXg6IDUwO1xcclxcbiAgbWFyZ2luOjEwcHg7XFxyXFxuICB0b3A6IDMwcHg7XFxyXFxuICBjb2xvcjogd2hpdGU7XFxyXFxuICB0ZXh0LXNoYWRvdzogMCAwIDVweCByZ2JhKDAsIDAsIDAsIDAuNCk7XFxyXFxufVxcclxcblxcclxcbi5jcm8gLmljYS1jYXJkLWNvbnRhaW5lciB7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG4gIG1pbi1oZWlnaHQ6IDI1MHB4O1xcclxcbn1cXHJcXG5cXHJcXG4uY3JvIC5pY2EtY2FyZC1jb250YWluZXIgaDEge1xcclxcbiAgY29sb3I6ICNFQjFGMDc7XFxyXFxufVxcclxcblxcclxcbi5jcm8gLmljYS1jYXJkLWNvbnRhaW5lciBhIHtcXHJcXG4gIGFsaWduLXNlbGY6IGZsZXgtc3RhcnQ7XFxyXFxuICBtYXgtd2lkdGg6IDI1MHB4O1xcclxcbiAgbWFyZ2luLXRvcDotMTYwcHg7XFxyXFxufVxcclxcblxcclxcbi5jcm8gLmljYS1jYXJkLWNvbnRhaW5lciBpbWcge1xcclxcbiAgbWF4LXdpZHRoOiAzODVweDtcXHJcXG4gIHdpZHRoOiA4MCU7XFxyXFxuICBhbGlnbi1zZWxmOiBmbGV4LWVuZDtcXHJcXG4gIG1hcmdpbi10b3A6LTEyMHB4O1xcclxcbn1cXHJcXG5cXHJcXG5AbWVkaWEgb25seSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDk2MHB4KXtcXHJcXG4gIC5jcm8gLmljYS1jYXJkLWNvbnRhaW5lciB7XFxyXFxuICAgIG1pbi1oZWlnaHQ6IG5vbmU7XFxyXFxuICB9XFxyXFxuXFxyXFxuICAuY3JvIC5pY2EtY2FyZC1jb250YWluZXIgaDEge1xcclxcbiAgICBsaW5lLWhlaWdodDogM3JlbTtcXHJcXG4gICAgZm9udC1zaXplOiAzcmVtO1xcclxcbiAgICBtYXJnaW4tYm90dG9tOiAyMHB4O1xcclxcbiAgfVxcclxcblxcclxcbiAgLmNybyAuaWNhLWNhcmQtY29udGFpbmVyIGEge1xcclxcbiAgICBhbGlnbi1zZWxmOiBjZW50ZXI7XFxyXFxuICAgIG1hcmdpbi10b3A6IDIwcHg7XFxyXFxuICAgIG1heC13aWR0aDogbm9uZTtcXHJcXG4gICAgd2lkdGg6IDEwMCU7XFxyXFxuICB9XFxyXFxuXFxyXFxuICAuY3JvIC5pY2EtY2FyZC1jb250YWluZXIgaW1nIHtcXHJcXG4gICAgYWxpZ24tc2VsZjogY2VudGVyO1xcclxcbiAgICBtYXJnaW4tdG9wOmF1dG87XFxyXFxuICB9XFxyXFxuXFxyXFxuICAuY3JvIC5vZmZlcnMtY29udGFpbmVyIHtcXHJcXG4gICAgd2lkdGg6IDEwMCU7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcclxcbiAgICAtd2Via2l0LWZpbHRlcjogZHJvcC1zaGFkb3coIDFweCAxcHggMnB4IHJnYmEoMCwwLDAsMC40KSApO1xcclxcbiAgICBmaWx0ZXI6IGRyb3Atc2hhZG93KCAxcHggMXB4IDJweCByZ2JhKDAsMCwwLDAuNCkgKTtcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIC5zdGFydC1wYWdlLWljYXNlID4gaGVhZGVyLmZ1bGwtc2l6ZS1pbWFnZSAuaW1hZ2Utc2xpZGVyLFxcclxcbiAgLnN0YXJ0LXBhZ2UtaWNhc2UgPiBoZWFkZXIuZnVsbC1zaXplLWltYWdlIC5pbWFnZS1zbGlkZXIgdWwsXFxyXFxuICAuc3RhcnQtcGFnZS1pY2FzZSA+IGhlYWRlci5mdWxsLXNpemUtaW1hZ2UgLmltYWdlLXNsaWRlciBsaSB7XFxyXFxuICAgIG1heC1oZWlnaHQ6IDEwMCU7XFxyXFxuICAgIHdpZHRoOiAxMDAlICFpbXBvcnRhbnQ7XFxyXFxuICAgIGhlaWdodDogMTAwJSAhaW1wb3J0YW50O1xcclxcbiAgfVxcclxcbn1cXHJcXG4uY3JvIC51bnNsaWRlci1jb250cm9scyB7IHBvaW50ZXItZXZlbnRzOiBub25lOyB9XFxyXFxuLmNybyAudW5zbGlkZXItYXJyb3cgeyBwb2ludGVyLWV2ZW50czogYXV0bzsgfVxcclxcblxcclxcbkBtZWRpYSAobWF4LXdpZHRoOiA3NjdweCkgeyAuY3JvIC5jcm8taWZyYW1lLWNvbnRhaW5lciB7IHBhZGRpbmctYm90dG9tOiAxMzUlICFpbXBvcnRhbnQ7IH0gfVxcclxcbi5jcm8gPiAuY3JvLWlmcmFtZS1jb250YWluZXIgeyBkaXNwbGF5OiBub25lOyB9XFxyXFxuLmNybyAubW9kYWwtY29wbnRhaW5lciAuY3JvLWlmcmFtZS1jb250YWluZXIgeyBkaXNwbGF5OiBpbml0aWFsOyB9XFxyXFxuLmNybyAuY29udGFpbmVyIHsgdGV4dC1hbGlnbjogY2VudGVyOyBtYXJnaW4tdG9wOiA1MHB4O31cXHJcXG4uY3JvIC5jb250YWluZXIgaDIgeyBmb250OiAyOHB4IGljYWhhbmQ7IG1hcmdpbi1ib3R0b206IDIwcHg7IH1cXHJcXG4uY3JvIC5jcm8taWZyYW1lLWNvbnRhaW5lciB7XFxyXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxuICBoZWlnaHQ6IDA7XFxyXFxuICBvdmVyZmxvdzogaGlkZGVuO1xcclxcbiAgcGFkZGluZy1ib3R0b206IDg1JTtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6ICNGM0YwRUI7XFxyXFxufVxcclxcbi5jcm8gLmNyby1pZnJhbWUtY29udGFpbmVyIGlmcmFtZSB7XFxyXFxuICBvcGFjaXR5OiAwO1xcclxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgdG9wOiAwO1xcclxcbiAgbGVmdDogMDtcXHJcXG4gIHdpZHRoOiAxMDAlO1xcclxcbiAgaGVpZ2h0OiAxMDAlO1xcclxcbn1cXHJcXG5cXHJcXG4uY3JvIC51c3AtbGlzdCB7IG1hcmdpbi1ib3R0b206IDEwcHg7IH1cXHJcXG5cXHJcXG4uY3JvIC51c3AtbGlzdCBsaSB7XFxyXFxuICBmb250OiAyNHB4IGljYXJ1YnJpaztcXHJcXG4gIGZvbnQtd2VpZ2h0OiA2MDA7XFxyXFxuICBtYXJnaW4tYm90dG9tOiAxNXB4O1xcclxcbn1cXHJcXG4uY3JvIC51c3AtbGlzdCBzdmcge1xcclxcbiAgZmlsbDogIzhEQjcyQztcXHJcXG4gIG1hcmdpbi1yaWdodDogNXB4O1xcclxcbn1cXHJcXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyIS4vc3JjL3N0YXJ0LXBhZ2Uvc3R5bGUuY3NzXG4vLyBtb2R1bGUgaWQgPSAxMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiY29uc3Qgc3RvcmFnZSA9ICgpID0+IHtcclxuICBjb25zdCBmYWxsQmFjayA9IHtcclxuICAgIHN0b3JhZ2U6IHt9LFxyXG4gICAgc2V0SXRlbShrZXksIHZhbHVlKSB7XHJcbiAgICAgIHRoaXMuc3RvcmFnZVtrZXldID0gdmFsdWU7XHJcbiAgICB9LFxyXG4gICAgZ2V0SXRlbShrZXkpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZVtrZXldO1xyXG4gICAgfSxcclxuICB9O1xyXG4gIGNvbnN0IGNob29zZVN0b3JhZ2UgPSAodHlwZU9mU3RvcmFnZSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKHR5cGVPZlN0b3JhZ2UgaW4gd2luZG93ICYmIHdpbmRvd1t0eXBlT2ZTdG9yYWdlXSAhPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiB3aW5kb3dbdHlwZU9mU3RvcmFnZV07XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZhbGxCYWNrO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHNldFVwKHR5cGVPZlN0b3JhZ2UgPSAnc2Vzc2lvblN0b3JhZ2UnKSB7XHJcbiAgICAgIGNvbnN0IHN0b3JhZ2VUeXBlID0gY2hvb3NlU3RvcmFnZSh0eXBlT2ZTdG9yYWdlKTtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzZXQoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgc3RvcmFnZVR5cGUuc2V0SXRlbShrZXksIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXQoa2V5KSB7XHJcbiAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShzdG9yYWdlVHlwZS5nZXRJdGVtKGtleSkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVtb3ZlKGtleSkge1xyXG4gICAgICAgICAgc3RvcmFnZVR5cGUucmVtb3ZlSXRlbShrZXkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgIH07XHJcbiAgICB9LFxyXG4gIH07XHJcbn07XHJcblxyXG5jb25zdCBkYiA9IHN0b3JhZ2UoKTtcclxuZXhwb3J0IGRlZmF1bHQgZGIuc2V0VXAoKTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3V0aWwvbW9kdWxlcy9zdG9yYWdlLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==